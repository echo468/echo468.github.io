<!DOCTYPE html>


<html lang="en">


<head>
  <meta charset="utf-8" />
    
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />
  <title>
     Hexo
  </title>
  <meta name="generator" content="hexo-theme-ayer">
  
  <link rel="shortcut icon" href="/favicon.ico" />
  
  
<link rel="stylesheet" href="/dist/main.css">

  
<link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Shen-Yu/cdn/css/remixicon.min.css">

  
<link rel="stylesheet" href="/css/custom.css">

  
  
<script src="https://cdn.jsdelivr.net/npm/pace-js@1.0.2/pace.min.js"></script>

  
  

  

</head>

</html>

<body>
  <div id="app">
    
      <canvas class="fireworks"></canvas>
      <style>
        .fireworks {
          position: fixed;
          left: 0;
          top: 0;
          z-index: 99999;
          pointer-events: none;
        }
      </style>
      
      
    <main class="content on">
      
<section class="cover">
    
      
      <a class="forkMe" href="https://github.com/Shen-Yu/hexo-theme-ayer"
        target="_blank"><img width="149" height="149" src="/images/forkme.png"
          class="attachment-full size-full" alt="Fork me on GitHub" data-recalc-dims="1"></a>
    
  <div class="cover-frame">
    <div class="bg-box">
      <img src="/images/cover1.jpg" alt="image frame" />
    </div>
    <div class="cover-inner text-center text-white">
      <h1><a href="/">Hexo</a></h1>
      <div id="subtitle-box">
        
        <span id="subtitle"></span>
        
      </div>
      <div>
        
        <img
          src="/images/ayer.svg"
          class="cover-logo"
          alt="Hexo"
        />
        
      </div>
    </div>
  </div>
  <div class="cover-learn-more">
    <a href="javascript:void(0)" class="anchor"><i class="ri-arrow-down-line"></i></a>
  </div>
</section>



<script src="https://cdn.jsdelivr.net/npm/typed.js@2.0.11/lib/typed.min.js"></script>


<!-- Subtitle -->

  <script>
    try {
      var typed = new Typed("#subtitle", {
        strings: ['keep learning!!!!', '', ''],
        startDelay: 0,
        typeSpeed: 200,
        loop: true,
        backSpeed: 100,
        showCursor: true
      });
    } catch (err) {
      console.log(err)
    }
  </script>
  
<div id="main">
  <section class="outer">
  <article class="articles">
    
    
    
    
    <article
  id="post-games101-13-Ray-Tracing1"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2023/05/13/games101-13-Ray-Tracing1/"
    >games101-13-Ray_Tracing1</a> 
</h2>
 

    </header>
     
    <div class="article-meta">
      <a href="/2023/05/13/games101-13-Ray-Tracing1/" class="article-date">
  <time datetime="2023-05-13T05:44:01.000Z" itemprop="datePublished">2023-05-13</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/games101/">games101</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h4 id="Whitted光线追踪如何处理全局光照"><a href="#Whitted光线追踪如何处理全局光照" class="headerlink" title="Whitted光线追踪如何处理全局光照"></a>Whitted光线追踪如何处理全局光照</h4><p>​		光栅化不适合处理全局的效果。如软阴影、磨砂材质、间接光照（光反射多次后到达相机）。在之前的光栅化处理中，只考虑光的一次反射，从光源到达着色点再到达相机。光栅化渲染快，常用于实时渲染（每秒超过30帧）</p>
<p>假设：</p>
<p>（1）光线沿着直线传播</p>
<p>（2）光线和光线不会发生碰撞</p>
<p>（3）光线路径可逆，即从A发出的到B的光线，一定也可以从B发出到A（中途可发生反射和折射）</p>
<p>​		从人眼或摄像机向近投影平面上的每一个像素点发射一条光线，判断与场景物体的交点。一条光线可能会与不止一个物体相交，但是考虑遮挡关系，只去找最近的交点（相当于进行了深度测试）。</p>
<img src="https://cdn.jsdelivr.net/gh/echo468/picgo@main/img/202305121407903.png" alt="image-20230512140740839" style="zoom:67%;" />

<p>​		由于要计算每一个片元的值，因此需要以相机为起点，向每一个像素都发射一条光线。在view空间下进行计算，需要将屏幕的像素中心坐标，变到view空间下。（相机在原点看向-z轴）</p>
<p>​		view空间变到屏幕空间的过程：透视视锥体（宽高比&#x3D;屏幕宽高比）压缩成正交长方体，将正交长方体压缩到[-1,1]的正方体。z值用于深度测试，将[-1,1]的xy拉伸到屏幕的[0,w]和[0,h]。</p>
<p>​		逆变换：将屏幕上的像素中心坐标先变换到[0-1]，再变换到[-1,1]（注意opengcv的y轴朝下，这一步需要将y轴变换朝上）。将[-1,1]拉伸到与屏幕相同的宽高比，但是xy（或者说平面宽高）具体是多少由可视角度和距相机的距离决定。得到view空间下近平面上的坐标（近平面大小）。屏幕上每一个像素点与view空间下近平面上每一个点一一对应。也就是以相机为起点，向近平面像素的对应点都发射一条光线，判断与场景物体的交点。</p>
<p>​		不进行优化的找最近交点的方式：对于一根光线，遍历场景中的每一个物体对象。对于每一个对象，如果是网格对象，将光线与网格对象的每一个三角形求交，记录最近的三角形（距离、交点重心坐标和三角形索引等）。如果是类似球的隐式几何体，直接带入求解。遍历物体对象时，如果光线与物体有交点，还得确保比上一个对象的交点更近。最后记录最近的物体对象及三角形信息。</p>
<img src="https://cdn.jsdelivr.net/gh/echo468/picgo@main/img/202305121409264.png" alt="image-20230512140905212" style="zoom:67%;" />

<p>​		还是针对一根光线：接着连接该交点和光源，只要判断这条连线之间是否有物体存在就可以知道该交点是否在阴影之中。新的光线，光源起点为着色点，光线方向为光源-着色点。对新的光线类似于从相机发射的光线那样进行光线追踪。判断是否有更近的交点。如果该点不在阴影中，知道该点的法线（三角形可以用两条边叉乘再归一化，球体就是着色点-球心再归一化）、相机位置和光源位置，可以利用blinn-phong计算出该点对应的像素值。遍历所有近投影平面上的像素就能得到一张完整的图像。此时效果与局部光照模型是一样的，只考虑了光一次反射，计算得到的是硬阴影。（相当于光线直接打在物体上，由于是漫反射，一定有一根光线会进入相机）</p>
<p>​		上一个例子中光线第一个与圆球物体相交，假设该圆球是一个镜面球，那么便会发生镜面反射。如果是玻璃球，除了镜面反射之外，也存在折射，同时反射与折射出去的光线可能与场景中的物体再次碰撞，发生第二次折射与反射。下图以两个光线，以两次折射或反射的部分光线为例。（全局光照重点是考虑间接光照，及光的多次反射&#x2F;折射）</p>
<img src="https://cdn.jsdelivr.net/gh/echo468/picgo@main/img/202305121413323.png" alt="image-20230512141359281" style="zoom:67%;" />

<p>​		此时每一个像素的颜色贡献来自直接光照，反射方向间接光，折射方向间接光（如果有折射的话）。下一步将这些所有交点（上图中4个交点）与光源连接，计算这些所有点的局部光照模型的结果（被遮挡就不用计算），将其按照光线能量权重累加(光在传播过程中会有损失，如果不添加权值最后会发生曝光)，最终得到近投影平面上该像素点的颜色。这是一个全局光照模型，不仅仅考虑了直接光源的贡献，还考虑各种折射与反射光线的贡献。</p>
<p>​		具体做法是，求出镜面反射的光线（或折射光线），此时这条光线不一定指向光源。因此对该光纤进行递归处理（与上述单单追踪不同）。如果该光线碰到的是镜面物体，则继续反射递归；碰到的是透明物体继续反射+折射递归。递归的此处有最大限制，不能无限递归。如果在有限递归次数内，相交到漫反射物体，不再继续反射和折射，进行光照计算。为了防止结果过亮，每次反射&#x2F;折射都有损失。菲涅尔项得到反射率为k，折射率为1-k。</p>
<img src="https://cdn.jsdelivr.net/gh/echo468/picgo@main/img/202305121414958.png" alt="image-20230512141440915" style="zoom:67%;" />

<p>​		上图中的光线分成三种类别，相机到物体为primary ray；中间反射和折射的蓝线为secondary  ray；最后交点与光源的连线为shadow ray，因为要考虑遮挡。</p>
<h4 id="如何判断光线与物体的交点"><a href="#如何判断光线与物体的交点" class="headerlink" title="如何判断光线与物体的交点"></a>如何判断光线与物体的交点</h4><h5 id="光线与隐式几何求交"><a href="#光线与隐式几何求交" class="headerlink" title="光线与隐式几何求交"></a>光线与隐式几何求交</h5><p>​		通过光源位置O和光线方向d定义一条光线（光线是射线）：</p>
<img src="https://cdn.jsdelivr.net/gh/echo468/picgo@main/img/202305121420925.png" alt="image-20230512142046886" style="zoom: 50%;" />

<p>​		光线与球求交，t值对应的点需要满足两个表达式：</p>
<img src="https://cdn.jsdelivr.net/gh/echo468/picgo@main/img/202305121424656.png" alt="image-20230512142416606" style="zoom: 67%;" />

<p>​		光线与球求交可能会没有交点、有一个交点或者有两个交点。在有两个交点的情况下，取更小的t值。（并且保证更小的t必须是实数且为非负数）</p>
<img src="https://cdn.jsdelivr.net/gh/echo468/picgo@main/img/202305121424151.png" alt="image-20230512142454099" style="zoom: 50%;" />

<p>​		对于光线与隐式表面的交点，只要将光线方程代入求解 t 即可：</p>
<img src="https://cdn.jsdelivr.net/gh/echo468/picgo@main/img/202305121502542.png" alt="image-20230512150218495" style="zoom:67%;" />

<h5 id="光线与显示几何求交"><a href="#光线与显示几何求交" class="headerlink" title="光线与显示几何求交"></a>光线与显示几何求交</h5><p>​		对于显示表面，最重要的是判断光线如何与三角形求交（只考虑0&#x2F;1个交点）。如下图可以将该光线与所有三角形面求交，找到最小的t值。对于多个像素（多条光线）都与所有面计算，计算量相当大。总计算量为像素数（一个像素一个光线）✖三角形面。</p>
<img src="https://cdn.jsdelivr.net/gh/echo468/picgo@main/img/202305121507126.png" alt="image-20230512150709077" style="zoom:67%;" />

<p>​		判断光线与三角形所在平面是否有交点，如果有交点再判断该点是否在三角形内部。</p>
<p>​		首先通过一个点和法线定义一个平面。如果任意一点和该点的连线与法线垂直，则说明该点在平面上。将p和n用xyz定义，展开后如右式。</p>
<img src="https://cdn.jsdelivr.net/gh/echo468/picgo@main/img/202305121515786.png" alt="image-20230512151503743" style="zoom:67%;" />

<p>​		得到参数 t 之后，可以计算出交点，并且再去计算出重心坐标就能判断该交点是否在三角形内。</p>
<img src="https://cdn.jsdelivr.net/gh/echo468/picgo@main/img/202305121520092.png" alt="image-20230512152052037" style="zoom: 50%;" />

<p>​		如下方法直接判断光线在三角形内部是否有交点。假设该点在三角形内，则可以通过重心坐标表示。通过如下方法解出t,b1,b2。如果t,b1,b2,1-b1-b2都是非负数，则该点在三角形内部（注意要判断4项，x是叉乘，.是点乘）。</p>
<p>​		<img src="https://cdn.jsdelivr.net/gh/echo468/picgo@main/img/202305121520552.png" alt="image-20230512152025494" style="zoom: 50%;" /></p>
<h5 id="光线与包围盒求交"><a href="#光线与包围盒求交" class="headerlink" title="光线与包围盒求交"></a>光线与包围盒求交</h5><p>​		使用包围盒加速光线与物体求交。三维空间常用的包围盒是AABB包围盒，即一个长方体。包围盒是由3个对面形成的交集。以二维为例，计算出光线进入两个对面的时间，和光线出两个对面的时间。将第一幅图和第二幅图的线段做交集。</p>
<img src="https://cdn.jsdelivr.net/gh/echo468/picgo@main/img/202305121549035.png" alt="image-20230512154907983" style="zoom:67%;" />

<p>​		对于三维场景来说，光线进入一个盒子，就说明三个对面都要满足光线已经进入（对所有的进入时间tmin取最大值）；光线离开一个盒子，只要满足光线离开任意一个对面（对所有的离开时间tmax取最小值）。如果进入时间小于离开时间，光线一定会在盒子中停留一段时间，即有交点。</p>
<img src="https://cdn.jsdelivr.net/gh/echo468/picgo@main/img/202305121559857.png" alt="image-20230512155903819" style="zoom: 67%;" />

<p>​		使用AABB便于计算，之前计算光线与任意平面求交计算很复杂。</p>
<img src="https://cdn.jsdelivr.net/gh/echo468/picgo@main/img/202305121628668.png" alt="image-20230512162803617" style="zoom:67%;" />

<p>​		如果光线离开盒子的时间＜0，说明盒子在光线背后。如果离开盒子的时间≥0，但是进入盒子的时间＜0，说明光线起点在盒子内部。如果离开时间＜进入时间，则没有交点。当且仅当进入时间小于离开时间，且进入时间≥0，光线与盒子有交点。（不考虑平行）</p>
<table>
<thead>
<tr>
<th align="center"><img src="https://cdn.jsdelivr.net/gh/echo468/picgo@main/img/202305121642550.png" alt="image-20230512164222503" style="zoom: 67%;" /></th>
<th align="center"><img src="https://cdn.jsdelivr.net/gh/echo468/picgo@main/img/202305121643720.png" alt="image-20230512164312676" style="zoom:67%;" /></th>
</tr>
</thead>
<tbody><tr>
<td align="center"><img src="https://cdn.jsdelivr.net/gh/echo468/picgo@main/img/202305121652618.png" alt="image-20230512165258572" style="zoom:67%;" /></td>
<td align="center"></td>
</tr>
</tbody></table>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
    </footer>
  </div>

    
 
   
</article>

    
    <article
  id="post-games101-12-Geometry3"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2023/05/12/games101-12-Geometry3/"
    >games101-12-Geometry3</a> 
</h2>
 

    </header>
     
    <div class="article-meta">
      <a href="/2023/05/12/games101-12-Geometry3/" class="article-date">
  <time datetime="2023-05-12T10:44:12.000Z" itemprop="datePublished">2023-05-12</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/games101/">games101</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h4 id="细分"><a href="#细分" class="headerlink" title="细分"></a>细分</h4><p>​		分出更多的三角形，并且让三角形的位置发生变化，使得原来的模型边的更加精细。所以细分分为两个步骤：增加顶点（面）和对点的位置进行调整。</p>
<img src="https://cdn.jsdelivr.net/gh/echo468/picgo@main/img/202305111940872.png" alt="image-20230511194013793" style="zoom:67%;" />

<h5 id="Loop细分"><a href="#Loop细分" class="headerlink" title="Loop细分"></a>Loop细分</h5><p>​		取三角形三条边的中点，用三个中点组成新的三角形，原来的三角形会被细分成四个三角形。以不同的规则调整旧顶点和新生成顶点的位置。如下对于一个新生成的点，且该点所在的边被两个三角形共享，按照如下公式进行加权计算，使得顶点位置改变后，表面相对平滑。</p>
<img src="https://cdn.jsdelivr.net/gh/echo468/picgo@main/img/202305111945734.png" alt="image-20230511194542678" style="zoom: 67%;" />

<p>​		对于旧的顶点，一个旧顶点可能被多个三角形共享。按照如下公式利用权值、自己的顶点坐标和周围相邻的顶点坐标进行加权计算，如果周围相邻的点多，受周围点的影响就更大。其中n是该点的度，就是该点连接了几条边，u的取值受n值影响。</p>
<img src="https://cdn.jsdelivr.net/gh/echo468/picgo@main/img/202305111946343.png" alt="image-20230511194635296" style="zoom:67%;" />

<p>​		Loop细分结果如下，注意该方法只能对三角形网格进行细分，如果对四边形网格，需要其他的细分方法：</p>
<img src="https://cdn.jsdelivr.net/gh/echo468/picgo@main/img/202305111952456.png" alt="image-20230511195211382" style="zoom:67%;" />

<h5 id="Catmull-Clark细分"><a href="#Catmull-Clark细分" class="headerlink" title="Catmull-Clark细分"></a>Catmull-Clark细分</h5><p>​		定义四边形面（quad face)和非四边形面（Non-quad face）</p>
<p>​		奇异点：度不为4点</p>
<img src="https://cdn.jsdelivr.net/gh/echo468/picgo@main/img/202305112020896.png" alt="image-20230511202020854" style="zoom: 50%;" />

<p>​		取每个面的中点，以及网格面每个边的中点，连接这些中点。如下图所示，现在图中有4个奇异点。只要原来的面不是四边形面，新增的点一定是奇异点。第一次细分，每个非四边形面会引入一个新的奇异点，但是非四边形面会消失，也就是不会再增加奇异点。</p>
<table>
<thead>
<tr>
<th align="center"><img src="https://cdn.jsdelivr.net/gh/echo468/picgo@main/img/202305112023594.png" alt="image-20230511202351551" style="zoom: 50%;" /></th>
<th align="center"><img src="https://cdn.jsdelivr.net/gh/echo468/picgo@main/img/202305112030671.png" alt="image-20230511203019621" style="zoom: 50%;" /></th>
</tr>
</thead>
<tbody><tr>
<td align="center"><img src="https://cdn.jsdelivr.net/gh/echo468/picgo@main/img/202305112030336.png" alt="image-20230511203041212" style="zoom:50%;" /></td>
<td align="center"></td>
</tr>
</tbody></table>
<p>​		用如下方法对新增的点和旧的点进行调整，使得表面相对平滑：</p>
<img src="https://cdn.jsdelivr.net/gh/echo468/picgo@main/img/202305112034363.png" alt="image-20230511203420316" style="zoom: 67%;" />

<h4 id="简化"><a href="#简化" class="headerlink" title="简化"></a>简化</h4><p>1.为了提升性能，节省空间，需要使用更简化的模型。</p>
<p>2.根据场景决定模型的精细程度，比如对于远距离的物体，可以简化模型（类似Mipmap，但是几何的层次结构，以及不同层次结构之间的过度很难）。</p>
<img src="https://cdn.jsdelivr.net/gh/echo468/picgo@main/img/202305112044769.png" alt="image-20230511204425706" style="zoom:67%;" />

<p>​		一种简化方法，边坍缩,如下图将一条边连接的两个顶点变成一个顶点，然后该边就不存在了。但随之而来的问题就是，曲面简化需要尽量保持原本模型的大致形状，如何坍缩一条边，或者说坍缩哪一条边能够使得原模型样貌被改变的程度最小，这就是曲面简化的关键所在。</p>
<img src="https://cdn.jsdelivr.net/gh/echo468/picgo@main/img/202305112050293.png" alt="image-20230511205051245" style="zoom: 67%;" />

<p>​		如左图，将上面两条边坍塌成一个点，如果将该点的坐标用五个顶点或者上面三个顶点的进行平均，得到的结果会比原来的形状小一圈。为此引入一个度量，即二次误差度量(Quadric Error Metrics)。即计算坍缩之后蓝色新顶点所在的位置与原来各个平面的垂直距离的平方和。如果能够使得这个误差最小那么对整个模型样貌修改一定程度上也会较小。误差最小的位置就是最后新顶点的位置。</p>
<p><img src="https://cdn.jsdelivr.net/gh/echo468/picgo@main/img/202305112054659.png" alt="image-20230511205433625"></p>
<p>​		对于整个物体，坍缩流程如下，通过局部最优解得到全局最优解：</p>
<p>（1）为模型每条边赋值，其值为坍缩这条边之后，代替两个老顶点的新顶点所能得到的最小二次误差度量</p>
<p>（2）选取权值最小的边做坍缩，新顶点位置为原来计算得出使得二次误差最小的位置</p>
<p>（3） 坍缩完之后，与之相连其他的边的位置会改动，更新这些边的权值</p>
<p>（4）重复上述步骤，直到到达终止条件</p>
<h4 id="阴影贴图Shadow-Mapping"><a href="#阴影贴图Shadow-Mapping" class="headerlink" title="阴影贴图Shadow Mapping"></a>阴影贴图Shadow Mapping</h4><p>​		光栅化不能很好的处理全局光照，例如阴影。光栅化具有局部性，只考虑着色点和光源、相机的关系，而不考虑该点是否被遮挡，在阴影内（相对于光源被遮挡，但是相机可以看见）。Shadow Mapping在光栅化的情况下处理阴影，但只能处理点光源。并且生成的阴影具有明显边界，一个点在阴影中&#x2F;不在阴影中。</p>
<p>​		如果一个点不在阴影内，说明相机可以看到该点，光源也可以看到该点。一个点在阴影内，说明相机可以看到该点，光源不能看到该点。</p>
<p>​		首先从光源看向场景，根据深度测试的思想记录每个像素最前的深度。如下图是从光源的角度看场景：</p>
<img src="https://cdn.jsdelivr.net/gh/echo468/picgo@main/img/202305112331421.png" alt="image-20230511233126307" style="zoom:67%;" />

<p>​		如下图是生成的shadow maps，即光源视角的Z-buffer，但是是存在一张纹理图中：</p>
<img src="https://cdn.jsdelivr.net/gh/echo468/picgo@main/img/202305112331418.png" alt="image-20230511233142306" style="zoom:67%;" />

<p>​		从设定好的相机位置看向场景。将所有摄像机视角可见点，计算与光源的距离。再找到该点对应的shadow mapping上记录的深度值，如果二者相等，则表明该点能被相机和光源同时看到，不在阴影中，反之在阴影中。</p>
<table>
<thead>
<tr>
<th align="center">在阴影中</th>
<th align="center">不在阴影中</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><img src="https://cdn.jsdelivr.net/gh/echo468/picgo@main/img/202305112328210.png" alt="image-20230511232856119" style="zoom: 67%;" /></td>
<td align="center"><img src="https://cdn.jsdelivr.net/gh/echo468/picgo@main/img/202305112326631.png" alt="image-20230511232651546" style="zoom:67%;" /></td>
</tr>
</tbody></table>
<p>问题：如浮点数难以判断相等，会出现精度问题 ;该方法只适合点光源，生成硬阴影。在光源有一定大小，会存在软阴影。光源具有体积，导致有的地方完全看不到光源(本影, Umbra), 有的地方能看到一部分光源(半影，Penumbra)。所以阴影的边缘会有过渡的情况，从而产生软阴影现象。</p>
<img src="https://cdn.jsdelivr.net/gh/echo468/picgo@main/img/202305112341363.png" alt="image-20230511234128954" style="zoom: 33%;" /> 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
    </footer>
  </div>

    
 
   
</article>

    
    <article
  id="post-games101-11-Geometry2"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2023/05/11/games101-11-Geometry2/"
    >games101-11-Geometry2</a> 
</h2>
 

    </header>
     
    <div class="article-meta">
      <a href="/2023/05/11/games101-11-Geometry2/" class="article-date">
  <time datetime="2023-05-11T04:36:59.000Z" itemprop="datePublished">2023-05-11</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/games101/">games101</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h4 id="显示几何"><a href="#显示几何" class="headerlink" title="显示几何"></a>显示几何</h4><h5 id="点云"><a href="#点云" class="headerlink" title="点云"></a>点云</h5><p>​		不考虑物体是一个表面，而是考虑物体由点组成，只要点的数量足够多，就可以变成物体表面。空间中每一个点由（x,y,z)表示。理论上只要点足够密集，可以表示任何几何，由点变成多边形面。</p>
<p><img src="https://cdn.jsdelivr.net/gh/echo468/picgo@main/img/202305111242600.png" alt="image-20230511124237550"></p>
<h5 id="多边形面"><a href="#多边形面" class="headerlink" title="多边形面"></a>多边形面</h5><p>​		常用三角形面和四边形面，如下图将任何复杂的几何体拆成三角形面。通过定义各个多边形面的顶点以及顶点之间的连接关系就可以得到许许多多的三角形面或是四边形面，再通过这些面来近似表现出我们想要的模型效果。</p>
<img src="https://cdn.jsdelivr.net/gh/echo468/picgo@main/img/202305111245848.png" alt="image-20230511124525785" style="zoom:67%;" />

<p>​		例如比较著名的.obj文件，其格式如下：</p>
<img src="https://cdn.jsdelivr.net/gh/echo468/picgo@main/img/202305111247870.png" alt="image-20230511124752805" style="zoom:67%;" />

<p>​		v定义三角形面的三个顶点坐标（立方体8个顶点）；vt定义三角形面的三个顶点uv坐标（每个面4个点，共6个面所以最多有24种不同的纹理坐标信息）；vn定义三角形面的三个顶点的法线坐标（6个面的法线信息，有8个是因为建模软件输出的精度问题）；f定义点的连接关系，哪三个点形成三角形面。如5&#x2F;1&#x2F;1定义三角形的第一个顶点是第5个v，使用第1个vt作为uv该顶点的uv坐标，使用第1个vn作为该顶点的法线坐标。</p>
<h5 id="贝塞尔曲线"><a href="#贝塞尔曲线" class="headerlink" title="贝塞尔曲线"></a>贝塞尔曲线</h5><p>​		用一系列控制点定义曲线，并且定义曲线满足的一些性质。如下图p0,p1,p2,p3为控制点，该曲线的起始点为p0，结束点为p3，且曲线起始位置的切线沿p0p1方向，结束位置的切线沿p2p3方向（参数3是根据控制点的个数决定的）。曲线不一定要经过p1,p2。可以用任意多个点定义曲线，但2个点只能定义线段。将控制点经过仿射变换后绘制出的还是同一个曲线（仿射变换不包括投影变换）  。所形成的曲线具有凸包性质 ，即曲线一定在在控制点形成的凸包内，不会超出所有控制点构成的凸多边形范围。所以如果四个控制点在一个线段上，最后形成的曲线就是这个线段。</p>
<img src="https://cdn.jsdelivr.net/gh/echo468/picgo@main/img/202305111306969.png" alt="image-20230511130613920" style="zoom: 50%;" />

<p>​		以三个控制点的情况为例：</p>
<img src="https://cdn.jsdelivr.net/gh/echo468/picgo@main/img/202305111307165.png" alt="image-20230511130719131" style="zoom:50%;" />

<p>​		假设曲线起始对应时间0，结束对应时间1，现在要找到0-1中间任意一个时刻所对应曲线上点的位置。假设t&#x3D;1&#x2F;3，取b0b1线段上1&#x2F;3处的点：</p>
<img src="https://cdn.jsdelivr.net/gh/echo468/picgo@main/img/202305111311501.png" alt="image-20230511131116462" style="zoom: 50%;" />

<p>​		取b1b2线段上1&#x2F;3处的点：</p>
<img src="https://cdn.jsdelivr.net/gh/echo468/picgo@main/img/202305111311372.png" alt="image-20230511131143327" style="zoom:50%;" />

<p>​		此时连接上述的两个点形成一个新的线段（两个线段变成一个线段），取这个线段1&#x2F;3处的点，这个点就是t&#x3D;1&#x2F;3时刻，曲线上的点。遍历所有t，就可以获得整条曲线。</p>
<img src="https://cdn.jsdelivr.net/gh/echo468/picgo@main/img/202305111312851.png" alt="image-20230511131222819" style="zoom:50%;" />

<p>​		如下是四个控制迪安的情况，三个线段变成两个线段，两个线段变成一个线段：</p>
<img src="https://cdn.jsdelivr.net/gh/echo468/picgo@main/img/202305111315766.png" alt="image-20230511131501727" style="zoom:50%;" />

<p>​		将上述过程变成代数形式，如下是递归规程：</p>
<img src="https://cdn.jsdelivr.net/gh/echo468/picgo@main/img/202305111317078.png" alt="image-20230511131741041" style="zoom: 67%;" />

<p>​		代数表达式相当于在每个线段上进行插值。以b0b1为例，如果t&#x3D;0，新生成的点在b0处；如果t&#x3D;1，新生成的点在b1处，最后曲线上的点可以通过时间t以及三个控制点的坐标表示（上标表示第几层（从0开始），下标表示该层的第几个点（从0开始），最后一层只有一个点）：</p>
<img src="https://cdn.jsdelivr.net/gh/echo468/picgo@main/img/202305111319182.png" alt="image-20230511131938146" style="zoom:67%;" />

<p>​		第n层也就是最后一层只会新生成一个点，该点可以用每一个控制点和时间t的多项式进行线性组合计算出来，一共n+1项（bj表示第几个控制点（第0层），B表示该控制点对应的关于t的多项式）。该绘制曲线的方法也可以推广至三维，每一个控制点用（x,y,z)定义。该方法属于显示表达，已知t的范围已知映射关系，只要遍历所有的t就可以得到曲线上所有的坐标。</p>
<img src="https://cdn.jsdelivr.net/gh/echo468/picgo@main/img/202305111320523.png" alt="image-20230511132053483" style="zoom: 67%;" />

<p>​		例如由四个控制点，就会有四个关于时间t的多项式，n的值为3，j的值从0-3。四个多项式随时间t的变化如下，在任意一个时刻，四个多项式的和为1：</p>
<img src="https://cdn.jsdelivr.net/gh/echo468/picgo@main/img/202305111323212.png" alt="image-20230511132315175" style="zoom:67%;" />

<h5 id="逐段贝塞尔曲线"><a href="#逐段贝塞尔曲线" class="headerlink" title="逐段贝塞尔曲线"></a>逐段贝塞尔曲线</h5><p>​		当控制点多的时候，不便于计算操作。</p>
<img src="https://cdn.jsdelivr.net/gh/echo468/picgo@main/img/202305111447297.png" alt="image-20230511144704245" style="zoom:50%;" />

<p>​		将一个贝塞尔曲线，用多段贝塞尔曲线组合起来，逐段定义贝塞尔曲线。一般情况下，每一段由四个控制点控制。如下曲线由三段拼接。</p>
<img src="https://cdn.jsdelivr.net/gh/echo468/picgo@main/img/202305111452294.png" alt="image-20230511145214254" style="zoom:50%;" />

<p>​		如果要使得曲线之间的拼接光滑（已知第一个曲线的最后一个控制点和第二个曲线的第一个控制点是同一个点），需要第一个曲线最后一个点的切线和第二个曲线第一个点的切线共线、反向，第一个曲线倒数第二个点和第二个曲线第二个点距离两个曲线重叠的点的距离相同。（如果不相同不能称之为光滑）</p>
<img src="https://cdn.jsdelivr.net/gh/echo468/picgo@main/img/202305111453267.png" alt="image-20230511145338232" style="zoom: 80%;" />



<p>​		另一种定义曲线的方法叫做B样条曲线。对于多个控制点定义的曲线，如果移动一个点，会使得整条曲线发生变换。现在只想对曲线的局部进行变化，B样条曲线可以在不逐段定义的情况先，控制一个控制点的变化最多影响到曲线的哪一个局部范围内。</p>
<p>​		对于两段曲线，有重合的点，叫做C0连续：</p>
<img src="https://cdn.jsdelivr.net/gh/echo468/picgo@main/img/202305111628969.png" alt="image-20230511162850925" style="zoom:67%;" />

<p>​		对于两段曲线，不仅有重合的点，重合区域切线等长、共线且相反，叫做C1连续：</p>
<img src="https://cdn.jsdelivr.net/gh/echo468/picgo@main/img/202305111629412.png" alt="image-20230511162918366" style="zoom:67%;" />

<h5 id="曲面"><a href="#曲面" class="headerlink" title="曲面"></a>曲面</h5><img src="https://cdn.jsdelivr.net/gh/echo468/picgo@main/img/202305111624270.png" alt="image-20230511162453198" style="zoom:67%;" />

<p>​		首先规定一共4x4 &#x3D; 16个控制点，其水平面位置如图中16个黑点所示(并未表示出高度，防止图形太乱)，将这16个点分成4列，图中红色圈中的为一列的具体例子。第1步在这4个控制点之下利用第一个参数 u得到蓝色点，因为有4列，所以一共可以得到如图所示的4个蓝色点。(灰色曲线分别为每列4个点所对应的贝塞尔曲线)第2步在得到4个蓝色顶点之后，在这四个蓝色顶点的基础之下利用第二个参数 v 可以得出贝塞尔曲面上的正确一点。第3步遍历所有的 u，v值就可以成功得到一个贝塞尔曲面。对于曲面和曲面间如何光滑衔接是更复杂的问题。这里由uv可以映射到曲面上的一个点，所以也是显示表示。</p>
<h5 id="其他面操作"><a href="#其他面操作" class="headerlink" title="其他面操作"></a>其他面操作</h5><p>对于曲面物体更广泛的操作还是分解成多边形面。</p>
<p>1.细分：通过将面细分成更多的面（如三角形或者四边形）使得模型精细。</p>
<p>2.简化：将不破坏大体形状的前提下，使用更少的面（如三角形或者四边形）节省内存空间。</p>
<p>3.正规化：例如所有组成物体的三角形都为正三角形，这会具有很多很好的性质，但不不能丢失物体原本的表现质量。</p>
<p><img src="https://cdn.jsdelivr.net/gh/echo468/picgo@main/img/202305111509325.png" alt="image-20230511150928273"></p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
    </footer>
  </div>

    
 
   
</article>

    
    <article
  id="post-games101-5-6-Rasterization"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2023/05/07/games101-5-6-Rasterization/"
    >games101-5/6-Rasterization</a> 
</h2>
 

    </header>
     
    <div class="article-meta">
      <a href="/2023/05/07/games101-5-6-Rasterization/" class="article-date">
  <time datetime="2023-05-07T11:58:44.000Z" itemprop="datePublished">2023-05-07</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/games101/">games101</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h4 id="三角形及光栅化"><a href="#三角形及光栅化" class="headerlink" title="三角形及光栅化"></a>三角形及光栅化</h4><p>三角形的好处：</p>
<p>1.最基础的多边形</p>
<p>2.三角形内部一定在一个平面</p>
<p>3.三角形的内外定义清晰</p>
<p>4.便于插值</p>
<img src="https://cdn.jsdelivr.net/gh/echo468/picgo@main/img/202307111544303.jpg" alt="img" style="zoom:67%;" /> 

<p>光栅器是位于最终处理过的顶点之后到片段着色器之前所经过的所有算法和过程的总和。</p>
<p>光栅器会将一个图元的所有顶点作为输入，并将它转换为一系列的片段。顶点坐标理论上可以取任意值，但片段不行，因为它们受限于窗口的分辨率。</p>
<p>光栅化：判断像素和三角形的位置关系（判断像素中心点（采样点，像素中心与像素坐标区分）和三角形的位置关系）</p>
<p>采样：被三角形所遮盖的采样点所在的像素处，会生成一个片段。对于三角形边缘，有的采样点没有被三角形内部遮盖，所以不会生成片元，也不会受到片段着色器的影响。由于屏幕像素总量的限制，有些边缘的像素能够被渲染出来，而有些则不会。结果就是使用了不光滑的边缘来渲染图元，导致锯齿边缘。</p>
<table>
<thead>
<tr>
<th><img src="https://cdn.jsdelivr.net/gh/echo468/picgo@main/img/202307111544352.jpg" alt="img"></th>
<th><img src="https://cdn.jsdelivr.net/gh/echo468/picgo@main/img/202307111544377.jpg" alt="img"></th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td></td>
</tr>
</tbody></table>
<p><img src="https://cdn.jsdelivr.net/gh/echo468/picgo@main/img/202307111546146.jpg" alt="img"></p>
<p>可以使用向量叉乘的方法，判断像素中心是否在三角形内部。如果在三角形边上，可以自定义是否属于在三角形内。</p>
<p><img src="https://cdn.jsdelivr.net/gh/echo468/picgo@main/img/202307111546119.jpg" alt="img"> </p>
<p>使用包围盒可以减少计算量。此处使用轴向包围盒AABB，对窄且长的三角形不友好。窄且长的三角形可以使用右侧方式。</p>
<p><img src="https://cdn.jsdelivr.net/gh/echo468/picgo@main/img/202307111546100.jpg" alt="img"><img src="https://cdn.jsdelivr.net/gh/echo468/picgo@main/img/202307111546178.jpg" alt="img"> </p>
<p>像素内部颜色在不同设备有不同表现，此处简单认为一个像素内部颜色值相同。</p>
<p><img src="https://cdn.jsdelivr.net/gh/echo468/picgo@main/img/202307111546790.jpg" alt="img"><img src="https://cdn.jsdelivr.net/gh/echo468/picgo@main/img/202307111546772.jpg" alt="img"></p>
<p><img src="https://cdn.jsdelivr.net/gh/echo468/picgo@main/img/202307111546730.jpg" alt="img"> </p>
<p>屏幕空间用一些离散的点（像素中心）是否在三角形内进行采样。会产生锯齿。</p>
<p><img src="https://cdn.jsdelivr.net/gh/echo468/picgo@main/img/202307111546706.jpg" alt="img"><img src="https://cdn.jsdelivr.net/gh/echo468/picgo@main/img/202307111546751.jpg" alt="img">  </p>
<h4 id="Aliasing走样"><a href="#Aliasing走样" class="headerlink" title="Aliasing走样"></a>Aliasing走样</h4><p>采样</p>
<p>（1）空间中采样：像素所有到达感光元件的光学信息-离散成像素</p>
<p><img src="https://cdn.jsdelivr.net/gh/echo468/picgo@main/img/202307111546842.jpg" alt="img"> </p>
<p>（2）采样除了可以发生在不同位置还可以发生在不同时间</p>
<p><img src="https://cdn.jsdelivr.net/gh/echo468/picgo@main/img/202307111547302.jpg" alt="img"> </p>
<p>Artifcts</p>
<p>（1）锯齿（空间位置上的采样）</p>
<p>（2）摩尔纹（空间位置上的采样）</p>
<p>（3）车轮效应（时间上的采样）</p>
<p>（4）信号变化太快采样跟不上</p>
<p>反走样</p>
<p>采样之前滤波&#x2F;模糊</p>
<p><img src="https://cdn.jsdelivr.net/gh/echo468/picgo@main/img/202307111547258.jpg" alt="img"> </p>
<p>不可采样-模糊：走样后模糊</p>
<h5 id="频率和周期"><a href="#频率和周期" class="headerlink" title="频率和周期"></a>频率和周期</h5><p>修改系数f改变sin函数和cos函数的频率，频率定义函数变换有多快。频率的倒数是周期，周期定义函数隔多久重复一次</p>
<p><img src="C:\Users\华为\AppData\Local\Temp\ksohtml10168\wps19.jpg" alt="img"> </p>
<h5 id="傅里叶变换"><a href="#傅里叶变换" class="headerlink" title="傅里叶变换"></a>傅里叶变换</h5><p>傅里叶级数展开：任何一个周期函数，都可以写成一系列sin和cos的线性组合以及一个常数项</p>
<p><img src="https://cdn.jsdelivr.net/gh/echo468/picgo@main/img/202307111548357.jpg" alt="img"></p>
<p>频率从低到高，通过增加更多sin和cos函数，会无限趋近于原周期函数</p>
<p><img src="https://cdn.jsdelivr.net/gh/echo468/picgo@main/img/202307111548631.jpg" alt="img"> </p>
<p>傅里叶变换就是通过一些变换使得函数f(x)变成函数F(w)，F(w)通过逆傅里叶变换还原成函数f(x)：</p>
<p><img src="https://cdn.jsdelivr.net/gh/echo468/picgo@main/img/202307111548413.jpg" alt="img"> </p>
<h5 id="从时域上看走样"><a href="#从时域上看走样" class="headerlink" title="从时域上看走样"></a>从时域上看走样</h5><p>如下使用同一采样频率对不同频率的函数采样，对于高频函数，使用低频采样无法还原原函数：</p>
<p><img src="https://cdn.jsdelivr.net/gh/echo468/picgo@main/img/202307111548441.jpg" alt="img"> </p>
<p>假设有如下黑色和蓝色两个函数，采用如下频率的采样，可以得到相同的采样结果（黑色函数）。同样的采样频率采样两个频率截然不同的函数，得到的结果无法区分，称之为走样。</p>
<p><img src="https://cdn.jsdelivr.net/gh/echo468/picgo@main/img/202307111549921.jpg" alt="img"></p>
<h5 id="滤波-amp-时域频域"><a href="#滤波-amp-时域频域" class="headerlink" title="滤波&amp;时域频域"></a>滤波&amp;时域频域</h5><p>去掉一些特定的频率</p>
<p>傅里叶变换可以将函数从时域变到频域</p>
<p>此处没有时间信息，指的是是空间中的不同位置，傅里叶变换把图像空间变到频率空间，在频域图中，图中心是低频区域，更亮，图像信息越多，周围是高频区域，更黑，图像信息更少。从中心到边缘，频率逐渐增大，图像信息减少。通过傅里叶变换可以看到任何信号在不同频率的样子。</p>
<p><img src="https://cdn.jsdelivr.net/gh/echo468/picgo@main/img/202307111549894.jpg" alt="img"> </p>
<p>高通滤波：去掉低频信息后再将频域图通过逆傅里叶变换恢复到时域图，可以看到只留下了图像内容的边界。由于边界左右发生剧烈变化，是高频信息，因此频域图的高频部分表示图像内容边界。</p>
<p><img src="https://cdn.jsdelivr.net/gh/echo468/picgo@main/img/202307111549970.jpg" alt="img"> </p>
<p>低通滤波：去掉高频信息后再将频域图通过逆傅里叶变换恢复到时域图，可以看到图像边界模糊，相当于对图像进行了模糊操作。</p>
<p><img src="https://cdn.jsdelivr.net/gh/echo468/picgo@main/img/202307111549711.jpg" alt="img"></p>
<p>留下了不太明显的边界，外围保留越多，边界越明显。</p>
<p><img src="https://cdn.jsdelivr.net/gh/echo468/picgo@main/img/202307111549683.jpg" alt="img"> </p>
<p><img src="https://cdn.jsdelivr.net/gh/echo468/picgo@main/img/202307111549740.jpg" alt="img"> </p>
<h5 id="卷积"><a href="#卷积" class="headerlink" title="卷积"></a>卷积</h5><p>简单信号的卷积计算：</p>
<p><img src="https://cdn.jsdelivr.net/gh/echo468/picgo@main/img/202307111549772.jpg" alt="img"> </p>
<p><img src="https://cdn.jsdelivr.net/gh/echo468/picgo@main/img/202307111550328.jpg" alt="img"></p>
<p>结论：</p>
<p>（1）时域上用一个滤波器对信号卷积&#x3D;将时域信号和滤波器变成频域后，两个频域的乘积，再通过傅里叶逆变换变成时域</p>
<p>（2）时域上一个滤波器和信号乘积&#x3D;将时域信号和滤波器变成频域后，用滤波器频域卷积信号频域，再通过傅里叶逆变换变成时域</p>
<h5 id="从时域和频域看模糊"><a href="#从时域和频域看模糊" class="headerlink" title="从时域和频域看模糊"></a>从时域和频域看模糊</h5><p>如下利用3*3的卷积核对一张图片进行卷积操作，每一个像素的值为周围9个像素值的平均（除以9使得最后的值在0-255）,最后的结果是图片模糊。也可以将图片和卷积核通过傅里叶变换变成频域图，将两个频域图相乘得，通过傅里叶逆变换后得到最终结果。该卷积核的频域图相当于一个低通滤波，使得最后的图像边界模糊。</p>
<p><img src="https://cdn.jsdelivr.net/gh/echo468/picgo@main/img/202307111550356.jpg" alt="img"> </p>
<p>如下图左侧是上述卷积核的时域图，右侧是卷积核的频域图。卷积核越大，图片越模糊，过滤掉的高频信息就越多，频域图白色的部分越少。卷积核越小，图片越清晰，极端情况下卷积和小于等于一个像素的大小，图片所有信息都会被保留。</p>
<p><img src="https://cdn.jsdelivr.net/gh/echo468/picgo@main/img/202307111553952.png" alt="image-20230711155305901"></p>
<p><img src="https://cdn.jsdelivr.net/gh/echo468/picgo@main/img/202307111550051.jpg" alt="img"> </p>
<h5 id="从频域看采样"><a href="#从频域看采样" class="headerlink" title="从频域看采样"></a>从频域看采样</h5><p>从频域的角度来看，采样是对频域内容的重复（重复原始信号的频谱）。第一行左侧是一个函数的时域图，右侧是该函数的频域图。第二行左侧是一个冲激函数的的时域图，右侧是该函数的频域图。将函数a和函数c相乘得到函数e，是a函数上一些离散的点（时域上）。将函数a的频域图b和函数c的频域图d进行卷积得到函数e的频域图f，为b的重复。</p>
<p><img src="https://cdn.jsdelivr.net/gh/echo468/picgo@main/img/202307111550529.jpg" alt="img"> </p>
<h5 id="从频域看为什么会发生走样现象"><a href="#从频域看为什么会发生走样现象" class="headerlink" title="从频域看为什么会发生走样现象"></a>从频域看为什么会发生走样现象</h5><p>采样频率下降意味着采样点之间间隔很大，这会导致频谱间的间隔非常小。</p>
<p>因此走样在频域的角度就是频谱发生混叠。</p>
<p><img src="https://cdn.jsdelivr.net/gh/echo468/picgo@main/img/202307111551931.jpg" alt="img"> </p>
<h5 id="从频域看反走样"><a href="#从频域看反走样" class="headerlink" title="从频域看反走样"></a>从频域看反走样</h5><p>（1）增加采样率，使得像素和像素之间的间隔更小（但是很多时候分辨率是一定的，不能随意改变）</p>
<p>（2）先模糊再采样</p>
<p>模糊在频域上看是去掉高频信息，再采样（重复频谱），如下图：</p>
<p><img src="https://cdn.jsdelivr.net/gh/echo468/picgo@main/img/202307111551950.jpg" alt="img"> </p>
<p>根据图可以分析出不能先采样（重复频谱），再模糊（掉高频信息）。</p>
<h5 id="在实际应用中如何进行模糊操作"><a href="#在实际应用中如何进行模糊操作" class="headerlink" title="在实际应用中如何进行模糊操作"></a>在实际应用中如何进行模糊操作</h5><p><img src="https://cdn.jsdelivr.net/gh/echo468/picgo@main/img/202307111551994.jpg" alt="img"> </p>
<p>使用一个像素大小的滤波器，在一个像素内部卷积（做平均），此处做平均的方法是根据三角形在这个像素中的覆盖面积。如第一个覆盖1&#x2F;8，则红色1&#x2F;8，白色7&#x2F;8。</p>
<p><img src="https://cdn.jsdelivr.net/gh/echo468/picgo@main/img/202307111551476.jpg" alt="img"></p>
<p>使用MSAA的方法计算一个像素中的覆盖面积，将一个像素中间设置更多的采样点，如下是4*4。颜色缓冲的大小会随着子采样点的增加而增加。</p>
<p><img src="https://cdn.jsdelivr.net/gh/echo468/picgo@main/img/202307111551497.jpg" alt="img"> </p>
<p>如果是对每一个被遮盖住的子采样点运行一次片段着色器，最后将每个像素所有子采样点的颜色平均一下，这种计算方式会显著降低性能（早期SSAA）。实际MSAA的计算方式是每个图元中的每个像素只运行一次片段着色器。片段着色器所使用的顶点数据会插值到每个像素的中心，所得到的结果颜色会被储存在每个被遮盖住的且通过深度测试的子采样点中。最终这个像素的颜色值是像素内部所有子采样点的平均。如果该像素内部存在被覆盖且深度测试被通过的子样本，则计算像素的最终颜色。如4个采样点中只有2个被遮盖住了，这个像素的颜色将会是三角形颜色与其他两个采样点的颜色（不一定是背景色）的平均值。也就是通过一个像素中新增采样点在在三角形内部的占比来计算像素的颜色值。一个像素中如果有更多的采样点被三角形遮盖，那么这个像素的颜色就会更接近于三角形的颜色。三角形的不平滑边缘被稍浅的颜色所包围后，从远处观察时就会显得更加平滑了。</p>
<p>不仅仅是颜色值会受到多重采样的影响，深度和模板测试也能够使用多个采样点。对深度测试来说，每个顶点的深度值会在运行深度测试之前被插值到各个子样本中（也就是颜色需要的顶点属性用像素中心的坐标插值，每个像素只运行一次片段着色器，但是深度值是用子样本的坐标插值）。对模板测试来说，对每个子样本，而不是每个像素，存储一个模板值。当然，这也意味着深度和模板缓冲的大小会乘以子采样点的个数。</p>
<table>
<thead>
<tr>
<th><img src="https://cdn.jsdelivr.net/gh/echo468/picgo@main/img/202307111552052.png" alt="image-20230711155217013"></th>
<th><img src="https://cdn.jsdelivr.net/gh/echo468/picgo@main/img/202307111552404.png" alt="image-20230711155233357"></th>
</tr>
</thead>
<tbody><tr>
<td><img src="https://cdn.jsdelivr.net/gh/echo468/picgo@main/img/202307111552076.png" alt="image-20230711155247023"></td>
<td></td>
</tr>
</tbody></table>
<p>MSAA在一个像素中新增采样点是为了近似覆盖率进行模糊操作（包含了采样操作），并没有提高分辨率，并且增大了计算量。</p>
<p>Ps:对直线进行反走样，可以取直线上点周围临近的四个像素，根据点到像素中心的距离，填充不同深浅的颜色值。MSAA是在一个像素中取四个子采样点。</p>
<h5 id="其他方法"><a href="#其他方法" class="headerlink" title="其他方法"></a>其他方法</h5><p>FXAA:图像后期处理，找到边界把边界换成没有锯齿的边界</p>
<p>TAA：利用上一帧的信息</p>
<p>超分辨率:DLSS使用深度学习</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
    </footer>
  </div>

    
 
   
</article>

    
    <article
  id="post-games101-4-Transformation1"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2023/05/04/games101-4-Transformation1/"
    >games101-4-Transformation1</a> 
</h2>
 

    </header>
     
    <div class="article-meta">
      <a href="/2023/05/04/games101-4-Transformation1/" class="article-date">
  <time datetime="2023-05-04T08:21:05.000Z" itemprop="datePublished">2023-05-04</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/games101/">games101</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h4 id="MVP变换"><a href="#MVP变换" class="headerlink" title="MVP变换"></a>MVP变换</h4><p>局部空间-世界空间-观察空间-裁剪空间-屏幕空间</p>
<p>局部坐标-世界坐标-观察坐标-裁剪坐标（会变成NDC坐标）-屏幕坐标-光栅化-片元</p>
<p>​		一般可以直接将坐标定义在世界空间，M矩阵取单位矩阵。（当需要对物体进行修改的时候，在局部空间中来操作更方便；如果要对一个物体做出一个相对于其它物体位置的操作时，在世界坐标系中来操作更方便；）</p>
<h4 id="View变换"><a href="#View变换" class="headerlink" title="View变换"></a>View变换</h4><p>确定相机坐标系：</p>
<p>（1）相机位置坐标e</p>
<p>（2）观察方向g:由相机位置指向目标物体</p>
<p>（3）视点正方向t</p>
<p>计算相机坐标系三个轴的方法：</p>
<p>（1）观察方向向量g:目标物体坐标减相机坐标e,再除以长度变成单位向量</p>
<p>（2）辅助向量up：一般设置成（0，1，0），认为相机本身不会歪</p>
<p>（3）向量g×t（e）：通过向量g和辅助向量叉乘得到，此时向量g×t一定垂直于g和t所在平面,再除以长度变成单位向量</p>
<p>（4）视点正方向t向量：通过向量g×t和g向量叉乘得到，再除以长度变成单位向量</p>
<table>
<thead>
<tr>
<th><img src="https://cdn.jsdelivr.net/gh/echo468/picgo@main/img/202307021622014.png" alt="image-20230702162236905" style="zoom:67%;" /></th>
<th><img src="https://cdn.jsdelivr.net/gh/echo468/picgo@main/img/202307021622687.png" alt="image-20230702162254649"></th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td></td>
</tr>
</tbody></table>
<p>​		如果相机和目标物体的相对位置不变，则最后的观察结果都相同。因此当相机处于任意位置时，可以将相机移动到原点，相机始终看向-z方向，且相机坐标系的剩下两个轴与世界坐标系的两个轴X,Y方向一致。之后将物体坐标进行相同的变换，即可得到相机在原位置时相同的结果（将作用于相机的矩阵作用在物体上）。</p>
<img src="https://cdn.jsdelivr.net/gh/echo468/picgo@main/img/202307021623987.png" alt="image-20230702162356943" style="zoom:67%;" />

<p>下面求解view矩阵：</p>
<img src="https://cdn.jsdelivr.net/gh/echo468/picgo@main/img/202307021624535.png" alt="image-20230702162404488" style="zoom:67%;" />

<p>（1）平移操作，将e点移动到原点</p>
<p><img src="https://cdn.jsdelivr.net/gh/echo468/picgo@main/img/202307021624611.png" alt="img"></p>
<p>（2）旋转操作</p>
<p>由于计算从相机坐标系到世界坐标系的旋转矩阵较为复杂，因此可以先计算从世界坐标系变换到相机坐标系将y轴旋转到t轴，将z轴旋转到-g轴，将x轴旋转到g×t的轴。</p>
<p><img src="https://cdn.jsdelivr.net/gh/echo468/picgo@main/img/202307021624681.png" alt="img"></p>
<p>该操作为将相机坐标系变换到世界坐标系的逆操作，因此求出来的R矩阵为目标R矩阵的逆矩阵，也是目标R矩阵的转置矩阵。</p>
<p><img src="https://cdn.jsdelivr.net/gh/echo468/picgo@main/img/202307021624648.png" alt="img"></p>
<p>（3）最后求出的M矩阵如下，对目标物体坐标进行M矩阵变换</p>
<p><img src="https://cdn.jsdelivr.net/gh/echo468/picgo@main/img/202307021624731.png" alt="img"></p>
<h4 id="Projection变换"><a href="#Projection变换" class="headerlink" title="Projection变换"></a>Projection变换</h4><p> <img src="https://cdn.jsdelivr.net/gh/echo468/picgo@main/img/202307021625273.jpg" alt="img"></p>
<h5 id="Orthographic-projection-正交投影"><a href="#Orthographic-projection-正交投影" class="headerlink" title="Orthographic projection 正交投影"></a>Orthographic projection 正交投影</h5><p>假设相机在原点，看向-z轴。</p>
<p>将视线范围内的物体(假设在一个立方体中，该立方体通过六个数定义，注意越远z值越小，立方体外的部分都会被剪裁)全部压缩到[-1,1]范围内的正方体中，变成NDC坐标。先将立方体的重心平移到原点，再将立方体进行缩放(此处先不考虑旋转)：</p>
<p><img src="https://cdn.jsdelivr.net/gh/echo468/picgo@main/img/202307021625714.jpg" alt="img"> </p>
<p><img src="https://cdn.jsdelivr.net/gh/echo468/picgo@main/img/202307021625766.png" alt="img"></p>
<p>正交投影坐标的相对位置都不会改变，只需将物体全部转换到一个[−1,1]的正方体之中即可（其中x，y坐标便是投影结果，保留z是为了之后的深度检测）。压缩到一个正方体是为了之后的计算更加的方便在转换到屏幕坐标的时候就会重新拉伸回来。</p>
<p><img src="https://cdn.jsdelivr.net/gh/echo468/picgo@main/img/202307021626160.jpg" alt="img"></p>
<p>正交投影不会影响w值,w仍为1，进行透视除法后没有任何作用。由于这个原因，正射投影主要用于二维渲染以及一些建筑或工程的程序，在这些场景中更希望顶点不会被透视所干扰。（opengl使用右手坐标系，此处越远z越小，在opengl中NDC坐标会变换成左手坐标，越远z越大）</p>
<h5 id="Perspective-projection-透视投影"><a href="#Perspective-projection-透视投影" class="headerlink" title="Perspective projection 透视投影"></a>Perspective projection 透视投影</h5><p>(1) 将视锥体压缩成立方体</p>
<p>距离越远，压缩程度越大，形成近大远小的效果。</p>
<p><img src="https://cdn.jsdelivr.net/gh/echo468/picgo@main/img/202307021626131.jpg" alt="img"> </p>
<p>近平面n的xyz坐标不变，远平面f中心的xyz值不变。</p>
<p>根据相似三角形：</p>
<p><img src="https://cdn.jsdelivr.net/gh/echo468/picgo@main/img/202307021626190.png" alt="img"></p>
<p>即</p>
<p><img src="https://cdn.jsdelivr.net/gh/echo468/picgo@main/img/202307021626271.png" alt="img"><img src="https://cdn.jsdelivr.net/gh/echo468/picgo@main/img/202307021626239.jpg" alt="img"></p>
<p>（x,y,z,1）,(kx,ky,kz,k!&#x3D;0)都是三维空间中的点（x,y,z）。</p>
<p>可得矩阵：</p>
<p><img src="https://cdn.jsdelivr.net/gh/echo468/picgo@main/img/202307021627989.png" alt="img"></p>
<p>近平面n的xyz坐标不变：</p>
<p><img src="https://cdn.jsdelivr.net/gh/echo468/picgo@main/img/202307021627136.png" alt="img"></p>
<p><img src="https://cdn.jsdelivr.net/gh/echo468/picgo@main/img/202307021627025.png" alt="img"></p>
<p>远平面f中心的xyz值不变：</p>
<p><img src="https://cdn.jsdelivr.net/gh/echo468/picgo@main/img/202307021627384.png" alt="img"></p>
<p><img src="https://cdn.jsdelivr.net/gh/echo468/picgo@main/img/202307021627068.png" alt="img"></p>
<p>最后解的<img src="https://cdn.jsdelivr.net/gh/echo468/picgo@main/img/202307021627191.png" alt="img"></p>
<p>（2）将立方体变换到[-1,1]的正方体</p>
<p>将目标物体经过上述变换后，再进行正交投影变换即可：</p>
<p><img src="https://cdn.jsdelivr.net/gh/echo468/picgo@main/img/202307021627125.png" alt="img"></p>
<p><em><strong>*为什么在（1）中中间压缩的点z值不知道？*</strong></em><br><img src="https://cdn.jsdelivr.net/gh/echo468/picgo@main/img/202307021627363.png" alt="img"></p>
<p>Persp-&gt;ortho矩阵会改变顶点的w值（w&#x3D;z＜0），在进行完透视投影的MVP变换后，得离观察者越远的顶点坐标w分量的绝对值越大。顶点坐标的每个分量都会除以它的w分量，距离观察者越远顶点坐标就会越小。（最后的顶点应该被赋值到顶点着色器中的gl_Position输出，OpenGL将会自动进行透视除法和裁剪。）。</p>
<p>比较更新后的z值和原z值：</p>
<p><img src="https://cdn.jsdelivr.net/gh/echo468/picgo@main/img/202307021627495.png" alt="img"></p>
<p>因为n≥z≥f，所以(z-n)(f-z)值＞0，因为z＜0，方程最左侧的分数值小＜0，即更新后的z值小于原z值，即透视投影之后，中间物体距离相机更远。所以在推算时不知道z值。</p>
<p><em><strong>*如何确定视锥体？*</strong></em></p>
<p>利用垂直可视角度或者水平可视角度、近平面距离、远平面距离（距离相机的距离）以及进平面宽高比(width&#x2F;heigth)可以确定一个视锥体。（在opengl中，可视角度一般取45°，近平面取0.1，远平面100.0f）</p>
<p><img src="https://cdn.jsdelivr.net/gh/echo468/picgo@main/img/202307021627813.jpg" alt="img"> </p>
<p>如下图所示，相机在原点看向-z轴。已知Y（垂直可视角度）和n，可以计算出height&#x2F;2-&gt;height，通过宽高比可以得到width。远平面可以通过Y和f计算。</p>
<p><img src="https://cdn.jsdelivr.net/gh/echo468/picgo@main/img/202307021627150.jpg" alt="img"> </p>
<p>如果只是图元(Primitive)，例如三角形，的一部分超出了裁剪体积(Clipping Volume)，则OpenGL会重新构建这个三角形为一个或多个三角形让其能够适合这个裁剪范围。</p>
<h4 id="视口变换"><a href="#视口变换" class="headerlink" title="视口变换"></a>视口变换</h4><p>屏幕可以看作一组x<em>y的像素数组，数组的大小x</em>y为分辨率。此处认为在一个像素内部颜色不变，像素的颜色值通过RGB三个0-255之间的数表示。</p>
<p><img src="https://cdn.jsdelivr.net/gh/echo468/picgo@main/img/202307021627542.jpg" alt="img"> </p>
<p>像素坐标从（0，0）到（x-1，y-1）。像素（x，y）的中心在（x+0.5，y+0.5）,这些像素的覆盖范围从（0，0）到（x，y）。</p>
<p>视口变换就是将物体坐标从[-1,1]的正方体变到x*y的屏幕。</p>
<p><img src="https://cdn.jsdelivr.net/gh/echo468/picgo@main/img/202307021627754.jpg" alt="img"> </p>
<p>该变换与z无关，z保持不变用于后续深度测试。先把正方体的x、y进行缩放</p>
<p><img src="https://cdn.jsdelivr.net/gh/echo468/picgo@main/img/202307021627215.png" alt="img"></p>
<p>再将缩放后的立方体中心平移到屏幕中心：</p>
<p><img src="https://cdn.jsdelivr.net/gh/echo468/picgo@main/img/202307021628869.png" alt="img"></p>
<p><em><strong>*为什么不能先平移再缩放？*</strong></em></p>
<p>缩放会将每个坐标以原点为中心进行缩放（也就是位移向量也会被缩放），而不是物体中心，如下白色正方形按照缩放矩阵缩小一半的结果是蓝色正方形而不是红色正方形。</p>
<p><img src="https://cdn.jsdelivr.net/gh/echo468/picgo@main/img/202307021627809.jpg" alt="img"> </p>
<p>显示图像：将显存中的一块区映射到屏幕。</p>
<p>（区分 view变换：先平移再旋转 正交投影：先平移再缩放）</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
    </footer>
  </div>

    
 
   
</article>

    
    <article
  id="post-games101-3-Transformation"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2023/05/03/games101-3-Transformation/"
    >games101-3-Transformation</a> 
</h2>
 

    </header>
     
    <div class="article-meta">
      <a href="/2023/05/03/games101-3-Transformation/" class="article-date">
  <time datetime="2023-05-03T07:40:34.000Z" itemprop="datePublished">2023-05-03</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/games101/">games101</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h5 id="Scale缩放"><a href="#Scale缩放" class="headerlink" title="Scale缩放"></a>Scale缩放</h5><p>默认以原点为中心缩放。</p>
<p>（1）均匀缩放</p>
<p><img src="https://cdn.jsdelivr.net/gh/echo468/picgo@main/img/202305151556554.jpg" alt="img"> </p>
<p><img src="https://cdn.jsdelivr.net/gh/echo468/picgo@main/img/202305151616417.png" alt="image-20230515161619367"></p>
<p>（2）非均匀缩放</p>
<p><img src="https://cdn.jsdelivr.net/gh/echo468/picgo@main/img/202305151556684.jpg" alt="img"> </p>
<p><img src="https://cdn.jsdelivr.net/gh/echo468/picgo@main/img/202305151556714.png" alt="img">-&gt;<img src="https://cdn.jsdelivr.net/gh/echo468/picgo@main/img/202305151556762.png" alt="img"></p>
<h5 id="Reflection反射"><a href="#Reflection反射" class="headerlink" title="Reflection反射"></a>Reflection反射</h5><p><img src="https://cdn.jsdelivr.net/gh/echo468/picgo@main/img/202305151556569.jpg" alt="img"> </p>
<p><img src="https://cdn.jsdelivr.net/gh/echo468/picgo@main/img/202305151617348.png" alt="image-20230515161742312"></p>
<h5 id="Shear-Matric"><a href="#Shear-Matric" class="headerlink" title="Shear Matric"></a>Shear Matric</h5><p><img src="https://cdn.jsdelivr.net/gh/echo468/picgo@main/img/202305151556856.jpg" alt="img"> </p>
<p><img src="https://cdn.jsdelivr.net/gh/echo468/picgo@main/img/202305151618772.png" alt="image-20230515161856725"></p>
<h5 id="Rotate旋转"><a href="#Rotate旋转" class="headerlink" title="Rotate旋转"></a>Rotate旋转</h5><p><img src="https://cdn.jsdelivr.net/gh/echo468/picgo@main/img/202305151556794.jpg" alt="img"> </p>
<p>此处是2维旋转，默认以（0，0）为重心旋转，默认以逆时针旋转,也就是角度值为正。</p>
<p><img src="https://cdn.jsdelivr.net/gh/echo468/picgo@main/img/202305151556864.png" alt="img"></p>
<p>以边长为1进行旋转矩阵推导：</p>
<p><img src="https://cdn.jsdelivr.net/gh/echo468/picgo@main/img/202305151620544.png" alt="image-20230515162027508"></p>
<p>如果旋转-θ:</p>
<p><img src="https://cdn.jsdelivr.net/gh/echo468/picgo@main/img/202305151556898.png" alt="img"></p>
<p>矩阵为旋转θ时旋转矩阵的转置，并且由于旋转-θ是旋转θ的逆变换，因此该矩阵还为旋转θ时旋转矩阵的逆矩阵（一个矩阵的转置等于其正交矩阵，则该矩阵为正交矩阵）</p>
<h5 id="线性变换"><a href="#线性变换" class="headerlink" title="线性变换"></a>线性变换</h5><p><img src="https://cdn.jsdelivr.net/gh/echo468/picgo@main/img/202305151623337.png" alt="image-20230515162329289"></p>
<h5 id="Translation平移"><a href="#Translation平移" class="headerlink" title="Translation平移"></a>Translation平移</h5><p><img src="https://cdn.jsdelivr.net/gh/echo468/picgo@main/img/202305151557482.jpg" alt="img"> </p>
<p>此处是先进性线性变换再平移。</p>
<p><img src="https://cdn.jsdelivr.net/gh/echo468/picgo@main/img/202305151623645.png" alt="image-20230515162355592"></p>
<h5 id="齐次坐标"><a href="#齐次坐标" class="headerlink" title="齐次坐标"></a>齐次坐标</h5><p>引入齐次坐标是为了将所有变换都变成一个矩阵乘以一个向量的形式。</p>
<p><img src="https://cdn.jsdelivr.net/gh/echo468/picgo@main/img/202305151557224.jpg" alt="img"> </p>
<p>点的平移变换，点平移后成为新的点：</p>
<p><img src="https://cdn.jsdelivr.net/gh/echo468/picgo@main/img/202305151557330.png" alt="img"></p>
<p>向量具有平移不变性：</p>
<p><img src="https://cdn.jsdelivr.net/gh/echo468/picgo@main/img/202305151624937.png" alt="img"></p>
<p>可以通过齐次坐标的w验证：</p>
<p><img src="https://cdn.jsdelivr.net/gh/echo468/picgo@main/img/202305151557624.jpg" alt="img"> </p>
<p>一个点加上一个点的结果是这两个点的中点，原因如下，在w不等于0的情况下，(x,y,w)是二维点（x&#x2F;w,y&#x2F;w,1）。</p>
<h5 id="Affine-Transformation仿射变换"><a href="#Affine-Transformation仿射变换" class="headerlink" title="Affine Transformation仿射变换"></a>Affine Transformation仿射变换</h5><p>2维仿射变换最后一行才是（0，0，1），如下矩阵是先进行线性变换再进行平移变换。</p>
<p><img src="https://cdn.jsdelivr.net/gh/echo468/picgo@main/img/202305151557098.png" alt="img"></p>
<table>
<thead>
<tr>
<th>缩放变换矩阵</th>
<th>旋转变换矩阵</th>
<th>平移变换矩阵</th>
</tr>
</thead>
<tbody><tr>
<td><img src="https://cdn.jsdelivr.net/gh/echo468/picgo@main/img/202305151630316.png" alt="img"></td>
<td><img src="https://cdn.jsdelivr.net/gh/echo468/picgo@main/img/202305151557229.png" alt="img"></td>
<td><img src="https://cdn.jsdelivr.net/gh/echo468/picgo@main/img/202305151557387.png" alt="img"></td>
</tr>
</tbody></table>
<h5 id="Inverse-Transform逆变换"><a href="#Inverse-Transform逆变换" class="headerlink" title="Inverse Transform逆变换"></a>Inverse Transform逆变换</h5><p>逆变换相当于乘以变换的逆矩阵。</p>
<img src="https://cdn.jsdelivr.net/gh/echo468/picgo@main/img/202305151641812.png" alt="image-20230515164100755" style="zoom:67%;" /> 

<h5 id="Composite-Transform组合变换"><a href="#Composite-Transform组合变换" class="headerlink" title="Composite Transform组合变换"></a>Composite Transform组合变换</h5><p>复杂变换可以通过简单变换得到，变换的顺序很重要，如下先进行平移变换再进行旋转变换（默认围绕原点旋转）和先进行旋转变换再进行平移变换的结果不同。再次说明了矩阵乘法不能随意交换顺序。在c中cos和sin函数的参数都是弧度</p>
<p>（1）弧度转角度：角度 &#x3D; 弧度 * (180.0f &#x2F; PI)</p>
<p>（2）角度转弧度：弧度 &#x3D; 角度 * (PI &#x2F; 180.0f)</p>
<p><img src="https://cdn.jsdelivr.net/gh/echo468/picgo@main/img/202305151630935.jpg" alt="img"></p>
<p><img src="https://cdn.jsdelivr.net/gh/echo468/picgo@main/img/202305151557237.jpg" alt="img"></p>
<p><img src="https://cdn.jsdelivr.net/gh/echo468/picgo@main/img/202305151630157.png" alt="img"></p>
<p>将变换变成矩阵乘法，相当于从右到左应用。也可以先计算左边所有矩阵得到一个矩阵。</p>
<h5 id=""><a href="#" class="headerlink" title=""></a><img src="https://cdn.jsdelivr.net/gh/echo468/picgo@main/img/202305151557575.png" alt="img"></h5><h5 id="变换分解"><a href="#变换分解" class="headerlink" title="变换分解"></a>变换分解</h5><p>由于旋转默认是围绕原点旋转，如果想围绕任意点旋转，可以将变换按照如下方式分解：</p>
<p><img src="https://cdn.jsdelivr.net/gh/echo468/picgo@main/img/202305151557864.jpg" alt="img"> </p>
<h5 id="三维齐次坐标"><a href="#三维齐次坐标" class="headerlink" title="三维齐次坐标"></a>三维齐次坐标</h5><p><img src="https://cdn.jsdelivr.net/gh/echo468/picgo@main/img/202305151557958.jpg" alt="img"> </p>
<p>在w不等于0的情况下，(x,y,z,w)是三维点（x&#x2F;w,y&#x2F;w,z&#x2F;w,1）。</p>
<h5 id="三维仿射变换"><a href="#三维仿射变换" class="headerlink" title="三维仿射变换"></a>三维仿射变换</h5><p>如下矩阵是先进行线性变换再进行平移变换。</p>
<p><img src="https://cdn.jsdelivr.net/gh/echo468/picgo@main/img/202305151629055.png" alt="img"></p>
<h5 id="三维缩放"><a href="#三维缩放" class="headerlink" title="三维缩放"></a>三维缩放</h5><p><img src="https://cdn.jsdelivr.net/gh/echo468/picgo@main/img/202305151557536.png" alt="img"></p>
<h5 id="三维平移"><a href="#三维平移" class="headerlink" title="三维平移"></a>三维平移</h5><p><img src="https://cdn.jsdelivr.net/gh/echo468/picgo@main/img/202305151629010.png" alt="img"></p>
<h5 id="三维绕轴旋转"><a href="#三维绕轴旋转" class="headerlink" title="三维绕轴旋转"></a>三维绕轴旋转</h5><p><img src="https://cdn.jsdelivr.net/gh/echo468/picgo@main/img/202305151557761.png" alt="img"><img src="https://cdn.jsdelivr.net/gh/echo468/picgo@main/img/202305151557971.png" alt="img"></p>
<p><img src="https://cdn.jsdelivr.net/gh/echo468/picgo@main/img/202305151629293.png" alt="img"></p>
<p>任意旋转都可由如下的欧拉角组合获得(还有一种四元数旋转法，便于做叉乘)：</p>
<p><img src="https://cdn.jsdelivr.net/gh/echo468/picgo@main/img/202305151557849.png" alt="img"></p>
<p>任意旋转还可以使用如下的旋转公式，a是角度，n是任意向量，如果向量方向相同起始点不同，旋转结果会不同，所以此处默认向量过原点：</p>
<p><img src="https://cdn.jsdelivr.net/gh/echo468/picgo@main/img/202305151557590.jpg" alt="img"> </p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
    </footer>
  </div>

    
 
   
</article>

    
    <article
  id="post-games101-2-Linear_algebra"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2023/05/02/games101-2-Linear_algebra/"
    >games101-2-Linear_algebra</a> 
</h2>
 

    </header>
     
    <div class="article-meta">
      <a href="/2023/05/02/games101-2-Linear_algebra/" class="article-date">
  <time datetime="2023-05-02T07:40:24.000Z" itemprop="datePublished">2023-05-02</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/games101/">games101</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h4 id="线性代数"><a href="#线性代数" class="headerlink" title="线性代数"></a>线性代数</h4><h5 id="向量基础知识"><a href="#向量基础知识" class="headerlink" title="向量基础知识"></a>向量基础知识</h5><p>向量（矢量）：方向和长度，不关心绝对开始位置，只要A和B的相对位置不变，平移后还是相同向量。</p>
<p><img src="https://cdn.jsdelivr.net/gh/echo468/picgo@main/img/202305102345796.jpg" alt="img"> </p>
<p>向量的长度：<img src="https://cdn.jsdelivr.net/gh/echo468/picgo@main/img/202305102345918.png" alt="img"></p>
<p>单位向量（只关心方向不关心长度），将向量的每一个分量除以长度，也叫向量的标准化：<img src="https://cdn.jsdelivr.net/gh/echo468/picgo@main/img/202305102345145.png" alt="img"></p>
<p>向量操作：平行四边形法则和三角形法则（三角形法则也可以适用于多个向量首尾相连）。向量相加是将每个对应的分量分别相加，相减同理。</p>
<img src="https://cdn.jsdelivr.net/gh/echo468/picgo@main/img/202305102348907.png" alt="image-20230510234841798" style="zoom: 67%;" /> 

<p>向量的代数表示：将向量放入直角坐标系，X、Y为相互垂直的两个单位向量。用该方法向量就可以用x、y两个数表示，如下向量用4、3表示。将向量放入坐标系可以更方便的计算向量的长度。如向量（4，3）默认是过原点的。</p>
<p><img src="https://cdn.jsdelivr.net/gh/echo468/picgo@main/img/202305102345025.jpg" alt="img"> </p>
<p>图形学上默认向量是列向量：<img src="https://cdn.jsdelivr.net/gh/echo468/picgo@main/img/202305102345976.jpg" alt="img"> </p>
<p>列向量转置和向量的长度计算：<img src="https://cdn.jsdelivr.net/gh/echo468/picgo@main/img/202305102345663.png" alt="img"> <img src="https://cdn.jsdelivr.net/gh/echo468/picgo@main/img/202305110003014.png" alt="img"></p>
<p>当把一个向量加&#x2F;减&#x2F;乘&#x2F;除一个标量，可以简单的把向量的每个分量分别进行该运算。数学上是没有向量与标量相加运算的，但是很多线性代数的库都对它有支持。向量取反就是将每一个分量取反。</p>
<h5 id="向量的点乘"><a href="#向量的点乘" class="headerlink" title="向量的点乘"></a>向量的点乘</h5><p><img src="https://cdn.jsdelivr.net/gh/echo468/picgo@main/img/202305102345955.jpg" alt="img"> </p>
<p>两个向量的点乘结果是一个数，点乘可以快速计算两个向量的夹角。例如两个单位向量点乘的结果就是他们夹角的余弦。</p>
<p><img src="https://cdn.jsdelivr.net/gh/echo468/picgo@main/img/202305110003951.png" alt="img">   <img src="https://cdn.jsdelivr.net/gh/echo468/picgo@main/img/202305102345064.png" alt="img"></p>
<p>点乘的性质：</p>
<p><img src="https://cdn.jsdelivr.net/gh/echo468/picgo@main/img/202305102345765.jpg" alt="img"> </p>
<p>点乘的代数计算（对应元素相乘，最后将所有乘积相加）：</p>
<p><img src="https://cdn.jsdelivr.net/gh/echo468/picgo@main/img/202305102345885.jpg" alt="img"> </p>
<p>点乘的作用：</p>
<p>（1）计算一个向量在另一个向量上的投影</p>
<p><img src="https://cdn.jsdelivr.net/gh/echo468/picgo@main/img/202305102345069.jpg" alt="img"> </p>
<p>​		b向量在a向量上的投影的方向为a向量的方向，投影的大小为||b||cosθ，所以b向量在a向量上的投影为||b||cosθa，cosθ通过a向量和b向量的点乘获得。</p>
<p>计算向量的投影可以对向量进行分解</p>
<p><img src="https://cdn.jsdelivr.net/gh/echo468/picgo@main/img/202305102346329.jpg" alt="img"> </p>
<p>（2）通过点乘结果的正负判断向量在前还是在后（方向基本一致，垂直或者相反），在图形学上通过点乘结果判断两个向量的接近程度。例如对于两个单位向量，如果这两个向量方向接近，则点乘结果接近1；如果方向垂直，点乘结果接近0；如果方向相反，点乘结果接近1.</p>
<p><img src="https://cdn.jsdelivr.net/gh/echo468/picgo@main/img/202305102346910.jpg" alt="img"> </p>
<h5 id="向量的叉乘"><a href="#向量的叉乘" class="headerlink" title="向量的叉乘"></a>向量的叉乘</h5><p><img src="https://cdn.jsdelivr.net/gh/echo468/picgo@main/img/202305102346426.jpg" alt="img"> </p>
<p>两个向量的叉乘结果是一个新向量，该向量垂直于原来两个向量所在的平面。新向量的大小为<img src="https://cdn.jsdelivr.net/gh/echo468/picgo@main/img/202305102346743.png" alt="img">，新向量的方向通过右手螺旋定则确定。</p>
<p>向量叉乘的性质如下，注意一个向量叉乘自己得到的是长度为0的向量，而不是0。两个向量的叉乘可以得到一个三维空间的坐标系（右手坐标系x叉乘y是正z是右手坐标系，opengl使用右手坐标系）:</p>
<img src="https://cdn.jsdelivr.net/gh/echo468/picgo@main/img/202305102349505.png" alt="image-20230510234944416" style="zoom:80%;" /> 

<p>向量叉乘的代数运算:</p>
<p><img src="https://cdn.jsdelivr.net/gh/echo468/picgo@main/img/202305102350731.png" alt="image-20230510235008653"> </p>
<p>向量叉乘的作用:</p>
<p>（1）判断左右位置关系</p>
<p>如下在X、Y平面，判断向量b在向量a的左侧还是右侧。计算向量a叉乘向量b，如果结果为正，则向量b在向量a在左侧，即a-b是逆时针；如果结果为负，则向量b在向量a在右侧，即a-b是顺时针。</p>
<img src="https://cdn.jsdelivr.net/gh/echo468/picgo@main/img/202305151554742.png" alt="image-20230515155411695" style="zoom:80%;" /> 

<p>（2）判断内外</p>
<p>如下三角形，ABC按照逆时针顺序输入。AB叉乘AP，结果为正，点p在AB左侧；BC叉乘BP，结果为正，点p在BC左侧；CA叉乘CP，结果为正，p在CA左侧；结论p在三角形内部。如果ABC按照顺时针顺序输入，如果p在三条边右侧，则p在三角形内部。所以不管顺时针还是逆时针输入，p如果在三角形内部，p必须在三条边的同一边。在三角形光栅化时，用该方法可以判断三角形覆盖哪些像素。如果叉乘结果为0，则自定义是否在三角形内部。</p>
<img src="https://cdn.jsdelivr.net/gh/echo468/picgo@main/img/202305151554163.png" alt="image-20230515155440122" style="zoom:67%;" /> 

<h5 id="在三维直角坐标系（右手坐标系）中进行向量分解"><a href="#在三维直角坐标系（右手坐标系）中进行向量分解" class="headerlink" title="在三维直角坐标系（右手坐标系）中进行向量分解"></a>在三维直角坐标系（右手坐标系）中进行向量分解</h5><img src="https://cdn.jsdelivr.net/gh/echo468/picgo@main/img/202305151555684.png" alt="image-20230515155508640" style="zoom: 67%;" /> 

<p>以u为例，u为单位向量，长度为1，p在u的投影为：</p>
<p><img src="https://cdn.jsdelivr.net/gh/echo468/picgo@main/img/202305102346580.png" alt="img"></p>
<h5 id="矩阵"><a href="#矩阵" class="headerlink" title="矩阵"></a>矩阵</h5><p>N*M的矩阵：N行M列的矩阵</p>
<p>数学上是没有矩阵与标量相加减的运算的，但是很多线性代数的库都对它有支持。矩阵与标量之间的加减就是将矩阵中每一个元素都与标量进行加减。矩阵与矩阵之间的加减就是两个矩阵对应元素的加减运算，所以总体的规则和与标量运算是差不多的，只不过在相同索引下的元素才能进行运算。</p>
<p>矩阵数乘：将矩阵中的每一个数都与n相乘</p>
<p>矩阵乘法：N<em>M的矩阵与M</em>P的矩阵相乘得到N*P的矩阵，结果矩阵元素Aij由第一个矩阵第i行乘以第二个矩阵第j列获得。</p>
<p>矩阵乘法的性质：</p>
<img src="https://cdn.jsdelivr.net/gh/echo468/picgo@main/img/202305151550391.png" alt="image-20230515155028337" style="zoom:80%;" /> 

<p>矩阵与向量相乘，一般默认向量在右侧，矩阵列数与向量行数相同：</p>
<img src="https://cdn.jsdelivr.net/gh/echo468/picgo@main/img/202305151550865.png" alt="image-20230515155049820" style="zoom:67%;" /> 

<p>矩阵的转置：</p>
<img src="https://cdn.jsdelivr.net/gh/echo468/picgo@main/img/202305151551322.png" alt="image-20230515155114282" style="zoom: 50%;" /> 

<p>单位矩阵和逆矩阵:</p>
<img src="https://cdn.jsdelivr.net/gh/echo468/picgo@main/img/202305151551377.png" alt="image-20230515155143338" style="zoom:67%;" /> 

<p>原矩阵乘以单位矩阵，相当于不对原矩阵不做任何操作.</p>
<p>向量的点积和叉积可以转换成矩阵乘法（向量默认为列向量）：</p>
<img src="https://cdn.jsdelivr.net/gh/echo468/picgo@main/img/202305151552558.png" alt="image-20230515155234507" style="zoom:67%;" /> 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
    </footer>
  </div>

    
 
   
</article>

    
    <article
  id="post-gl函数流程图"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2023/04/17/gl%E5%87%BD%E6%95%B0%E6%B5%81%E7%A8%8B%E5%9B%BE/"
    >gl函数流程图</a> 
</h2>
 

    </header>
     
    <div class="article-meta">
      <a href="/2023/04/17/gl%E5%87%BD%E6%95%B0%E6%B5%81%E7%A8%8B%E5%9B%BE/" class="article-date">
  <time datetime="2023-04-17T01:33:58.000Z" itemprop="datePublished">2023-04-17</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E5%AE%9E%E4%B9%A0/">实习</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <p>1.清除</p>
<p>首先设置清除颜色缓冲区、深度缓冲区和模板缓冲区的值，这一步只是设置而并非真正的清除，每一个缓冲区的清除值都有默认值。之后调用glClear函数，通过设置参数，用上述设置的清除值清除指定的缓冲区。</p>
<p><img src="https://cdn.jsdelivr.net/gh/echo468/picgo@main/img/202304170934402.jpg" alt="img"> </p>
<p>2.纹理贴图</p>
<p>首先使用sgpugl_glGenTextures创建纹理对象，纹理对象的名称空间是无符号整数，纹理对象的名称仅限于在sgpugl_glGenTextures使用。sgpugl_glActiveTexture指定需要激活的纹理单元，之后的操作都在该纹理单元下进行（如果仅一个纹理单元默认为GL_TEXTURE0，可以指定多个纹理单元）。sgpugl_glBindTexture将纹理对象绑定在纹理目标上。如纹理对象texture1绑定在纹理单元GL_TEXTURE0下的纹理目标GL_TEXTURE_2D上。接下来的操作都是针对该纹理目标进行（一个纹理单元下可以有多个纹理目标）。sgpugl_glTexImage(12)D为该纹理目标指定纹理图片，生成纹理。sgpugl_glTexParameteri设置纹理参数，如环绕方式、过滤方式等。</p>
<p>在绘制前需要指定激活的纹理单元。采样器的类型识别纹理单元上的纹理目标。例如，采样器类型为的sampler2D，则采样器会在先前指定的纹理单元上选择纹理目标TEXTURE_2D，进而对纹理进行采样。</p>
<p>如下图是将三个纹理对象绑定在两个纹理单元下的三个纹理目标上，用其中一个纹理进行绘制的流程图。假如Draw前指定激活的纹理单元为GL_TEXTURE0，定位到红色区。假如着色器中采样器类型为的sampler2D，则定位到蓝色区域，找到对应纹理进行采样。</p>
<p>其中绿色区域的函数可以用指定的数据修改纹理目标指定区域的内容。</p>
<p><img src="https://cdn.jsdelivr.net/gh/echo468/picgo@main/img/202304170934497.jpg" alt="img"> </p>
<p>3.深度测试，多边形深度偏移</p>
<p>用1中的方法清除深度缓冲区，此处以默认值为例。在进行深度测试前必须先用sgpugl_glEnable启用深度测试功能。顶点X,Y坐标会从标准化设备坐标经过视口变换变成窗口坐标。z值根据sgpugl_glDepthRange(f)设置的范围也会从标准化设备坐标映射到窗口坐标，两个范围参数都限制在[0,1]。光栅化之后深度测试之前，如果较多片元的深度相差非常小，例如在相同的深度上绘制两个重叠的三角形，会发生z-Fighting。因此需要使用sgpugl_glEnable启用偏移，再通过sgpugl_glPolygonOffset对绘制的片元的深度值（由顶点插值得到）进行整体偏移。深度测试时通过sgpugl_glDepthFunc设置深度缓冲比较函数，默认为GL_LESS,即当前绘制的片元深度如果小于深度缓冲对应位置的深度值，则将颜色值写入颜色缓冲（之后可能被覆盖或者混合），否则丢弃。保留片元的深度值是否更到深度缓冲，通过glDepthMask设置。最后根据情况关闭深度测试和偏移。</p>
<p><img src="https://cdn.jsdelivr.net/gh/echo468/picgo@main/img/202304170934544.jpg" alt="img"> </p>
<p>4.颜色混合，Alpha测试</p>
<p>如果要绘制完全透明的物体，可以将全透明物体的Alpha值设置为0，将不透明物体的Alpha值设置为1。利用sgpugl_glEnable启用透明测试，透明测试在模板测试之前。sgpugl_glAlphaFunc可以指定透明度测试函数，此处以CL_GREATER，预设值为0.1为例。如果当前绘制的片元的Alpha为0，小于预设值，片元被丢弃。如果当前绘制的片元的Alpha为1，大于预设值，则保留片元。通过保留和丢弃片元来实现完全透明的效果。最后根据情况关闭透明测试。透明测试还常用于去除纹理图白色背景。</p>
<p>如果要绘制半透明物体，需要使用颜色混合（不透明物体直接颜色覆盖），该步骤在所有测试之后。绘制时要先绘制不透明物体（开启深度测试并允许深度写入）之后关闭深度写入，最后按照从远到近的顺序绘制半透明物体，不然可能会出现绘制错误。</p>
<p>情况1：半透明物体A在不透明物体B后</p>
<p>情况2：半透明物体A在不透明物体B前</p>
<p>情况3：半透明物体A在半透明物体B前</p>
<p>在情况1下，先绘制B再绘制A，且A不开启深度测试，不管A是否允许深度写入，A被遮挡的部分都会绘制出来。因此需要开启深度测试。在情况3下，先绘制A再绘制B，且A不禁止深度写入，B被遮挡的部分会被直接丢弃。因此需要禁止深度写入。在情况2下，假设先绘制A再绘制B，由于A禁止深度写入，B被遮挡的部分会绘制并覆盖A。因此需要先绘制不透明物体。在情况3下，先绘制A再绘制B，绘制B时，A为目标色B为源色；先绘制B再绘制A，绘制A时，B为目标色A为源色；根据混合算法的设置，这两次的结算结果可能不同。因此需要按照顺序绘制。</p>
<p>利用sgpugl_glEnable启用颜色混合，sgpugl_glBlendFunc可以指定颜色混合方式，即如何将深度测试保留的片元颜色值与颜色缓冲区对应的已存在的颜色值进行计算得到新的颜色值。最后根据情况关闭颜色混合或再次开启深度写入。</p>
<p><img src="https://cdn.jsdelivr.net/gh/echo468/picgo@main/img/202304170934584.jpg" alt="img"> </p>
<p>5.颜色填充</p>
<p>可以使用sgpugl_glColorPointer或者sgpugl_glColor设置顶点颜色数据，在使用sgpugl_glColorPointer前需先开启顶点颜色属性。但是sgpugl_glColorPointer优先级高于sgpugl_glColor，当使用sgpugl_glColorPointer时，不管sgpugl_glColor使用在sgpugl_glolorPointer前还是后，最后绘制出的颜色为顶点颜色数组定义的颜色。sgpugl_glColor可以对sgpugl_glVertexPointer定义的一组顶点数据设置统一的颜色，也可以在sgpugl_glBegin和sgpugl_glEnd中对每个顶点设置单独的颜色。sgpugl_glColorMask允许或禁⽌帧缓冲区某种通道的写⼊颜色缓冲。如果不允许R通道写入颜色缓冲，如果设置颜色为(1,0,1)紫色，最后绘制出来的会是(0,0,1)蓝色。注意如果着色模式不是平滑模式，则片元的颜色由图元的单个顶点得到。</p>
<p><img src="https://cdn.jsdelivr.net/gh/echo468/picgo@main/img/202304170934652.jpg" alt="img"> </p>
<p>6.模板测试</p>
<p>模板测试在深度测试之前。需要先清空模板缓冲区（清除值默认为0，每个值都为8位二进制，即有256种取值方式），并用sgpugl_glEnable启用模板测试。sgpugl_glStencilFunc设置模板测试的规则，如默认的“GL_ALWAYS，0, 0xFF”表示总是通过模板测试;下图中的“GL_NOTEQUAL，1，0xFF”表示如果片元对应模板缓冲的值不等于1，则通过模板测试。但是在比较之前，需要将模板缓冲的值和1分别与第三个参数0xFF进行与运算。sgpugl_glStencilOp设置如何更新模板缓冲，三个参数分别表示：模板测试失败时、模板测试通过但深度测试失败时及模板测试和深度测试都通过时采取的行为。如默认“GL_KEEP,GL_KEEP,GL_KEEP”表示无论测试结果如何，模板缓冲内的值都保持不变；下图中的“GL_KEEP,GL_KEEP,GL_REPLACE”表示当深度测试通过后，片元对应模板缓冲的值用sgpugl_glStencilFunc的第二个参数值代替。sgpugl_glStencilMask设置是否允许写入模板缓冲。如默认“0xFF”表示在写入模板缓冲之前，将写入的数和0xFF进行与运算（最后数保持原状，即允许写入）。如过设置“0x00”，写入的数会变成全0，即禁止写入，相当于sgpugl_glDepthMask（GL_FALSE）。也可以根据情况设置其他8位掩码。最后根据情况关闭模板测试。模板测试可用于绘制边框。</p>
<p><img src="https://cdn.jsdelivr.net/gh/echo468/picgo@main/img/202304170934268.jpg" alt="img"> </p>
<p>7.多边形正面判断，正背面剔除</p>
<p>在裁剪阶段，背面剔除用于绘制观察者所看到的面，不绘制看不到的面。这使得渲染的性能上可提高超过50%。gl按照如下方式区分图元的正面和背面： </p>
<p>正面：顶点连接顺序按照逆时针</p>
<p>背面：顶点连接顺序按照顺时针</p>
<p>Sgpugl_glFrontFace可以修改上述规则。注意顶点连接的顺序是相对于观察者而言的。因此图元是否需要剔除，是顶点连接顺序和观察者位置共同决定的。</p>
<p><img src="https://cdn.jsdelivr.net/gh/echo468/picgo@main/img/202304170934549.jpg" alt="img"> </p>
<p>8.渲染上下文的创建和管理</p>
<p><img src="https://cdn.jsdelivr.net/gh/echo468/picgo@main/img/202304170934751.jpg" alt="img"> </p>
<p>9.裁剪测试</p>
<p>裁剪测试在透明测试之前。先用sgpugl_glEnable启用裁剪测试，再用sgpugl_glScissor设置裁剪框，类似sgpugl_glViewport在窗口框出一块区域。但是sgpugl_glScissor是在裁剪框内的才进行绘制。sgpugl_glViewport相当于变相重置本次绘制的窗口，将所有需要绘制的物体映射在视口区域内。</p>
<p><img src="https://cdn.jsdelivr.net/gh/echo468/picgo@main/img/202304170934152.jpg" alt="img"> </p>
<p>10.顶点数据、矩阵变换、裁剪和视口</p>
<p>可以使用sgpugl_glVertexPointer或者在sgpugl_glBegin和sgpugl_glEnd中用sgpugl_glVertex设置顶点坐标数据，在使用sgpugl_glColorPointer前需先开启顶点坐标属性。</p>
<p>顶点首先经过世界变换（M）从模型空间变到世界空间，再经过观察变换（V）从世界空间变到观察空间，之后经过投影变换（P）从观察空间变到齐次裁剪空间。其中投影变换有正交投影和透视投影（近大远小）。上述变换需要对顶点坐标进行矩阵变换，在此之前需要先设置矩阵MV矩阵和P矩阵。可以用sgpugl_glLoadMatrixf自定义当前矩阵，也可以先通过sgpugl_glLoadIdentity将当前矩阵变成单位矩阵，再通过平移、旋转、缩放或者乘以其他矩阵得到最终需要的矩阵。但是调用draw前需要切换到MV空间下。</p>
<p>图元组装后进行裁剪，除了视锥体裁剪和背面剔除外，还可以通过sgpugl_glClipPlane设置裁剪平面进行图元裁剪，但是要先用sgpugl_glEnable启用裁剪平面。裁剪后对顶点坐标进行齐次除法即除以w使其变到NDC空间。最后通过视口变换将顶点坐标从NDC空间映射到视口区域的屏幕空间。</p>
<p><img src="https://cdn.jsdelivr.net/gh/echo468/picgo@main/img/202304170934683.jpg" alt="img"> </p>
<p>11.光照模型</p>
<p>使用光照模型需要提供顶点法线数据。物体的法线向量决定了它相对于光源的方向，从而计算顶点从光源接收的光线数量。可以使用sgpugl_glNormalPointer或者sgpugl_glNormal设置顶点法线数据，在使用sgpugl_glNormalPointer前需先开启顶点法线属性。sgpugl_glNormal可以对sgpugl_glVertexPointer定义的一组顶点数据设置统一的法线，也可以在sgpugl_glBegin和sgpugl_glEnd中对每个顶点设置单独的法线。</p>
<p>下一步开始使用光照模型。先用sgpugl_glEnable(GL_LIGHTING)开启整体光照效果。使用sgpugl_glLightfv设置光源，即设置入射光。光源最多设置8个，从GL_LIGHT0到GL_LIGHT7，每个光源可以设置的参数如下图。其中光源位置分为方向性光源（平行光）和位置性光源（点光源），聚光灯光源方向到光源的常数衰减因子这6个属性都是针对位置性光源。用sgpugl_glEnable开启光源，如sgpugl_glEnable（GL_LIGHT0）。接下来使用sgpugl_glMaterialfv设置光照模型的材质参数，即设置出射光。由于物体有两面，材质可能不同，因此要先确定为哪一面设置材质，可以设置的材质参数如下图。最后用sgpugl_glLightModelfv设置光照模型，便于进行光照计算。光照模型的概念由下图所示4个部分组成。</p>
<p><img src="https://cdn.jsdelivr.net/gh/echo468/picgo@main/img/202304170934799.jpg" alt="img"> </p>
<p>12.像素操作和帧缓冲区（更高版本的opengl基本不用这些）</p>
<p>（1）sgpugl_glCopyPixels进行像素的复制操作，从帧缓冲区复制到帧缓冲区，不涉及内存，因此避免了显存与内存间格式转换的问题，并且加快了运算速度。该函数前四个参数表示复制像素来源的矩形的左下角坐标、宽度和高度，可以当作是在窗口确认了一块矩形区域，第五个参数用于确认复制的内容，通常使用GL_COLOR，表示复制像素的颜色，但也可以是GL_DEPTH（深度缓冲数据）或GL_STENCIL（模板缓冲数据）。通过sgpugl_glRasterPos2f设置像素绘制的起始位置，系统会将该起始位置转换成窗口坐标，之后将会从起始位置绘制出刚刚窗口上指定的矩形中的内容。</p>
<p>（2）首先开辟一块内存空间。sgpugl_glReadPixels用于读取帧缓冲区的数据到内存，前四个参数同sgpugl_glCopyPixels，在窗口确认了一块矩形区域。第五个参数表示读取的内容，例如：GL_RGB就会依次读取像素的红、绿、蓝三种数据。第六个参数表示读取的内容保存到内存时所使用的格式，如GL_UNSIGNED_BYTE会把各种数据保存为GLubyte。第七个参数表示一个指针，即从帧缓冲区读取的数据保存在内存的位置。必要时可以使用sgpugl_glPixelStorei设置像素保存到内存时的对齐方式。通过sgpugl_glRasterPos2f设置像素绘制的起始位置(因此该函数比起sgpugl_glReadPixels少了第一个和第二个参数)，sgpugl_glDrawPixels将从内存读取数据到帧缓冲区，从起始位置绘制出刚刚窗口上指定的矩形中的内容。该绘制方法比起sgpugl_glCopyPixels速度较慢，因为整个过程是从显存-内存-显存，并且涉及格式转换问题。</p>
<p>（3）sgpugl_glBitmap用于将位图数据绘制在屏幕，位图数据可以理解为0、1矩阵，为1则在屏幕的对应像素绘制、为0不绘制。</p>
<p><img src="https://cdn.jsdelivr.net/gh/echo468/picgo@main/img/202304170938068.png" alt="image-20230417093822003"></p>
<p>​		第（3）部分代码如下，glBitmap函数参数前两位定义了位图的宽、高，如图字符大小为12*8的方阵，每一行数据用8位16进制表示。注意位图数据总是按块存储，每块的位数总是8的倍数，但实际位图的宽并不一定使8的倍数。组成位图的位从位图的左下角开始画：首先画最底下的一行，然后是这行的上一行，依此类推。第三、四个参数指定了位图的原点，默认为左下角，向上和向右为正方向。第五、六个参数指定该在位图光栅化后光栅位置的增量，如下代码的意思是第二个字符F在第一个字符F的基础上分别向X正轴和Y正轴移动20个像素单位。 （不过试的时候发现glRasterPos2i(0, 0)才显示，glRasterPos2i(20, 20)不显示，所以不太清楚这里的坐标系）</p>
<p><img src="https://cdn.jsdelivr.net/gh/echo468/picgo@main/img/202304272020851.png" alt="image-20230427202027799"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">GLubyte rasters[<span class="number">12</span>] = &#123;</span><br><span class="line">    <span class="number">0xc0</span>, <span class="number">0xc0</span>, <span class="number">0xc0</span>, <span class="number">0xc0</span>, <span class="number">0xc0</span>, <span class="number">0xfc</span>,</span><br><span class="line">    <span class="number">0xfc</span>, <span class="number">0xc0</span>, <span class="number">0xc0</span>, <span class="number">0xc0</span>, <span class="number">0xff</span>, <span class="number">0xff</span>&#125;;</span><br><span class="line"><span class="built_in">glColor3f</span>(<span class="number">1.0</span>, <span class="number">0.0</span>, <span class="number">0.0</span>);<span class="comment">//必须放RasterPos2i前</span></span><br><span class="line"><span class="built_in">glPixelStorei</span>(GL_UNPACK_ALIGNMENT, <span class="number">1</span>); </span><br><span class="line"><span class="comment">//光栅位置坐标与glVertex()提供的坐标同样对待,位于视口以外的点的当前光栅位置无效</span></span><br><span class="line"><span class="built_in">glRasterPos2i</span>(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"><span class="built_in">glBitmap</span>(<span class="number">8</span>, <span class="number">12</span>, <span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">20.0</span>, <span class="number">20.0</span>, rasters);</span><br><span class="line"><span class="built_in">glBitmap</span>(<span class="number">8</span>, <span class="number">12</span>, <span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">0.0</span>,<span class="number">0.0</span>, rasters);</span><br></pre></td></tr></table></figure>
<p>​		不过位图的宽高和实际给的位图数据也可能不同。</p>
<img src="C:\Users\华为\AppData\Roaming\Typora\typora-user-images\image-20230427203459953.png" alt="image-20230427203459953" style="zoom:50%;" />

<p>13.图元绘制</p>
<p>首先确定绘制的图元类型，注意gpugl_glDrawArrays和sgpugl_glBegin的图元参数不同。</p>
<table>
<thead>
<tr>
<th>图元类型</th>
<th>gpugl_glDrawArrays是否有该参数</th>
<th>sgpugl_glBegin是否有该参数</th>
<th>流程图中对应类型</th>
</tr>
</thead>
<tbody><tr>
<td>GL_POINTS</td>
<td>√</td>
<td>√</td>
<td>点</td>
</tr>
<tr>
<td>GL_LINES</td>
<td>√</td>
<td>√</td>
<td>线一类</td>
</tr>
<tr>
<td>GL_LINE_LOOP</td>
<td>√</td>
<td>√</td>
<td>线一类</td>
</tr>
<tr>
<td>GL_LINE_STRIP</td>
<td>√</td>
<td>√</td>
<td>线一类</td>
</tr>
<tr>
<td>GL_TRIANGLES</td>
<td>√</td>
<td>√</td>
<td>三角形一类&#x2F;多边形</td>
</tr>
<tr>
<td>GL_TRIANGLE_STRIP</td>
<td>√</td>
<td>√</td>
<td>三角形一类&#x2F;多边形</td>
</tr>
<tr>
<td>GL_TRIANGLE_FAN</td>
<td>√</td>
<td>√</td>
<td>三角形一类&#x2F;多边形</td>
</tr>
<tr>
<td>GL_POLYGON</td>
<td>×</td>
<td>√</td>
<td>三角形一类&#x2F;多边形</td>
</tr>
<tr>
<td>GL_QUADS</td>
<td>×</td>
<td>√</td>
<td>三角形一类&#x2F;多边形</td>
</tr>
<tr>
<td>GL_QUAD_STRIP</td>
<td>×</td>
<td>√</td>
<td>三角形一类&#x2F;多边形</td>
</tr>
</tbody></table>
<p>如果是绘制点可以用sgpugl_glPointSize(f)设置光栅化时一个点的直径，默认为1。如果绘制线，可以用sgpugl_glLineWidth设置直线宽度，默认为1。</p>
<p>直线可以用点画模式进行绘制。首先通过sgpugl_glEnable开启点画模式。sgpugl_glLineStipple设置点画的方式，其参数是由0、1组成的16位模式序列和重复因子，从模式低位开始，如果模式中的位是1，直线中对应像素就被绘制，否则就不绘制（如果直线长度大于16位则不断重复上述规则）。重复因子用来扩展模式，如模式中如果出现3个1会被扩展成个6个1。如果没有启用点画线功能，模式默认为OxFFFF、重复因子为1。多边形也可以用点画模式进行绘制。首先通过sgpugl_glEnable开启点画模式。sgpugl_glPolygonStipple设置点画的方式，其参数是一个指向32<em>32的位图指针，可以理解为32</em>32的0、1矩阵，通过GLubyte数组自定义（128个2位16进制序列）。从每个序列低位开始，模式中的位是1，多边形中对应像素就被绘制，否则就不绘制（如果多边形像素大于32*32则不断重复上述规则）。</p>
<p>sgpugl_glShadeModel用于设置平滑着色或者恒定着色。注意除了GL_POLYGON以外，恒定着色图元中片元的颜色为图元最后一个顶点的颜色，而GL_POLYGON下图元中片元的颜色为图元第一个顶点的颜色。</p>
<p>设置完上述所有后即可调用绘制函数，注意sgpugl_glDrawElements除了需要顶点数据以外，还需要索引数据。</p>
<p><img src="https://cdn.jsdelivr.net/gh/echo468/picgo@main/img/202304170934468.jpg" alt="img"> </p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
    </footer>
  </div>

    
 
   
</article>

    
    <article
  id="post-X11窗口_glfw_链接"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2023/04/03/X11%E7%AA%97%E5%8F%A3_glfw_%E9%93%BE%E6%8E%A5/"
    >X11窗口、glfw和链接</a> 
</h2>
 

    </header>
     
    <div class="article-meta">
      <a href="/2023/04/03/X11%E7%AA%97%E5%8F%A3_glfw_%E9%93%BE%E6%8E%A5/" class="article-date">
  <time datetime="2023-04-03T02:08:23.000Z" itemprop="datePublished">2023-04-03</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E5%AE%9E%E4%B9%A0/">实习</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h4 id="文件区分"><a href="#文件区分" class="headerlink" title="文件区分"></a>文件区分</h4><p>​		glut跨平台窗口库；glfw跨平台窗口库（glut替代版）；glut和glfw封装了Window的窗口管理系统，linux的窗口管理系统和创建上下文等（这些操作在每个系统上不同，所以该文件将其封装使得我们可以直接使用）。它提供了一些渲染物体所需的最低限度的接口。它允许用户创建OpenGL上下文、定义窗口参数以及处理用户输入。</p>
<p>  GL&#x2F;gl.h是基本的OpenGL标头，可提供OpenGL-1.1函数和令牌声明，甚至更多。对于超过1.1版的任何内容，都必须使用OpenGL扩展机制。由于这是一项枯燥而乏味的任务，因此GLEW项目已将其自动化，该项目将所有细节打包在一个易于使用的库中。该库的声明位于头文件GL&#x2F;glew.h中，该文件隐含了常规的OpenGL标头，因此在包含GL&#x2F;glew.h时，不再需要包含GL&#x2F;gl.h，包含该头文件可以使用gl,glu,glext,wgl,glx里的全部函数。glad.h与glew.h作用相同，可以看作其升级版。这两个头文件使用时要放在glfw3.h 或者glut.h文件之前。gl3w.h和glad.h作用类似。</p>
<h4 id="glfw和上下文"><a href="#glfw和上下文" class="headerlink" title="glfw和上下文"></a>glfw和上下文</h4><p>​		除了窗口创建，glfw还封装了上下文创建。glfw可以用elg和glx创建上下文，egl可以支持gl、es和vukan，glx支持gl扩展支持es。glfw系统库为高版本3.3.2，可以在应用程序中对glfw进行配置。如下代码希望在运行gl程序使用glx的上下文，在运行es程序使用egl的上下文。其实在glfwinit的时候已经默认使用glx的上下文，支持gl和es了，所以在if(casetype&#x3D;&#x3D;”gl”)后不需要显示指定，也可以保证在运行gl程序使用glx的上下文，并且支持es。不过为了使得运行es程序使用egl的上下文，需要设置GLFW_CONTEXT_CREATION_API和GLFW_CLIENT_API，注释如下。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>( !<span class="built_in">glfwInit</span>() )</span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">fprintf</span>( stderr, <span class="string">&quot;Failed to initialize GLFW\n&quot;</span> );</span><br><span class="line">	<span class="built_in">getchar</span>();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(casetype==<span class="string">&quot;gl&quot;</span>)&#123;</span><br><span class="line">    <span class="comment">//采样</span></span><br><span class="line">	<span class="built_in">glfwWindowHint</span>(GLFW_SAMPLES, <span class="number">4</span>);</span><br><span class="line">    <span class="comment">//版本</span></span><br><span class="line">	<span class="built_in">glfwWindowHint</span>(GLFW_CONTEXT_VERSION_MAJOR, <span class="number">2</span>);</span><br><span class="line">	<span class="built_in">glfwWindowHint</span>(GLFW_CONTEXT_VERSION_MINOR, <span class="number">1</span>);</span><br><span class="line">    <span class="comment">//opengl模式</span></span><br><span class="line">	<span class="built_in">glfwWindowHint</span>(GLFW_OPENGL_PROFILE, 			GLFW_OPENGL_COMPAT_PROFILE);</span><br><span class="line">    <span class="comment">//用户不能调节窗口大小</span></span><br><span class="line">    <span class="built_in">glfwWindowHint</span>(GLFW_RESIZABLE, GL_FALSE);</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="built_in">glfwWindowHint</span>(GLFW_SAMPLES, <span class="number">16</span>);</span><br><span class="line">    <span class="comment">//上下文指定egl</span></span><br><span class="line">    <span class="built_in">glfwWindowHint</span>(GLFW_CONTEXT_CREATION_API, 	GLFW_EGL_CONTEXT_API);</span><br><span class="line">    <span class="comment">//API使用opengl es</span></span><br><span class="line">    <span class="built_in">glfwWindowHint</span>(GLFW_CLIENT_API, GLFW_OPENGL_ES_API);</span><br><span class="line">    <span class="built_in">glfwWindowHint</span>(GLFW_CONTEXT_VERSION_MAJOR, <span class="number">3</span>);</span><br><span class="line">    <span class="built_in">glfwWindowHint</span>(GLFW_CONTEXT_VERSION_MINOR, <span class="number">2</span>);</span><br><span class="line">    <span class="built_in">glfwWindowHint</span>(GLFW_RESIZABLE, GL_FALSE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​		GLFW_OPENGL_PROFILE用于指定opengl模式，opengl es无该模式。opengl模式有COMPAT和COREl两种，CORE抛弃了部分用法，如果想兼容，使用COMPAT会少很多问题。</p>
<p>​	在如上代码中，如果程序以gl-es-gl的顺序运行，在运行到es时，进入else使用egl创建上下文，调用es的API；之后运行最后一个gl时，进入if，由于if中没有显示指定上下文和调用的API，因此还是会使用egl创建上下文，调用es的API。</p>
<p>​		在低版本的glfw文件中，链接的不是系统库而是用户自己指定的库，不能在应用程序设置，而是通过Cmakelists.txt设置，如下，通过ON和OFF设置是否使用egl创建上下文。</p>
<img src="https://cdn.jsdelivr.net/gh/echo468/picgo@main/img/202304121622378.png" alt="image-20230412162211136" style="zoom:67%;" />

<p>​		egl用于关联原生窗口，创建上下文，通过eglBindAPI指定使用gl还是es，与平台无关(窗口-egl-API)。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">eglBindAPI</span>(EGL_OPENGL_ES_API);<span class="comment">//绑定ES的API</span></span><br><span class="line"><span class="built_in">eglBindAPI</span>(EGL_OPENGL_API);<span class="comment">//绑定GL的API</span></span><br></pre></td></tr></table></figure>

<h4 id="X11窗口"><a href="#X11窗口" class="headerlink" title="X11窗口"></a>X11窗口</h4><p>1、在linux中，“X11”指的是“X Window System”，是图形化窗口管理系统。因此调用X11使得窗口可以在linux上运行，不能在windows上运行。</p>
<p>2、使用API时，gl.h头文件中只有函数声明，需要链接到函数实现，glfw已经封装了函数链接，如果直接用X11创建窗口需要在Makefile手动链接。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LD_LIBS=-lX11 -lXext -lEGL -lGL //链接GL</span><br></pre></td></tr></table></figure>

<p>3、X11窗口创建的部分函数和窗口监听</p>
<p>​		创建窗口前先打开与server 的连接。在程序可以使用display 之前，必须先建立一个和X server 的连接。这个连接建立以后，就可以使用Xlib 的函数或宏定义来获得display 的信息了。当参数设置为NULL时，为默认的display环境变量。这个函数返回一个指向display类型结构的指针，表明与X server建立了连接，并且包含了X server的所有信息，可以使用display之上所有窗口。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Display *display = XOpenDisplay(NULL);</span><br></pre></td></tr></table></figure>

<p>​		在进行了一些配置参数配置后，使用如下两个函数创建窗口（参数含义以及创建窗口前的配置流程暂时未知）。函数返回创建的窗口的ID，并使得X server产生一个CreateNotify 事件。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">XCreateWindow</span><br><span class="line">XCreateSimpleWindow</span><br></pre></td></tr></table></figure>

<p>​		X是一个服务器–客户端的结构。由服务器向客户端发送事件信息，让客户端知道发生了什么事情，然后客户端告诉服务器它感兴趣的是什么事情，也就是说，客户端会对那些事件产生反应。如下函数用于客户端告诉服务器窗口会对哪些事情有响应。StructureNotifyMask 即改变窗口状态，比如尺寸，位置等，对应事件ConfigureNotify；ExposureMask 对应事件Expose ；KeyPressMask 即键盘响应对应事件KeyPress。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">XSelectInput(display, win,ExposureMask|StructureNotifyMask);</span><br></pre></td></tr></table></figure>

<p>​		创建窗口之后，窗口并不能显示出来，需要调用如下函数来 画窗口让它显示。如果这个窗口有父窗口，那么在所有父窗口没有画出来之前，这个窗口即使用了这个函数，也是不能显示出来的。必须等所有父窗口都显示了，这个窗口才能画。X server产生一个MapNotify事件。客户端已经有相应操作了，绘制窗口。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">XStoreName (display, win, &quot;gears&quot;);//设置窗口名</span><br><span class="line">XMapWindow(display, win);</span><br></pre></td></tr></table></figure>

<p>​		进入窗口事件循环，获得事件，处理或丢弃。接收到的事件由XNextEvent 函数从消息队列里获得，把事件放到event.type 里并从队列里删除该消息 。当队列为空也就是没有下一个事件被接收时，程序就一直停留在XNextEvent里直到有下一个事件，无法执行之后的步骤。因此可以使用XPending(display)在有事件的时候响应事件，没有事件的时候在窗口上绘制。如果窗口的信息改变了，就需要XFlush 函数让窗口重画，但XNextEvent函数会隐式地调用XFlush。在opengl绘制函数的部分，glClearColor设置窗口颜色后，需要用</p>
<p>​		glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);</p>
<p>​		用上述指定颜色初始化颜色缓存，使用默认值初始化深度缓存，再利用函数</p>
<p>​		eglSwapBuffers(mContext.eglDisplay, mContext.eglSurface);才能显示在窗口（此处以egl配置上下文为例）。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">XEvent myevent;</span><br><span class="line">while (1) &#123;       </span><br><span class="line">      if (XPending(display)) &#123;</span><br><span class="line">       XNextEvent(display, &amp;myevent);</span><br><span class="line">       switch(myevent.type) &#123;</span><br><span class="line">       case ClientMessage:&#123;</span><br><span class="line">       &#125;</span><br><span class="line">       case ConfigureNotify:&#123;</span><br><span class="line">       &#125;&#125;&#125;</span><br><span class="line">     /*opengl绘制函数*/</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>​		关闭窗口事件（若窗口关闭则打印信息）</p>
<pre><code>//while循环外
Atom deleteAtom = XInternAtom(display, &quot;WM_DELETE_WINDOW&quot;, False);
XSetWMProtocols(display, win, &amp;deleteAtom, 1);
//while循环内
 case ClientMessage:&#123;
       if ((unsigned)myevent.xclient.data.l[0] == deleteAtom)&#123;
           printf(&quot;X WINDOW DELETED\n&quot;);
           return 0;
       &#125;
   &#125;
</code></pre>
<p>​		窗口改变事件</p>
<p>​		如下函数通过代码人为改变并重新设置窗口，因此一直存在ConfigureNotify事件。</p>
<pre><code>const unsigned int mask = CWWidth | CWHeight;
XWindowChanges changes;
int newWidth = 128, newHeight = 128;
changes.width = newWidth;
changes.height = newHeight;
XConfigureWindow(display, win, mask, &amp;changes);
</code></pre>
<p>​    	如下函数获取由外部事件对窗口产生的变化并改变viewport，使得绘制的图像根据窗口的变化变化，在外部事件发生时才存在ConfigureNotify事件。</p>
<pre><code>case ConfigureNotify:&#123;
    reshape(myevent.xconfigure.width,myevent.xconfigure.height); 
    break;
&#125;
</code></pre>
<p>​	  Expose 事件可能用于绘制和显示，在opengl绘制部分外部可以添加case Expose 。</p>
<p>​	  退出窗口时，需要关闭和X server 的连接，于是也就销毁了相关资源，关闭了窗口。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">XDestroyWindow(display, win);</span><br><span class="line">XCloseDisplay(display)；</span><br></pre></td></tr></table></figure>

<p>参考链接：</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/rufanchen_/article/details/7640584">https://blog.csdn.net/rufanchen_&#x2F;article&#x2F;details&#x2F;7640584</a></p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/okgogo2000/p/4322753.html">https://www.cnblogs.com/okgogo2000/p/4322753.html</a></p>
<h4 id="源文件-gt-可执行文件过程"><a href="#源文件-gt-可执行文件过程" class="headerlink" title="源文件-&gt;可执行文件过程"></a>源文件-&gt;可执行文件过程</h4><p>1.预处理：包括删除注释、宏扩展、#include文件包含等。预处理后生成.i文件。</p>
<p>2.编译：由编译器完成，检查语法及语义，生成错误或警告。编译后生成汇编语言.s文件。</p>
<p>3.汇编：将汇编文件翻译成机器码指令（二进制），将指令打包形成.o目标文件。</p>
<p>4.链接：完成调用的各种函数、静态库和动态库的链接，从函数原型链接到函数实现。形成.exe文件。</p>
<h4 id="Linux平台下cmake和make的区别"><a href="#Linux平台下cmake和make的区别" class="headerlink" title="Linux平台下cmake和make的区别"></a>Linux平台下cmake和make的区别</h4><p>Makefile编译规则文件。</p>
<p>make通过Makefile文件自动化批量处理编译，将源文件变成最终的可执行文件（包含gcc的功能）。</p>
<p>不同平台的Makefile文件不同，cmake作为跨平台编译工具可以将CMakeLists.txt文件转化为所需要的Makefile文件</p>
<h4 id="Cmake"><a href="#Cmake" class="headerlink" title="Cmake"></a>Cmake</h4><p>window平台下利用Cmake软件代替Linux下的cmake命令，用编译器如vs代替Linux下的make命令。</p>
<p>Cmake软件将cmake分为两步：</p>
<p>1.Configure：配置，生成需要的文件夹及准备文件</p>
<p>2.Generate：根据CMakeLists.txt生成工程文件。如果编译器选择vs，则生成vs工程文件，如果是Linux，则生成Makefile。生成vs工程文件，同Linux生成Makefile文件，都是规定了编译规则。</p>
<p>最后由vs执行工程，即执行make。</p>
<h4 id="动态库和静态库"><a href="#动态库和静态库" class="headerlink" title="动态库和静态库"></a>动态库和静态库</h4><p>1.区别</p>
<p>​		使用封装好的库函数十分方便并且十分高效，库分为静态库和动态库。</p>
<table>
<thead>
<tr>
<th align="center">库类型</th>
<th align="center">windows</th>
<th align="center">linux</th>
</tr>
</thead>
<tbody><tr>
<td align="center">静态库</td>
<td align="center">.lib</td>
<td align="center">.a</td>
</tr>
<tr>
<td align="center">动态库</td>
<td align="center">.dll</td>
<td align="center">.so</td>
</tr>
</tbody></table>
<p>​		当程序与静态库链接时，静态库中所包含的所有函数方法都会被拷贝到最终的可执行文件中去。这就会导致最终生成的可执行代码量相对变多，相当于编译器将代码补充完整了。编译后的可执行程序不需要静态库，因为所有使用的函数都已经被编译进去了。这种方式会让程序运行起来相对快一些，不过也会有个缺点: 占用磁盘和内存空间，导致可执行程序过大。另外，静态库会被添加到和它链接的每个程序中去, 而且这些程序运行时, 都会被加载到内存中，无形中又多消耗了更多的内存空间。  与动态库链接的可执行文件只包含它需要的函数方法的引用表，而不是所有的函数代码，只有在程序执行时, 那些需要的函数代码才会被拷贝到内存中。这样就使可执行文件比较小, 节省磁盘空间，更进一步，操作系统使用虚拟内存，使得一份动态库驻留在内存中被多个程序使用，也同时节约了内存。不过由于运行时要去链接库会花费一定的时间，执行速度相对会慢一些。如果要修改的刚好是库函数的话，在接口不变的前提下，使用动态库的程序只需要将动态库重新编译就可以了，而使用静态库的程序则需要将静态库重新编译好后，将程序再重新编译一遍。</p>
<p>2.两种链接</p>
<p>​		现在源程序main.cpp链接库sub,sub链接库add</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*add.h */</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> _ADD_H_</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _ADD_H_</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">()</span></span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">------------------------------------------------------------</span><br><span class="line"><span class="comment">/*add.c*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;add.h&quot;</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;add\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">------------------------------------------------------------</span><br><span class="line"><span class="comment">/*sub.h*/</span>v</span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> _SUB_H_</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _SUB_H_</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sub</span><span class="params">()</span></span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">----------------------------------------------------------</span><br><span class="line"><span class="comment">/*sub.c*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;add.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;sub.h&quot;</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sub</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;sub\n&quot;</span>);</span><br><span class="line">    <span class="built_in">add</span>();</span><br><span class="line">&#125;</span><br><span class="line">------------------------------------------------------------</span><br><span class="line"><span class="comment">/*main.c*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;sub.h&quot;</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">sub</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gcc -c add.c</span><br><span class="line">gcc -c sub.c</span><br></pre></td></tr></table></figure>

<p>​		首先生成的文件：sub.o ，add.o，无论是静态库文件还是动态库文件，都是由 .o 文件创建。使用-c不会链接、生成可执行文件，只会预处理、编译和汇编。</p>
<p>（1）静态库</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ar cr libadd.a add.o</span><br><span class="line">ar cr libsub.a sub.o </span><br></pre></td></tr></table></figure>

<p>​		ar：静态函数库创建的命令</p>
<p>​		-c :create创建</p>
<p>​		库文件的命名规范是以lib开头（前缀），紧接着是静态库名，以 .a 为后缀名。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -o main main.c -L . –l sub -L . –l add</span><br></pre></td></tr></table></figure>

<p>​		-L ：指定函数库查找的位置，’.’表示在当前目录下查找</p>
<p>​		-l：指定函数库名，其中的lib和.a(.so)省略。</p>
<p>​		-o:链接，生成可执行文件，指名生成的可执行文件名</p>
<p>​	  使用静态库内部函数，只需要在使用到这些函数的源程序中包含这些函数的原型声明（头文件），然后在用gcc命令生成可执行文件时指明静态库名，gcc将会从静态库中将函数拷贝到可执行文件中。gcc会在静态库名前加上前缀lib，然后追加扩展名.a得到的静态库文件名来查找静态库文件。在程序main.c中，包含了静态库的头文件sub.h，然后在主程序main中直接调用函数sub()即可。生成可执行文件后静态库可以不再需要。</p>
<p>​		注意：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gcc -o main main.c -L . –l sub </span><br><span class="line">gcc -o main main.c -L . –l add -L . –l sub</span><br></pre></td></tr></table></figure>

<p>​		都会发生sub无法链接到add导致sub中的函数undefined reference to，因此链接顺序不能变，而且用main链接sub和add即可，不需要单独写一行sub链接add。</p>
<p>（2）动态库</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">gcc -fPIC -o add.o -c add.c</span><br><span class="line">gcc  -fPIC  -o sub.o -c sub.c</span><br><span class="line">gcc -shared -o libadd.so add.o</span><br><span class="line">gcc -shared -o libsub.so sub.o</span><br></pre></td></tr></table></figure>

<pre><code>     -fpic:产生代码位置无关代码,则产生的代码中，没有绝对地址，全部使用相对地址，故而代码可以被加载器加载到内存的任意位置，都可以正确的执行。这正是共享库所要求的，共享库被加载时，在内存的位置不是固定的。
</code></pre>
<p>​		-shared ：生成共享库</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -o main main.c -L . –l sub -L . –l add</span><br></pre></td></tr></table></figure>

<p>​		.&#x2F;执行时会发生如下报错：</p>
<pre><code>     error while loading shared libraries:libmymath.so: cannot open shared object file: No such file or directory
</code></pre>
<p>​		原因如下：</p>
<p>​		gcc -o 链接器工作于链接阶段，工作时需要-l指定库名和-L指定库路径。如果在指定库路径没有找到库，会发生</p>
<p>undefined reference to的报错，导致可执行文件无法生成。但是有时不会发生该报错，可以对make添加-WL -Z DEFS编译选项，在生成可执行文件前找到该错误。</p>
<p>​		.&#x2F;运行可执行程序时还需要动态链接器，工作于程序运行阶段，工作时需要提供动态库所在目录位置。该目录与上述-L指定的路径不同，动态链接器去固定位置（通过环境变量）查找动态库，如果找不到就会报错，所以需要先将动态库的工作目录加入到环境变量中。一般会去默认的动态库搜索路径&#x2F;usr&#x2F;lib查找，可以将.so文件复制到&#x2F;usr&#x2F;lib中来解决上述报错。</p>
<h4 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ldd exe 查看可执行程序运行时链接的动态库</span><br></pre></td></tr></table></figure>

<p>​		如果在源文件的头文件中使用</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;GLFW/glfw3.h&gt;</span></span></span><br></pre></td></tr></table></figure>

<p>​		则之后会默认链接到&#x2F;usr&#x2F;lib下的系统库（库名&#x3D;&gt;目录）</p>
<p><img src="https://cdn.jsdelivr.net/gh/echo468/picgo@main/img/202304120856844.png" alt="image-20230412085632785"></p>
<p>​		在项目文件中添加一个新文件夹，使用自定义的glfw库文件。</p>
<p><img src="https://cdn.jsdelivr.net/gh/echo468/picgo@main/img/202304120901444.png" alt="image-20230412090145388"></p>
<p>​		头文件会链接到自己的库文件而不是系统的库文件。编译源文件时，需要将glfw文件一起编译，因此需要修改源文件的Cmakelist.txt文件。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">add_subdirectory(external) </span><br></pre></td></tr></table></figure>

<p>​		cmake会通过源文件的Cmakelist.txt找到external目录下的Cmakelist.txt</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">include_directories（external/glfw-3.1.2/include/GLFW）</span><br></pre></td></tr></table></figure>

<p>​		向工程添加多个特定的头文件搜索路径，添加该行后源文件的头文件部分可以改成</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;glfw3.h&gt;</span></span></span><br></pre></td></tr></table></figure>

<p>​		如果包含头文件后，没有找到external目录下的Cmakelist.txt，无法生成自己的库文件，最后还是会链接到系统库。如果glfw文件编译链接成功，最后就会链接到自己的库。在Cmakelist.txt或者其他文件中指明了动态链接库的搜索位置，因此不会去默认的路径&#x2F;usr&#x2F;lib。</p>
<p><img src="https://cdn.jsdelivr.net/gh/echo468/picgo@main/img/202304120915237.png" alt="image-20230412091529196"></p>
<h4 id="gdb调试"><a href="#gdb调试" class="headerlink" title="gdb调试"></a>gdb调试</h4><p><img src="https://cdn.jsdelivr.net/gh/echo468/picgo@main/img/202304120919388.png" alt="image-20230412091902342"></p>
<p>​		可以用如下方式调试：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ gdb 可执行程序名</span><br><span class="line">(gdb) b 函数名 //设置断点，运行到该函数暂停</span><br><span class="line">(gdb) run //运行到第一个断点暂停</span><br><span class="line">(gdb) c	//继续运行到下一个断点暂停</span><br><span class="line">(gdb) quit //退出gdb环境</span><br></pre></td></tr></table></figure>

 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
    </footer>
  </div>

    
 
   
</article>

    
    <article
  id="post-计算着色器"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2023/03/14/%E8%AE%A1%E7%AE%97%E7%9D%80%E8%89%B2%E5%99%A8/"
    >计算着色器</a> 
</h2>
 

    </header>
     
    <div class="article-meta">
      <a href="/2023/03/14/%E8%AE%A1%E7%AE%97%E7%9D%80%E8%89%B2%E5%99%A8/" class="article-date">
  <time datetime="2023-03-14T01:35:48.000Z" itemprop="datePublished">2023-03-14</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E5%AE%9E%E4%B9%A0/">实习</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <p>计算着色器是在GPU上运行的，是在普通渲染管线之外的着色器程序。计算着色器是完全用于计算任意信息的着色器阶段。虽然它可以进行渲染，但它通常用于与绘制三角形和像素没有直接关系的任务。利用GUP的快速计算和并行性，可以用于处理大量的计算。</p>
<p>opengl4.3才开始支持计算着色器，opengl es是3.1才开始支持计算着色器。</p>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#version 320 es</span></span><br><span class="line"><span class="keyword">layout</span> (<span class="keyword">local_size_x</span> = <span class="number">1</span>) <span class="keyword">in</span>; </span><br><span class="line"><span class="keyword">layout</span> (<span class="keyword">rgba32f</span>, <span class="keyword">binding</span> = <span class="number">0</span>) <span class="keyword">uniform</span> <span class="keyword">readonly</span> <span class="keyword">mediump</span> <span class="type">imageBuffer</span> po_buffer;</span><br><span class="line"><span class="keyword">layout</span> (<span class="keyword">rgba32f</span>, <span class="keyword">binding</span> = <span class="number">1</span>) <span class="keyword">uniform</span> <span class="keyword">writeonly</span> <span class="keyword">mediump</span> <span class="type">imageBuffer</span> po_buffer1;</span><br><span class="line"><span class="type">void</span> main()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//此处全局工作组和本地工作组yz均为1，因此可以通过x确定位置</span></span><br><span class="line">    <span class="type">int</span> pos = <span class="type">int</span>(<span class="built_in">gl_GlobalInvocationID</span>.x);</span><br><span class="line">    <span class="type">vec4</span> value = <span class="built_in">imageLoad</span>(po_buffer, pos);</span><br><span class="line">    value.x = value.x+<span class="number">0.4</span>;</span><br><span class="line">    value.y = value.y+<span class="number">0.4</span>;</span><br><span class="line">    <span class="built_in">imageStore</span>(po_buffer1, pos, value); </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>binding与之后glBindImageTexture的第一个参数相同，通过ID绑定对应的tbo，而tbo绑定对应的buffer。相当于通过绑定知道从哪个buffer读取数据，从哪个buffer写入数据。因为此处是读取buffer所以使用imageBuffer，如果是数组的话可能使用image2D。es需要指定精度，所以添加mediump。同时因为需要读取的是rgba而不是r（如果只设置r，value就无法读取y值），所以需要指定readonly和writeonly。但是在opengl4.3中不需要指定精度，并且读写可以在一个buffer中进行。</p>
<p>imageLoad从buffer的指定位置读取数据，imageStore将值写入buffer的指定位置。</p>
<p>计算着色器任务以组为单位进行执行，称为工作组。拥有邻居的工作组被称为本地工作组（局部）, 这些组可以组成更大的组，称为全局工作组，而全局工作组通常作为执行命令的一个单位。计算着色器会被全局工作组中每一个本地工作组中的每一个单元调用一次，工作组的每一个单元称为工作项，每一次调用称为一次执行。执行的单元之间可以u通过变量和显存进行通信（不同工作组不能通信），且可执行同步操作保持一致性（单个工作组内可以并行）。</p>
<p>如下例子假设全局工作组yz轴都为1 ，局部工作组只有xy：</p>
<p>gl_LocalInvocationID.x × local_size_y+gl_LocalInvocationID.y+local_size_x×local_size_y×gl_WorkGroupID.x&#x3D;gl_GlobalInvocationID.x×local_size_y×y轴的工作组个数+gl_GlobalInvocationID.y</p>
<p>local_size是本地工作组的大小，有xyz三个维度，不设置默认为1。gl_WorkGroupID本地工作组在全局工作组的索引（从0开始），local_size_x×local_size_y本地工作组的大小（该大小尽量与硬件匹配），gl_LocalInvocationID工作项在本地工作组的坐标（从0开始）。gl_GlobalInvocationID：在全局工作组中，当前工作项所在位置。（在es中imageLoad后的pos只能使用int，所以可以设置本地工作组和全局工作组yz均为1，这样可以只使用gl_GlobalInvocationID.x就可以遍历到所有数据，否则可以通过上述公式计算。）本地工作组的大小×全局工作组的大小-&gt;所有需要遍历的数据</p>
<p>与普通着色器一样正常链接</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">computeShader = LoadShader(GL_COMPUTE_SHADER, cShaderStr);</span><br><span class="line">compute_prog = glCreateProgram();</span><br><span class="line"><span class="keyword">if</span> (compute_prog == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">glAttachShader(compute_prog, computeShader);</span><br><span class="line">glLinkProgram(compute_prog);</span><br></pre></td></tr></table></figure>
<p> 将顶点数据arraybuffer与texbuffer绑定</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">glGenBuffers(<span class="number">1</span>, &amp;po_buffer);</span><br><span class="line">glBindBuffer(GL_ARRAY_BUFFER, po_buffer);</span><br><span class="line">glBufferData(GL_ARRAY_BUFFER, <span class="keyword">sizeof</span>(vVertices), vVertices, GL_DYNAMIC_COPY);</span><br><span class="line"></span><br><span class="line">glGenBuffers(<span class="number">1</span>, &amp;po_buffer1);</span><br><span class="line">glBindBuffer(GL_ARRAY_BUFFER, po_buffer1);</span><br><span class="line">glBufferData(GL_ARRAY_BUFFER, <span class="keyword">sizeof</span>(vVertices),vVertices, GL_DYNAMIC_COPY);</span><br><span class="line"></span><br><span class="line">glGenTextures(<span class="number">1</span>, &amp;po_tbo);</span><br><span class="line">glBindTexture(GL_TEXTURE_BUFFER, po_tbo);</span><br><span class="line">glTexBuffer(GL_TEXTURE_BUFFER, GL_RGBA32F, po_buffer);</span><br><span class="line"></span><br><span class="line">glGenTextures(<span class="number">1</span>, &amp;po_tbo1);</span><br><span class="line">glBindTexture(GL_TEXTURE_BUFFER, po_tbo1);</span><br><span class="line">glTexBuffer(GL_TEXTURE_BUFFER, GL_RGBA32F, po_buffer1);</span><br></pre></td></tr></table></figure>
<p>先使用计算着色器，绑定tbo和id，GL_READ_WRITE设置读写权限（如果计算着色器规定了这里可以就设置读写,opengl因为读写可以在一个buffer进行因此一定要设置可读可写）。glDispatchCompute的三个参数设置了全局工作组的大小，三个参数可以理解为xyz方向各有几个本地工作组。glMemoryBarrier是隔断作用，为了保证计算着色器中纹理像素全部写入完成才进行下一步。最后使用渲染着色器进行绘制。如果至使用一次计算着色器的话，可以不用vao，渲染着色器默认使用writeonly的buffer。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">glUseProgram(userData-&gt;compute_prog);</span><br><span class="line">glBindImageTexture(<span class="number">0</span>, po_tbo, <span class="number">0</span>, GL_FALSE, <span class="number">0</span>, GL_READ_WRITE, GL_RGBA32F);</span><br><span class="line">glBindImageTexture(<span class="number">1</span>, po_tbo1, <span class="number">0</span>, GL_FALSE, <span class="number">0</span>, GL_READ_WRITE, GL_RGBA32F);</span><br><span class="line">glDispatchCompute(<span class="number">3</span>, <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">glMemoryBarrier(GL_SHADER_IMAGE_ACCESS_BARRIER_BIT);</span><br><span class="line">vao(po_tbo1配置数据与tbo1绑定)</span><br></pre></td></tr></table></figure>
<p>如果要进行类似transformfeedback的操作，进行累加变换，需要交换读写tbo。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(flag)&#123;</span><br><span class="line">glBindImageTexture(<span class="number">0</span>, po_tbo, <span class="number">0</span>, GL_FALSE, <span class="number">0</span>, GL_READ_WRITE, GL_RGBA32F);</span><br><span class="line">glBindImageTexture(<span class="number">1</span>, po_tbo1, <span class="number">0</span>, GL_FALSE, <span class="number">0</span>, GL_READ_WRITE, GL_RGBA32F);</span><br><span class="line">vao(po_tbo配置数据与tbo绑定)</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">glBindImageTexture(<span class="number">1</span>, po_tbo, <span class="number">0</span>, GL_FALSE, <span class="number">0</span>, GL_READ_WRITE, GL_RGBA32F);</span><br><span class="line">glBindImageTexture(<span class="number">0</span>, po_tbo1, <span class="number">0</span>, GL_FALSE, <span class="number">0</span>, GL_READ_WRITE, GL_RGBA32F);</span><br><span class="line">vao1(po_tbo1配置数据与tbo1绑定)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
    </footer>
  </div>

    
 
   
</article>

    
  </article>
  

  
  <nav class="page-nav">
    
    <a class="extend prev" rel="prev" href="/">上一页</a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="page-number" href="/page/4/">4</a><span class="space">&hellip;</span><a class="page-number" href="/page/6/">6</a><a class="extend next" rel="next" href="/page/3/">下一页</a>
  </nav>
  
</section>
</div>

      <footer class="footer">
  <div class="outer">
    <ul>
      <li>
        Copyrights &copy;
        2020-2023
        <i class="ri-heart-fill heart_icon"></i> John Doe
      </li>
    </ul>
    <ul>
      <li>
        
        
        
        Powered by <a href="https://hexo.io" target="_blank">Hexo</a>
        <span class="division">|</span>
        Theme - <a href="https://github.com/Shen-Yu/hexo-theme-ayer" target="_blank">Ayer</a>
        
      </li>
    </ul>
    <ul>
      <li>
        
        
        <span>
  <span><i class="ri-user-3-fill"></i>Visitors:<span id="busuanzi_value_site_uv"></span></s>
  <span class="division">|</span>
  <span><i class="ri-eye-fill"></i>Views:<span id="busuanzi_value_page_pv"></span></span>
</span>
        
      </li>
    </ul>
    <ul>
      
        <li>
          <a href="http://www.beian.miit.gov.cn/" target="_black">赣ICP备2021001676号</a>
        </li>
        
    </ul>
    <ul>
      <li>
        <!-- cnzz统计 -->
        
        <script type="text/javascript" src='https://s9.cnzz.com/z_stat.php?id=1278069914&amp;web_id=1278069914'></script>
        
      </li>
    </ul>
  </div>
</footer>
      <div class="float_btns">
        <div class="totop" id="totop">
  <i class="ri-arrow-up-line"></i>
</div>

<div class="todark" id="todark">
  <i class="ri-moon-line"></i>
</div>

      </div>
    </main>
    <aside class="sidebar on">
      <button class="navbar-toggle"></button>
<nav class="navbar">
  
  <div class="logo">
    <a href="/"><img src="/images/ayer-side.svg" alt="Hexo"></a>
  </div>
  
  <ul class="nav nav-main">
    
    <li class="nav-item">
      <a class="nav-item-link" href="/">主页</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/archives">归档</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/categories">分类</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/tags">标签</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/friend">友链</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/journal">日志</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/2019/about">关于我</a>
    </li>
    
  </ul>
</nav>
<nav class="navbar navbar-bottom">
  <ul class="nav">
    <li class="nav-item">
      
      <a class="nav-item-link nav-item-search"  title="Search">
        <i class="ri-search-line"></i>
      </a>
      
      
      <a class="nav-item-link" target="_blank" href="/atom.xml" title="RSS Feed">
        <i class="ri-rss-line"></i>
      </a>
      
    </li>
  </ul>
</nav>
<div class="search-form-wrap">
  <div class="local-search local-search-plugin">
  <input type="search" id="local-search-input" class="local-search-input" placeholder="Search...">
  <div id="local-search-result" class="local-search-result"></div>
</div>
</div>
    </aside>
    <script>
      if (window.matchMedia("(max-width: 768px)").matches) {
        document.querySelector('.content').classList.remove('on');
        document.querySelector('.sidebar').classList.remove('on');
      }
    </script>
    <div id="mask"></div>

<!-- #reward -->
<div id="reward">
  <span class="close"><i class="ri-close-line"></i></span>
  <p class="reward-p"><i class="ri-cup-line"></i>请我喝杯咖啡吧~</p>
  <div class="reward-box">
    
    <div class="reward-item">
      <img class="reward-img" src="https://cdn.jsdelivr.net/gh/Shen-Yu/cdn/img/alipay.jpg">
      <span class="reward-type">支付宝</span>
    </div>
    
    
    <div class="reward-item">
      <img class="reward-img" src="https://cdn.jsdelivr.net/gh/Shen-Yu/cdn/img/wechat.jpg">
      <span class="reward-type">微信</span>
    </div>
    
  </div>
</div>
    
<script src="/js/jquery-2.0.3.min.js"></script>


<script src="/js/lazyload.min.js"></script>

<!-- Tocbot -->

<script src="https://cdn.jsdelivr.net/npm/jquery-modal@0.9.2/jquery.modal.min.js"></script>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/jquery-modal@0.9.2/jquery.modal.min.css">
<script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/js/jquery.justifiedGallery.min.js"></script>

<script src="/dist/main.js"></script>

<!-- ImageViewer -->

<!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                <!--  Controls are self-explanatory. Order can be changed. -->

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" style="display:none" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                        <div class="pswp__preloader__cut">
                            <div class="pswp__preloader__donut"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div>

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.css">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.min.css">
<script src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js"></script>

<script>
    function viewer_init() {
        let pswpElement = document.querySelectorAll('.pswp')[0];
        let $imgArr = document.querySelectorAll(('.article-entry img:not(.reward-img)'))

        $imgArr.forEach(($em, i) => {
            $em.onclick = () => {
                // slider展开状态
                // todo: 这样不好，后面改成状态
                if (document.querySelector('.left-col.show')) return
                let items = []
                $imgArr.forEach(($em2, i2) => {
                    let img = $em2.getAttribute('data-idx', i2)
                    let src = $em2.getAttribute('data-target') || $em2.getAttribute('src')
                    let title = $em2.getAttribute('alt')
                    // 获得原图尺寸
                    const image = new Image()
                    image.src = src
                    items.push({
                        src: src,
                        w: image.width || $em2.width,
                        h: image.height || $em2.height,
                        title: title
                    })
                })
                var gallery = new PhotoSwipe(pswpElement, PhotoSwipeUI_Default, items, {
                    index: parseInt(i)
                });
                gallery.init()
            }
        })
    }
    viewer_init()
</script>

<!-- MathJax -->

<!-- Katex -->

<!-- busuanzi  -->


<script src="/js/busuanzi-2.3.pure.min.js"></script>


<!-- ClickLove -->

<!-- ClickBoom1 -->

<script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script>

<script src="/js/clickBoom1.js"></script>


<!-- ClickBoom2 -->

<!-- CodeCopy -->


<link rel="stylesheet" href="/css/clipboard.css">

<script src="https://cdn.jsdelivr.net/npm/clipboard@2/dist/clipboard.min.js"></script>
<script>
  function wait(callback, seconds) {
    var timelag = null;
    timelag = window.setTimeout(callback, seconds);
  }
  !function (e, t, a) {
    var initCopyCode = function(){
      var copyHtml = '';
      copyHtml += '<button class="btn-copy" data-clipboard-snippet="">';
      copyHtml += '<i class="ri-file-copy-2-line"></i><span>COPY</span>';
      copyHtml += '</button>';
      $(".highlight .code pre").before(copyHtml);
      $(".article pre code").before(copyHtml);
      var clipboard = new ClipboardJS('.btn-copy', {
        target: function(trigger) {
          return trigger.nextElementSibling;
        }
      });
      clipboard.on('success', function(e) {
        let $btn = $(e.trigger);
        $btn.addClass('copied');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-checkbox-circle-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPIED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-checkbox-circle-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
      clipboard.on('error', function(e) {
        e.clearSelection();
        let $btn = $(e.trigger);
        $btn.addClass('copy-failed');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-time-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPY FAILED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-time-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
    }
    initCopyCode();
  }(window, document);
</script>


<!-- CanvasBackground -->


<script src="/js/dz.js"></script>



    
    <div id="music">
    
    
    
    <iframe frameborder="no" border="1" marginwidth="0" marginheight="0" width="200" height="52"
        src="//music.163.com/outchain/player?type=2&id=1441758494&auto=1&height=32"></iframe>
</div>

<style>
    #music {
        position: fixed;
        right: 15px;
        bottom: 0;
        z-index: 998;
    }
</style>
    
  </div>
</body>

</html>
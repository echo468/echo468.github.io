<!DOCTYPE html>


<html lang="en">


<head>
  <meta charset="utf-8" />
    
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />
  <title>
     Hexo
  </title>
  <meta name="generator" content="hexo-theme-ayer">
  
  <link rel="shortcut icon" href="/favicon.ico" />
  
  
<link rel="stylesheet" href="/dist/main.css">

  
<link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Shen-Yu/cdn/css/remixicon.min.css">

  
<link rel="stylesheet" href="/css/custom.css">

  
  
<script src="https://cdn.jsdelivr.net/npm/pace-js@1.0.2/pace.min.js"></script>

  
  

  

</head>

</html>

<body>
  <div id="app">
    
      <canvas class="fireworks"></canvas>
      <style>
        .fireworks {
          position: fixed;
          left: 0;
          top: 0;
          z-index: 99999;
          pointer-events: none;
        }
      </style>
      
      
    <main class="content on">
      
<section class="cover">
    
      
      <a class="forkMe" href="https://github.com/Shen-Yu/hexo-theme-ayer"
        target="_blank"><img width="149" height="149" src="/images/forkme.png"
          class="attachment-full size-full" alt="Fork me on GitHub" data-recalc-dims="1"></a>
    
  <div class="cover-frame">
    <div class="bg-box">
      <img src="/images/cover1.jpg" alt="image frame" />
    </div>
    <div class="cover-inner text-center text-white">
      <h1><a href="/">Hexo</a></h1>
      <div id="subtitle-box">
        
        <span id="subtitle"></span>
        
      </div>
      <div>
        
        <img
          src="/images/ayer.svg"
          class="cover-logo"
          alt="Hexo"
        />
        
      </div>
    </div>
  </div>
  <div class="cover-learn-more">
    <a href="javascript:void(0)" class="anchor"><i class="ri-arrow-down-line"></i></a>
  </div>
</section>



<script src="https://cdn.jsdelivr.net/npm/typed.js@2.0.11/lib/typed.min.js"></script>


<!-- Subtitle -->

  <script>
    try {
      var typed = new Typed("#subtitle", {
        strings: ['keep learning!!!!', '', ''],
        startDelay: 0,
        typeSpeed: 200,
        loop: true,
        backSpeed: 100,
        showCursor: true
      });
    } catch (err) {
      console.log(err)
    }
  </script>
  
<div id="main">
  <section class="outer">
  <article class="articles">
    
    
    
    
    <article
  id="post-X11窗口绘制"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2023/04/03/X11%E7%AA%97%E5%8F%A3%E7%BB%98%E5%88%B6/"
    >X11窗口绘制</a> 
</h2>
 

    </header>
     
    <div class="article-meta">
      <a href="/2023/04/03/X11%E7%AA%97%E5%8F%A3%E7%BB%98%E5%88%B6/" class="article-date">
  <time datetime="2023-04-03T02:08:23.000Z" itemprop="datePublished">2023-04-03</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E5%AE%9E%E4%B9%A0/">实习</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <p>1、在linux中，“X11”指的是“X Window System”，是图形化窗口管理系统。因此调用X11使得窗口可以在linux上运行，不能在windows上运行。</p>
<p>2、glut跨平台窗口库；glfw跨平台窗口库（glut替代版）；glut和glfw封装了Window的窗口管理系统，linux的窗口管理系统和egl。</p>
<p>3、egl用于关联原生窗口，创建上下文，通过eglBindAPI指定使用gl还是es，与平台无关(窗口-egl-API)。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">eglBindAPI(EGL_OPENGL_ES_API);//绑定ES的API</span><br><span class="line">eglBindAPI(EGL_OPENGL_API);//绑定GL的API</span><br></pre></td></tr></table></figure>

<p>4、使用API时，gl.h头文件中只有函数声明，需要链接到函数实现，glfw已经封装了函数链接，如果直接用X11创建窗口需要在Makefile手动链接。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LD_LIBS=-lX11 -lXext -lEGL -lGL //链接GL</span><br></pre></td></tr></table></figure>

<p>​	  GL&#x2F;gl.h是基本的OpenGL标头，可提供OpenGL-1.1函数和令牌声明，甚至更多。对于超过1.1版的任何内容，都必须使用OpenGL扩展机制。由于这是一项枯燥而乏味的任务，因此GLEW项目已将其自动化，该项目将所有细节打包在一个易于使用的库中。该库的声明位于头文件GL&#x2F;glew.h中，该文件隐含了常规的OpenGL标头，因此在包含GL&#x2F;glew.h时，不再需要包含GL&#x2F;gl.h。</p>
<p>5、X11窗口创建的部分函数和窗口监听</p>
<p>​		创建窗口前先打开与server 的连接。在程序可以使用display 之前，必须先建立一个和X server 的连接。这个连接建立以后，就可以使用Xlib 的函数或宏定义来获得display 的信息了。当参数设置为NULL时，为默认的display环境变量。这个函数返回一个指向display类型结构的指针，表明与X server建立了连接，并且包含了X server的所有信息，可以使用display之上所有窗口。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Display *display = XOpenDisplay(NULL);</span><br></pre></td></tr></table></figure>

<p>​		在进行了一些配置参数配置后，使用如下两个函数创建窗口（参数含义以及创建窗口前的配置流程暂时未知）。函数返回创建的窗口的ID，并使得X server产生一个CreateNotify 事件。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">XCreateWindow</span><br><span class="line">XCreateSimpleWindow</span><br></pre></td></tr></table></figure>

<p>​		X是一个服务器–客户端的结构。由服务器向客户端发送事件信息，让客户端知道发生了什么事情，然后客户端告诉服务器它感兴趣的是什么事情，也就是说，客户端会对那些事件产生反应。如下函数用于客户端告诉服务器窗口会对哪些事情有响应。StructureNotifyMask 即改变窗口状态，比如尺寸，位置等，对应事件ConfigureNotify；ExposureMask 对应事件Expose ；KeyPressMask 即键盘响应对应事件KeyPress。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">XSelectInput(display, win,ExposureMask|StructureNotifyMask);</span><br></pre></td></tr></table></figure>

<p>​		创建窗口之后，窗口并不能显示出来，需要调用如下函数来 画窗口让它显示。如果这个窗口有父窗口，那么在所有父窗口没有画出来之前，这个窗口即使用了这个函数，也是不能显示出来的。必须等所有父窗口都显示了，这个窗口才能画。X server产生一个MapNotify事件。客户端已经有相应操作了，绘制窗口。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">XStoreName (display, win, &quot;gears&quot;);//设置窗口名</span><br><span class="line">XMapWindow(display, win);</span><br></pre></td></tr></table></figure>

<p>​		进入窗口事件循环，获得事件，处理或丢弃。接收到的事件由XNextEvent 函数从消息队列里获得，把事件放到event.type 里并从队列里删除该消息 。当队列为空也就是没有下一个事件被接收时，程序就一直停留在XNextEvent里直到有下一个事件，因此可以使用XPending(display)在有事件的时候响应事件，没有事件的时候在窗口上绘制。如果窗口的信息改变了，就需要XFlush 函数让窗口重画，但XNextEvent函数会隐式地调用XFlush。在opengl绘制函数的部分，glClearColor设置窗口颜色后，需要用</p>
<p>glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);</p>
<p>清空颜色缓存和深度缓存，再利用函数</p>
<p>eglSwapBuffers(mContext.eglDisplay, mContext.eglSurface);才能显示在窗口。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">XEvent myevent;</span><br><span class="line">while (1) &#123;       </span><br><span class="line">      if (XPending(display)) &#123;</span><br><span class="line">       XNextEvent(display, &amp;myevent);</span><br><span class="line">       switch(myevent.type) &#123;</span><br><span class="line">       case ClientMessage:&#123;</span><br><span class="line">       &#125;</span><br><span class="line">       case ConfigureNotify:&#123;</span><br><span class="line">       &#125;&#125;&#125;</span><br><span class="line">     /*opengl绘制函数*/</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>​		关闭窗口事件（若窗口关闭则打印信息）</p>
<pre><code>//while循环外
Atom deleteAtom = XInternAtom(display, &quot;WM_DELETE_WINDOW&quot;, False);
XSetWMProtocols(display, win, &amp;deleteAtom, 1);
//while循环内
 case ClientMessage:&#123;
       if ((unsigned)myevent.xclient.data.l[0] == deleteAtom)&#123;
           printf(&quot;X WINDOW DELETED\n&quot;);
           return 0;
       &#125;
   &#125;
</code></pre>
<p>​		窗口改变事件</p>
<p>​		如下函数通过代码人为改变并重新设置窗口，因此一直存在ConfigureNotify事件。</p>
<pre><code>const unsigned int mask = CWWidth | CWHeight;
XWindowChanges changes;
int newWidth = 128, newHeight = 128;
changes.width = newWidth;
changes.height = newHeight;
XConfigureWindow(display, win, mask, &amp;changes);
</code></pre>
<p>​    	如下函数获取由外部事件对窗口产生的变化并改变viewport，使得绘制的图像根据窗口的变化变化。</p>
<pre><code>case ConfigureNotify:&#123;
    reshape(myevent.xconfigure.width,myevent.xconfigure.height); 
    break;
&#125;
</code></pre>
<p>​	  Expose 事件可能用于绘制和显示，在opengl绘制部分外部可以添加case Expose 。</p>
<p>​	  退出窗口时，需要关闭和X server 的连接，于是也就销毁了相关资源，关闭了窗口。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">XDestroyWindow(display, win);</span><br><span class="line">XCloseDisplay(display)；</span><br></pre></td></tr></table></figure>

<p>参考链接：</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/rufanchen_/article/details/7640584">https://blog.csdn.net/rufanchen_&#x2F;article&#x2F;details&#x2F;7640584</a></p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/okgogo2000/p/4322753.html">https://www.cnblogs.com/okgogo2000/p/4322753.html</a></p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
    </footer>
  </div>

    
 
   
</article>

    
    <article
  id="post-计算着色器"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2023/03/14/%E8%AE%A1%E7%AE%97%E7%9D%80%E8%89%B2%E5%99%A8/"
    >计算着色器</a> 
</h2>
 

    </header>
     
    <div class="article-meta">
      <a href="/2023/03/14/%E8%AE%A1%E7%AE%97%E7%9D%80%E8%89%B2%E5%99%A8/" class="article-date">
  <time datetime="2023-03-14T01:35:48.000Z" itemprop="datePublished">2023-03-14</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E5%AE%9E%E4%B9%A0/">实习</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <p>计算着色器是在GPU上运行的，是在普通渲染管线之外的着色器程序。计算着色器是完全用于计算任意信息的着色器阶段。虽然它可以进行渲染，但它通常用于与绘制三角形和像素没有直接关系的任务。利用GUP的快速计算和并行性，可以用于处理大量的计算。</p>
<p>opengl4.3才开始支持计算着色器，opengl es是3.1才开始支持计算着色器。</p>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#version 320 es</span></span><br><span class="line"><span class="keyword">layout</span> (<span class="keyword">local_size_x</span> = <span class="number">1</span>) <span class="keyword">in</span>; </span><br><span class="line"><span class="keyword">layout</span> (<span class="keyword">rgba32f</span>, <span class="keyword">binding</span> = <span class="number">0</span>) <span class="keyword">uniform</span> <span class="keyword">readonly</span> <span class="keyword">mediump</span> <span class="type">imageBuffer</span> po_buffer;</span><br><span class="line"><span class="keyword">layout</span> (<span class="keyword">rgba32f</span>, <span class="keyword">binding</span> = <span class="number">1</span>) <span class="keyword">uniform</span> <span class="keyword">writeonly</span> <span class="keyword">mediump</span> <span class="type">imageBuffer</span> po_buffer1;</span><br><span class="line"><span class="type">void</span> main()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//此处全局工作组和本地工作组yz均为1，因此可以通过x确定位置</span></span><br><span class="line">    <span class="type">int</span> pos = <span class="type">int</span>(<span class="built_in">gl_GlobalInvocationID</span>.x);</span><br><span class="line">    <span class="type">vec4</span> value = <span class="built_in">imageLoad</span>(po_buffer, pos);</span><br><span class="line">    value.x = value.x+<span class="number">0.4</span>;</span><br><span class="line">    value.y = value.y+<span class="number">0.4</span>;</span><br><span class="line">    <span class="built_in">imageStore</span>(po_buffer1, pos, value); </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>binding与之后glBindImageTexture的第一个参数相同，通过ID绑定对应的tbo，而tbo绑定对应的buffer。相当于通过绑定知道从哪个buffer读取数据，从哪个buffer写入数据。因为此处是读取buffer所以使用imageBuffer，如果是数组的话可能使用image2D。es需要指定精度，所以添加mediump。同时因为需要读取的是rgba而不是r（如果只设置r，value就无法读取y值），所以需要指定readonly和writeonly。但是在opengl4.3中不需要指定精度，并且读写可以在一个buffer中进行。</p>
<p>imageLoad从buffer的指定位置读取数据，imageStore将值写入buffer的指定位置。</p>
<p>计算着色器任务以组为单位进行执行，称为工作组。拥有邻居的工作组被称为本地工作组（局部）, 这些组可以组成更大的组，称为全局工作组，而全局工作组通常作为执行命令的一个单位。计算着色器会被全局工作组中每一个本地工作组中的每一个单元调用一次，工作组的每一个单元称为工作项，每一次调用称为一次执行。执行的单元之间可以u通过变量和显存进行通信（不同工作组不能通信），且可执行同步操作保持一致性（单个工作组内可以并行）。</p>
<p>如下例子假设全局工作组yz轴都为1 ，局部工作组只有xy：</p>
<p>gl_LocalInvocationID.x × local_size_y+gl_LocalInvocationID.y+local_size_x×local_size_y×gl_WorkGroupID.x&#x3D;gl_GlobalInvocationID.x×local_size_y×y轴的工作组个数+gl_GlobalInvocationID.y</p>
<p>local_size是本地工作组的大小，有xyz三个维度，不设置默认为1。gl_WorkGroupID本地工作组在全局工作组的索引（从0开始），local_size_x×local_size_y本地工作组的大小（该大小尽量与硬件匹配），gl_LocalInvocationID工作项在本地工作组的坐标（从0开始）。gl_GlobalInvocationID：在全局工作组中，当前工作项所在位置。（在es中imageLoad后的pos只能使用int，所以可以设置本地工作组和全局工作组yz均为1，这样可以只使用gl_GlobalInvocationID.x就可以遍历到所有数据，否则可以通过上述公式计算。）本地工作组的大小×全局工作组的大小-&gt;所有需要遍历的数据</p>
<p>与普通着色器一样正常链接</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">computeShader = LoadShader(GL_COMPUTE_SHADER, cShaderStr);</span><br><span class="line">compute_prog = glCreateProgram();</span><br><span class="line"><span class="keyword">if</span> (compute_prog == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">glAttachShader(compute_prog, computeShader);</span><br><span class="line">glLinkProgram(compute_prog);</span><br></pre></td></tr></table></figure>
<p> 将顶点数据arraybuffer与texbuffer绑定</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">glGenBuffers(<span class="number">1</span>, &amp;po_buffer);</span><br><span class="line">glBindBuffer(GL_ARRAY_BUFFER, po_buffer);</span><br><span class="line">glBufferData(GL_ARRAY_BUFFER, <span class="keyword">sizeof</span>(vVertices), vVertices, GL_DYNAMIC_COPY);</span><br><span class="line"></span><br><span class="line">glGenBuffers(<span class="number">1</span>, &amp;po_buffer1);</span><br><span class="line">glBindBuffer(GL_ARRAY_BUFFER, po_buffer1);</span><br><span class="line">glBufferData(GL_ARRAY_BUFFER, <span class="keyword">sizeof</span>(vVertices),vVertices, GL_DYNAMIC_COPY);</span><br><span class="line"></span><br><span class="line">glGenTextures(<span class="number">1</span>, &amp;po_tbo);</span><br><span class="line">glBindTexture(GL_TEXTURE_BUFFER, po_tbo);</span><br><span class="line">glTexBuffer(GL_TEXTURE_BUFFER, GL_RGBA32F, po_buffer);</span><br><span class="line"></span><br><span class="line">glGenTextures(<span class="number">1</span>, &amp;po_tbo1);</span><br><span class="line">glBindTexture(GL_TEXTURE_BUFFER, po_tbo1);</span><br><span class="line">glTexBuffer(GL_TEXTURE_BUFFER, GL_RGBA32F, po_buffer1);</span><br></pre></td></tr></table></figure>
<p>先使用计算着色器，绑定tbo和id，GL_READ_WRITE设置读写权限（如果计算着色器规定了这里可以就设置读写,opengl因为读写可以在一个buffer进行因此一定要设置可读可写）。glDispatchCompute的三个参数设置了全局工作组的大小，三个参数可以理解为xyz方向各有几个本地工作组。glMemoryBarrier是隔断作用，为了保证计算着色器中纹理像素全部写入完成才进行下一步。最后使用渲染着色器进行绘制。如果至使用一次计算着色器的话，可以不用vao，渲染着色器默认使用writeonly的buffer。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">glUseProgram(userData-&gt;compute_prog);</span><br><span class="line">glBindImageTexture(<span class="number">0</span>, po_tbo, <span class="number">0</span>, GL_FALSE, <span class="number">0</span>, GL_READ_WRITE, GL_RGBA32F);</span><br><span class="line">glBindImageTexture(<span class="number">1</span>, po_tbo1, <span class="number">0</span>, GL_FALSE, <span class="number">0</span>, GL_READ_WRITE, GL_RGBA32F);</span><br><span class="line">glDispatchCompute(<span class="number">3</span>, <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">glMemoryBarrier(GL_SHADER_IMAGE_ACCESS_BARRIER_BIT);</span><br><span class="line">vao(po_tbo1配置数据与tbo1绑定)</span><br></pre></td></tr></table></figure>
<p>如果要进行类似transformfeedback的操作，进行累加变换，需要交换读写tbo。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(flag)&#123;</span><br><span class="line">glBindImageTexture(<span class="number">0</span>, po_tbo, <span class="number">0</span>, GL_FALSE, <span class="number">0</span>, GL_READ_WRITE, GL_RGBA32F);</span><br><span class="line">glBindImageTexture(<span class="number">1</span>, po_tbo1, <span class="number">0</span>, GL_FALSE, <span class="number">0</span>, GL_READ_WRITE, GL_RGBA32F);</span><br><span class="line">vao(po_tbo配置数据与tbo绑定)</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">glBindImageTexture(<span class="number">1</span>, po_tbo, <span class="number">0</span>, GL_FALSE, <span class="number">0</span>, GL_READ_WRITE, GL_RGBA32F);</span><br><span class="line">glBindImageTexture(<span class="number">0</span>, po_tbo1, <span class="number">0</span>, GL_FALSE, <span class="number">0</span>, GL_READ_WRITE, GL_RGBA32F);</span><br><span class="line">vao1(po_tbo1配置数据与tbo1绑定)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
    </footer>
  </div>

    
 
   
</article>

    
    <article
  id="post-webgl基础"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2023/02/07/webgl%E5%9F%BA%E7%A1%80/"
    >webgl基础</a> 
</h2>
 

    </header>
     
    <div class="article-meta">
      <a href="/2023/02/07/webgl%E5%9F%BA%E7%A1%80/" class="article-date">
  <time datetime="2023-02-07T13:36:35.000Z" itemprop="datePublished">2023-02-07</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/Webgl/">Webgl</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <p>1.导入相关文件</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;../lib/webgl-utils.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;../lib/webgl-debug.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;../lib/cuon-utils.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>2.在html<body>元素中创建Canvas画布，并且对其css进行相关设置。该画布具有2D绘图和3D绘图的功能。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">canvas</span> <span class="attr">id</span>=<span class="string">&quot;webgl&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">canvas</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>3.通过JavaScript获取上面创建的Canvas元素返回一个Canvas对象。Canvas对象也可以不通过<canvas>标签创建，然后id方式获取，也可以通过DOM直接创建。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取</span></span><br><span class="line"><span class="keyword">var</span> canvas= <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;webgl&#x27;</span>)</span><br><span class="line"><span class="comment">//直接创建后添加</span></span><br><span class="line"><span class="keyword">var</span> canvas = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;canvas&#x27;</span>);</span><br><span class="line"><span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">appendChild</span>(canvas);</span><br></pre></td></tr></table></figure>

<p>4.获取Canvas上下文，执行<code>canvas.getContext(&#39;2d&#39;)</code>返回对象具有一系列绘制二维图形的方法，比如绘制直线、圆弧等API。执行<code>canvas.getContext(&#39;webgl&#39;);</code>返回对象具有一系列绘制渲染三维场景的方法，也就是WebGL API。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> c =canvas.<span class="title function_">getContext</span>(<span class="string">&#x27;2d&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> gl=canvas.<span class="title function_">getContext</span>(<span class="string">&#x27;webgl&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p>5.编写着色器文件</p>
<p>可以直接将着色器文件写成字符串</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> vertexShaderSource = <span class="string">&#x27;&#x27;</span> +    </span><br><span class="line">    <span class="string">&#x27;void main()&#123;&#x27;</span> + </span><br><span class="line">    <span class="string">&#x27;   gl_PointSize=20.0;&#x27;</span> +   </span><br><span class="line">    <span class="string">&#x27;   gl_Position =vec4(0.0,0.0,0.0,1.0);&#x27;</span> +    </span><br><span class="line">    <span class="string">&#x27;&#125;&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>或者将着色器文件写在<script>标签中并通过innerText获取，获取到的对象为字符串</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;script id=<span class="string">&quot;vertexShader&quot;</span> type=<span class="string">&quot;x-shader/x-vertex&quot;</span>&gt;</span><br><span class="line"><span class="keyword">var</span> vertexShaderSource = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;vertexShader&#x27;</span>).<span class="property">innerText</span>;</span><br></pre></td></tr></table></figure>

<p>6.初始化着色器</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> program = <span class="title function_">initShader</span>(gl,vertex,frag);</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">initShader</span>(<span class="params">gl,vertexShaderSource,fragmentShaderSource</span>)&#123;</span><br><span class="line"><span class="comment">//创建着色器对象</span></span><br><span class="line"><span class="keyword">var</span> vertexShader = gl.<span class="title function_">createShader</span>(gl.<span class="property">VERTEX_SHADER</span>);</span><br><span class="line"><span class="keyword">var</span> fragmentShader = gl.<span class="title function_">createShader</span>(gl.<span class="property">FRAGMENT_SHADER</span>);</span><br><span class="line"><span class="comment">//引入源代码</span></span><br><span class="line">gl.<span class="title function_">shaderSource</span>(vertexShader,vertexShaderSource); </span><br><span class="line">gl.<span class="title function_">shaderSource</span>(fragmentShader,fragmentShaderSource);</span><br><span class="line"><span class="comment">//编译着色器</span></span><br><span class="line">gl.<span class="title function_">compileShader</span>(vertexShader);</span><br><span class="line">gl.<span class="title function_">compileShader</span>(fragmentShader);</span><br><span class="line"><span class="comment">//创建着色器对象</span></span><br><span class="line"><span class="keyword">var</span> program = gl.<span class="title function_">createProgram</span>();</span><br><span class="line"><span class="comment">//附着着色器到program</span></span><br><span class="line">gl.<span class="title function_">attachShader</span>(program,vertexShader);</span><br><span class="line">gl.<span class="title function_">attachShader</span>(program,fragmentShader);</span><br><span class="line"><span class="comment">//链接program</span></span><br><span class="line">gl.<span class="title function_">linkProgram</span>(program);</span><br><span class="line"><span class="comment">//使用program</span></span><br><span class="line">gl.<span class="title function_">useProgram</span>(program);</span><br><span class="line"><span class="keyword">return</span> program;</span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>

<p>7.正常调用webgl函数，以绘制正方形为例</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在着色器中的位置设置，与顶点着色器中的attribute同名</span></span><br><span class="line"><span class="keyword">var</span> apos = gl.<span class="title function_">getAttribLocation</span>(program,<span class="string">&#x27;apos&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//类型数组构造函数Float32Array创建顶点数组（-1~1之间）</span></span><br><span class="line"><span class="keyword">var</span> data = <span class="keyword">new</span> <span class="title class_">Float32Array</span>([<span class="number">0.5</span>,<span class="number">0.5</span>,-<span class="number">0.5</span>,<span class="number">0.5</span>,-<span class="number">0.5</span>,-<span class="number">0.5</span>,<span class="number">0.5</span>,-<span class="number">0.5</span>]);</span><br><span class="line"></span><br><span class="line"><span class="comment">//缓冲区设置</span></span><br><span class="line"><span class="keyword">var</span> buffer=gl.<span class="title function_">createBuffer</span>();</span><br><span class="line">gl.<span class="title function_">bindBuffer</span>(gl.<span class="property">ARRAY_BUFFER</span>,buffer);</span><br><span class="line">gl.<span class="title function_">bufferData</span>(gl.<span class="property">ARRAY_BUFFER</span>,data,gl.<span class="property">STATIC_DRAW</span>);</span><br><span class="line">gl.<span class="title function_">vertexAttribPointer</span>(apos,<span class="number">2</span>,gl.<span class="property">FLOAT</span>,<span class="literal">false</span>,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">gl.<span class="title function_">enableVertexAttribArray</span>(apos);</span><br><span class="line"></span><br><span class="line"><span class="comment">//开始绘制</span></span><br><span class="line">gl.<span class="title function_">drawArrays</span>(gl.<span class="property">LINE_LOOP</span>,<span class="number">0</span>,<span class="number">4</span>);</span><br></pre></td></tr></table></figure>

 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
    </footer>
  </div>

    
 
   
</article>

    
    <article
  id="post-层级模型"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2023/02/05/%E5%B1%82%E7%BA%A7%E6%A8%A1%E5%9E%8B/"
    >层级模型</a> 
</h2>
 

    </header>
     
    <div class="article-meta">
      <a href="/2023/02/05/%E5%B1%82%E7%BA%A7%E6%A8%A1%E5%9E%8B/" class="article-date">
  <time datetime="2023-02-05T15:44:24.000Z" itemprop="datePublished">2023-02-05</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/three-js/">three.js</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h4 id="使用层级模型"><a href="#使用层级模型" class="headerlink" title="使用层级模型"></a>使用层级模型</h4><p>创建两个网格模型mesh1、mesh2，通过<code>THREE.Group</code>类创建一个组对象group,然后通过<code>add</code>方法把网格模型mesh1、mesh2作为设置为组对象group的子对象，然后在通过执行<code>scene.add(group)</code>把组对象group作为场景对象的scene的子对象。也就是说场景对象是scene是group的父对象，group是mesh1、mesh2的父对象，这样就构成了一个三层的层级结构。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> group = <span class="keyword">new</span> <span class="variable constant_">THREE</span>.<span class="title class_">Group</span>();</span><br><span class="line">group.<span class="title function_">add</span>(mesh1);</span><br><span class="line">group.<span class="title function_">add</span>(mesh2);</span><br><span class="line">scene.<span class="title function_">add</span>(group);<span class="comment">//.add()方法都是继承自它们共同的基类(父类)Object3D</span></span><br><span class="line"><span class="comment">//等价于group.add(mesh1,mesh2);</span></span><br></pre></td></tr></table></figure>

<p>Three.js场景对象<code>Scene</code>、组对象<code>Group</code>都有一个子对象属性<code>.children</code>,通过该属性可以访问父对象的子对象，子对象属性<code>.children</code>的值是数组，所有子对象是数组的值。场景对象<code>Scene</code>的子对象，除了组对象<code>Group</code>之外，还可以看到环境光<code>AmbientLight</code>、平行光<code>DirectionalLight</code>、辅助坐标对象<code>AxesHelper</code>等。场景对象<code>Scene</code>构成的层级模型本身是一个树结构，场景对象层级模型的第一层，也就是树结构的根节点，一般来说网格模型Mesh、点模型Points、线模型Line是树结构的最外层叶子结点。构建层级模型的中间层一般都是通过Three.js的<code>Group</code>类来完成，<code>Group</code>类实例化的对象可以称为组对象。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;查看group的子对象&#x27;</span>,group.<span class="property">children</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;查看Scene的子对象&#x27;</span>,scene.<span class="property">children</span>);</span><br></pre></td></tr></table></figure>

<p>网格模型mesh1、mesh2作为设置为父对象group的子对象，如果父对象group进行旋转、缩放、平移变换，子对象同样跟着变换。使用层级模型可以操作一组对象。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//沿着Y轴平移mesh1和mesh2的父对象，mesh1和mesh2跟着平移</span></span><br><span class="line">group.<span class="title function_">translateY</span>(<span class="number">100</span>);</span><br><span class="line"><span class="comment">//父对象缩放，子对象跟着缩放</span></span><br><span class="line">group.<span class="property">scale</span>.<span class="title function_">set</span>(<span class="number">4</span>,<span class="number">4</span>,<span class="number">4</span>);</span><br><span class="line"><span class="comment">//父对象旋转，子对象跟着旋转</span></span><br><span class="line">group.<span class="title function_">rotateY</span>(<span class="title class_">Math</span>.<span class="property">PI</span>/<span class="number">6</span>)</span><br></pre></td></tr></table></figure>

<p>如下代码等效</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> mesh1 = <span class="keyword">new</span> <span class="variable constant_">THREE</span>.<span class="title class_">Mesh</span>(geometry, material);</span><br><span class="line"><span class="keyword">const</span> mesh2 = <span class="keyword">new</span> <span class="variable constant_">THREE</span>.<span class="title class_">Mesh</span>(geometry, material);</span><br><span class="line"><span class="keyword">const</span> obj = <span class="keyword">new</span> <span class="variable constant_">THREE</span>.<span class="title class_">Object3D</span>();<span class="comment">//作为mesh1和mesh2的父对象</span></span><br><span class="line">obj.<span class="title function_">add</span>(mesh1,mesh2);</span><br></pre></td></tr></table></figure>

<p>Three.js默认mesh也可以添加子对象，mesh基类也是Object3D。如下代码与<code>group.add(mesh1,mesh2);</code>等效。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">group.<span class="title function_">add</span>(mesh1);</span><br><span class="line">mesh1.<span class="title function_">add</span>(mesh2);</span><br></pre></td></tr></table></figure>

<h4 id="遍历模型树结构、查询模型节点"><a href="#遍历模型树结构、查询模型节点" class="headerlink" title="遍历模型树结构、查询模型节点"></a>遍历模型树结构、查询模型节点</h4><p>在层级模型中可以给组或者模型对象通过<code>.name</code>属性命名进行标记。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">group.<span class="property">name</span>=<span class="string">&#x27;小区房子&#x27;</span>;</span><br><span class="line">mesh.<span class="property">name</span>=<span class="string">&#x27;一号楼&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>如下代码将5个mesh作为group1（高层）的子对象，将5个mesh作为group2（洋房）的子对象，将group1和group2作为group3（小区房子）的子对象，一共是4层模型。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> group1 = <span class="keyword">new</span> <span class="variable constant_">THREE</span>.<span class="title class_">Group</span>();</span><br><span class="line">group1.<span class="property">name</span> = <span class="string">&quot;高层&quot;</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">    <span class="comment">/*...*/</span></span><br><span class="line">    group1.<span class="title function_">add</span>(mesh);</span><br><span class="line">    mesh.<span class="property">name</span> = i + <span class="number">1</span> + <span class="string">&#x27;号楼&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line">group1.<span class="property">position</span>.<span class="property">y</span> = <span class="number">30</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> group2 = <span class="keyword">new</span> <span class="variable constant_">THREE</span>.<span class="title class_">Group</span>();</span><br><span class="line">group2.<span class="property">name</span> = <span class="string">&quot;洋房&quot;</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">    <span class="comment">/*...*/</span></span><br><span class="line">    group2.<span class="title function_">add</span>(mesh);</span><br><span class="line">    mesh.<span class="property">name</span> = i + <span class="number">6</span> + <span class="string">&#x27;号楼&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line">group2.<span class="property">position</span>.<span class="property">z</span> = <span class="number">50</span>;</span><br><span class="line">group2.<span class="property">position</span>.<span class="property">y</span> = <span class="number">15</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> model = <span class="keyword">new</span> <span class="variable constant_">THREE</span>.<span class="title class_">Group</span>();</span><br><span class="line">model.<span class="property">name</span>=<span class="string">&#x27;小区房子&#x27;</span>;</span><br><span class="line">model.<span class="title function_">add</span>(group1, group2);</span><br><span class="line">model.<span class="property">position</span>.<span class="title function_">set</span>(-<span class="number">50</span>,<span class="number">0</span>,-<span class="number">25</span>);</span><br></pre></td></tr></table></figure>

<p>Three.js层级模型就是一个树结构，可以通过递归遍历的算法去遍历Three.js一个模型对象包含的所有后代。obj.name包括mesh的name和group的name。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 递归遍历model包含所有的模型节点</span></span><br><span class="line">model.<span class="title function_">traverse</span>(<span class="keyword">function</span>(<span class="params">obj</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;所有模型节点的名称&#x27;</span>,obj.<span class="property">name</span>);</span><br><span class="line">    <span class="comment">// obj.isMesh：if判断模型对象obj是不是网格模型&#x27;Mesh&#x27;</span></span><br><span class="line">    <span class="keyword">if</span> (obj.<span class="property">isMesh</span>) &#123;<span class="comment">//判断条件也可以是obj.type === &#x27;Mesh&#x27;</span></span><br><span class="line">        obj.<span class="property">material</span>.<span class="property">color</span>.<span class="title function_">set</span>(<span class="number">0xffff00</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);。</span><br></pre></td></tr></table></figure>

<p>通过一些方法查找一个模型树中的某个节点，并对其进行设置。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 返回名.name为&quot;4号楼&quot;对应的对象</span></span><br><span class="line"><span class="keyword">const</span> nameNode = scene.<span class="property">getObjectByName</span> (<span class="string">&quot;4号楼&quot;</span>);</span><br><span class="line">nameNode.<span class="property">material</span>.<span class="property">color</span>.<span class="title function_">set</span>(<span class="number">0xff0000</span>);</span><br></pre></td></tr></table></figure>

<h4 id="本地坐标和世界坐标"><a href="#本地坐标和世界坐标" class="headerlink" title="本地坐标和世界坐标"></a>本地坐标和世界坐标</h4><p>改变子对象的<code>.position</code>，子对象在世界坐标系中的坐标会发生改变。改变父对象的<code>.position</code>，子对象在世界坐标系中的位置也会跟着变化，也就是说父对象<code>.position</code>和子对象<code>.position</code>叠加才是才是子对象的<code>.position</code>。任何一个模型的本地坐标就是模型的<code>.position</code>属性。一个模型的世界坐标，是模型自身<code>.position</code>和所有父对象<code>.position</code>累加的坐标。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mesh.<span class="property">position</span>.<span class="title function_">set</span>(<span class="number">50</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">const</span> group = <span class="keyword">new</span> <span class="variable constant_">THREE</span>.<span class="title class_">Group</span>();</span><br><span class="line">group.<span class="title function_">add</span>(mesh);</span><br><span class="line">group.<span class="property">position</span>.<span class="title function_">set</span>(<span class="number">50</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br></pre></td></tr></table></figure>

<p><code>mesh.getWorldPosition(Vector3)</code>读取一个模型的世界坐标，并把读取结果存储到参数<code>Vector3</code>中。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 声明一个三维向量用来表示某个坐标</span></span><br><span class="line"><span class="keyword">const</span> worldPosition = <span class="keyword">new</span> <span class="variable constant_">THREE</span>.<span class="title class_">Vector3</span>();</span><br><span class="line"><span class="comment">// 获取mesh的世界坐标，mesh的世界坐标受到父对象group的.position影响</span></span><br><span class="line">mesh.<span class="title function_">getWorldPosition</span>(worldPosition);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;世界坐标&#x27;</span>,worldPosition);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;本地坐标&#x27;</span>,mesh.<span class="property">position</span>);</span><br></pre></td></tr></table></figure>

<p><code>mesh.add(坐标系)</code>给mesh添加一个可视化的局部坐标系。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//可视化mesh的局部坐标系</span></span><br><span class="line"><span class="keyword">const</span> meshAxesHelper = <span class="keyword">new</span> <span class="variable constant_">THREE</span>.<span class="title class_">AxesHelper</span>(<span class="number">50</span>);</span><br><span class="line">mesh.<span class="title function_">add</span>(meshAxesHelper);</span><br></pre></td></tr></table></figure>

<h4 id="移除对象-remove"><a href="#移除对象-remove" class="headerlink" title="移除对象.remove()"></a>移除对象.remove()</h4><p><code>.add()</code>方法是给父对象添加一个子对象，<code>.remove()</code>方法是删除父对象中的一个子对象，这将改变<code>.children()</code>属性。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 删除父对象group的子对象网格模型mesh1</span></span><br><span class="line">group.<span class="title function_">remove</span>(mesh1);</span><br><span class="line">scene.<span class="title function_">remove</span>(ambient);<span class="comment">//移除场景中环境光</span></span><br><span class="line">scene.<span class="title function_">remove</span>(model);<span class="comment">//移除场景中模型对象</span></span><br></pre></td></tr></table></figure>

<p>也可以一次性移除多个子对象。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">group.<span class="title function_">remove</span>(mesh1,mesh2);</span><br></pre></td></tr></table></figure>

<h3 id="模型属性-visible"><a href="#模型属性-visible" class="headerlink" title="模型属性.visible"></a>模型属性<code>.visible</code></h3><p>模型对象的父类<code>Object3D</code>封装了一个属性<code>.visible</code>，通过该属性可以隐藏或显示一个模型。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mesh.<span class="property">visible</span> =<span class="literal">false</span>;<span class="comment">// 隐藏一个网格模型，visible的默认值是true</span></span><br><span class="line">group.<span class="property">visible</span> =<span class="literal">false</span>;<span class="comment">// 隐藏一个包含多个模型的组对象group</span></span><br><span class="line">mesh.<span class="property">visible</span> =<span class="literal">true</span>;<span class="comment">// 使网格模型mesh处于显示状态</span></span><br></pre></td></tr></table></figure>

<p>材质对象的父类<code>Material</code>封装了一个<code>.visible</code>属性，通过该属性可以控制是否隐藏该材质对应的模型对象。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 隐藏网格模型mesh，visible的默认值是true</span></span><br><span class="line">mesh.<span class="property">material</span>.<span class="property">visible</span> =<span class="literal">false</span>;</span><br><span class="line"><span class="comment">// 注意如果mesh2和mesh的.material属性指向同一个材质，mesh2也会跟着mesh隐藏</span></span><br></pre></td></tr></table></figure>

<p>注意:如果多个模型引用了同一个材质，如果该材质<code>.visible</code>设置为false，意味着隐藏绑定该材质的所有模型。</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
    </footer>
  </div>

    
 
   
</article>

    
    <article
  id="post-模型对象及材质"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2023/02/05/%E6%A8%A1%E5%9E%8B%E5%AF%B9%E8%B1%A1%E5%8F%8A%E6%9D%90%E8%B4%A8/"
    >模型对象及材质</a> 
</h2>
 

    </header>
     
    <div class="article-meta">
      <a href="/2023/02/05/%E6%A8%A1%E5%9E%8B%E5%AF%B9%E8%B1%A1%E5%8F%8A%E6%9D%90%E8%B4%A8/" class="article-date">
  <time datetime="2023-02-05T09:18:27.000Z" itemprop="datePublished">2023-02-05</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/three-js/">three.js</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h4 id="三维向量Vector3与模型位置"><a href="#三维向量Vector3与模型位置" class="headerlink" title="三维向量Vector3与模型位置"></a>三维向量Vector3与模型位置</h4><p>点模型<code>Points</code>、线模型<code>Line</code>、网格网格模型<code>Mesh</code>等模型对象的父类都是Object3D。</p>
<p>三维向量<code>Vector3</code>有xyz三个分量，Three.js中会用三维向量<code>Vector3</code>表示很多种数据。<code>Vector3</code>对象具有属性<code>.x</code>、<code>.y</code>、<code>.z</code>，<code>Vector3</code>对象还具有<code>.set()</code>等方法。位置属性<code>.position</code>使用Three.js三维向量对象<code>Vector3</code>表示，因此具有<code>Vector3</code>所有的属性和方法。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> v3 = <span class="keyword">new</span> <span class="variable constant_">THREE</span>.<span class="title class_">Vector3</span>(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;v3&#x27;</span>, v3);</span><br><span class="line">v3.<span class="title function_">set</span>(<span class="number">10</span>,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">v3.<span class="property">x</span> = <span class="number">100</span>;</span><br></pre></td></tr></table></figure>

<p>通过模型位置属性<code>.position</code>可以设置模型在场景<code>Scene</code>中的位置。模型位置<code>.position</code>的默认值是<code>THREE.Vector3(0.0,0.0,0.0)</code>，表示坐标原点。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//设置网格模型y坐标</span></span><br><span class="line">mesh.<span class="property">position</span>.<span class="property">y</span> = <span class="number">80</span>;</span><br><span class="line"><span class="comment">//设置模型xyz坐标</span></span><br><span class="line">mesh.<span class="property">position</span>.<span class="title function_">set</span>(<span class="number">80</span>,<span class="number">2</span>,<span class="number">10</span>);</span><br></pre></td></tr></table></figure>

<p>执行<code>.translateX()</code>、<code>.translateY()</code>、<code>.translateZ()</code>等方法本质上改变的都是模型的位置属性<code>.position</code>。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 等价于mesh.position.x = mesh.position.x + 100;</span></span><br><span class="line"><span class="comment">//而不是mesh.position.x = 100;</span></span><br><span class="line">mesh.<span class="title function_">translateX</span>(<span class="number">100</span>);</span><br></pre></td></tr></table></figure>

<p>如果调用两次<code>mesh.translateX(100);</code>，第二次是在第一次的基础上进行累计变换。注意这些平移以及缩放函数与<code>BufferGeometry</code>平移以及缩放函数的区别。如下图<code>mesh.position.set(50,50,0);mesh.translateZ(100);</code>函数将局部坐标系的原点设置在世界坐标系x&#x3D;50,y&#x3D;50处，接着将局部坐标系的原点沿着世界坐标系的z轴平移100。<code>geometry.rotateX(Math.PI/2);geometry.translate(50,0,0);</code>函数将物体的中心点绕局部坐标系的x轴旋转90°并且平移50。</p>
<img src="https://cdn.jsdelivr.net/gh/echo468/picgo@main/img/202302052253053.png" alt="image-20230205225318979" style="zoom: 50%;" />

<p>沿着自定义的方向移动。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//向量Vector3对象表示方向</span></span><br><span class="line"><span class="keyword">const</span> axis = <span class="keyword">new</span> <span class="variable constant_">THREE</span>.<span class="title class_">Vector3</span>(<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">axis.<span class="title function_">normalize</span>(); <span class="comment">//向量归一化</span></span><br><span class="line"><span class="comment">//沿着axis轴表示方向平移100</span></span><br><span class="line">mesh.<span class="title function_">translateOnAxis</span>(axis, <span class="number">100</span>);</span><br></pre></td></tr></table></figure>

<p><code>.scale</code>表示模型对象的xyz三个方向上的缩放比例，<code>.scale</code>的属性值是一个三维向量对象<code>Vector3</code>,默认值是<code>THREE.Vector3(1.0,1.0,1.0)</code>。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//x轴方向放大2倍</span></span><br><span class="line">mesh.<span class="property">scale</span>.<span class="property">x</span> = <span class="number">2.0</span>;</span><br><span class="line"><span class="comment">//网格模型xyz方向分别缩放0.5,1.5,2倍</span></span><br><span class="line">mesh.<span class="property">scale</span>.<span class="title function_">set</span>(<span class="number">0.5</span>, <span class="number">1.5</span>, <span class="number">2</span>)</span><br></pre></td></tr></table></figure>

<p>如下图通过旋转使得局部坐标系的y轴与世界坐标系的z轴平行，使用<code>geometry.scale(1,2,1);</code>函数后图形沿着局部坐标系的y轴放大至原来的2倍。即在世界坐标系中沿z轴前后放大而不是沿y轴上下放大。但是如果是<code>mesh.scale</code>会将局部坐标系和物体按照局部坐标系的轴一起缩放。</p>
<img src="https://cdn.jsdelivr.net/gh/echo468/picgo@main/img/202302052323314.png" alt="image-20230205232310262" style="zoom:67%;" />

<h4 id="欧拉Euler与角度属性-rotation"><a href="#欧拉Euler与角度属性-rotation" class="headerlink" title="欧拉Euler与角度属性.rotation"></a>欧拉Euler与角度属性.rotation</h4><p>模型的角度属性<code>.rotation</code>和四元数属性<code>.quaternion</code>都是表示模型的角度状态，只是表示方法不同，<code>.rotation</code>属性值是欧拉对象,<code>.quaternion</code>属性值是四元数对象。</p>
<p> 创建一个欧拉对象，表示绕着xyz轴分别旋转45度，0度，90度。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title class_">Euler</span> = <span class="keyword">new</span> <span class="variable constant_">THREE</span>.<span class="title class_">Euler</span>( <span class="title class_">Math</span>.<span class="property">PI</span>/<span class="number">4</span>,<span class="number">0</span>, <span class="title class_">Math</span>.<span class="property">PI</span>/<span class="number">2</span>);</span><br></pre></td></tr></table></figure>

<p>通过属性设置欧拉对象的三个分量值。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title class_">Euler</span> = <span class="keyword">new</span> <span class="variable constant_">THREE</span>.<span class="title class_">Euler</span>();</span><br><span class="line"><span class="title class_">Euler</span>.<span class="property">x</span> = <span class="title class_">Math</span>.<span class="property">PI</span>/<span class="number">4</span>;</span><br><span class="line"><span class="title class_">Euler</span>.<span class="property">y</span> = <span class="title class_">Math</span>.<span class="property">PI</span>/<span class="number">2</span>;</span><br><span class="line"><span class="title class_">Euler</span>.<span class="property">z</span> = <span class="title class_">Math</span>.<span class="property">PI</span>/<span class="number">4</span>;</span><br></pre></td></tr></table></figure>

<p>角度属性<code>.rotation</code>的值是欧拉对象<code>Euler</code>。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//绕y轴的角度设置为60度</span></span><br><span class="line">mesh.<span class="property">rotation</span>.<span class="property">y</span> = <span class="title class_">Math</span>.<span class="property">PI</span>/<span class="number">3</span>;</span><br><span class="line"><span class="comment">//绕y轴的角度增加60度</span></span><br><span class="line">mesh.<span class="property">rotation</span>.<span class="property">y</span> += <span class="title class_">Math</span>.<span class="property">PI</span>/<span class="number">3</span>;</span><br><span class="line"><span class="comment">//绕y轴的角度减去60度</span></span><br><span class="line">mesh.<span class="property">rotation</span>.<span class="property">y</span> -= <span class="title class_">Math</span>.<span class="property">PI</span>/<span class="number">3</span>;</span><br></pre></td></tr></table></figure>

<p>模型执行<code>.rotateX()</code>、<code>.rotateY()</code>等旋转方法，会发现改变了模型的角度属性<code>.rotation</code>。如下函数是对<code>model.rotation.y</code>的累计变化。注意如果是mesh下的rotate函数就会将局部坐标系和物体按照局部坐标系的轴一起旋转，如果是geometry下的rotate函数只将物体按照局部坐标系的轴旋转。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mesh.<span class="title function_">rotateX</span>(<span class="title class_">Math</span>.<span class="property">PI</span>/<span class="number">4</span>);</span><br><span class="line">mesh.<span class="title function_">rotateY</span>(<span class="title class_">Math</span>.<span class="property">PI</span> / <span class="number">2</span>);</span><br></pre></td></tr></table></figure>

<p>旋转动画。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 渲染循环</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">    model.<span class="property">rotation</span>.<span class="property">y</span>+=<span class="number">0.01</span>;</span><br><span class="line">    <span class="comment">//等价与model.rotateY(0.01);</span></span><br><span class="line">    <span class="title function_">requestAnimationFrame</span>(render);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">    model.<span class="title function_">rotateY</span>(<span class="number">0.01</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果是绕某个轴旋转，如下是网格模型绕<code>(0,1,0)</code>向量表示的轴旋转<code>π/8</code>。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> axis = <span class="keyword">new</span> <span class="variable constant_">THREE</span>.<span class="title class_">Vector3</span>(<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>);<span class="comment">//向量axis</span></span><br><span class="line">mesh.<span class="title function_">rotateOnAxis</span>(axis,<span class="title class_">Math</span>.<span class="property">PI</span>/<span class="number">8</span>);<span class="comment">//绕axis轴旋转π/8</span></span><br></pre></td></tr></table></figure>

<h4 id="模型材质颜色-Color对象"><a href="#模型材质颜色-Color对象" class="headerlink" title="模型材质颜色(Color对象)"></a>模型材质颜色(Color对象)</h4><p>浏览器控制台查看材质颜色属性的属性值。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;material.color&#x27;</span>,material.<span class="property">color</span>);</span><br></pre></td></tr></table></figure>

<p>颜色对象有三个属性，分别为<code>.r</code>、<code>.g</code>、<code>.b</code>，表示颜色RGB的三个分量。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建一个颜色对象</span></span><br><span class="line"><span class="keyword">const</span> color = <span class="keyword">new</span> <span class="variable constant_">THREE</span>.<span class="title class_">Color</span>();<span class="comment">//默认是纯白色0xffffff。</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;查看颜色对象结构&#x27;</span>,color);<span class="comment">//可以查看rgb的值</span></span><br><span class="line"><span class="comment">// 查看Color对象设置0x00ff00对应的的.r、.g、.b值</span></span><br><span class="line"><span class="keyword">const</span> color = <span class="keyword">new</span> <span class="variable constant_">THREE</span>.<span class="title class_">Color</span>(<span class="number">0x00ff00</span>);</span><br><span class="line"><span class="comment">//通过.r、.g、.b属性改变颜色值</span></span><br><span class="line">color.<span class="property">r</span> = <span class="number">0.0</span>;</span><br><span class="line">color.<span class="property">b</span> = <span class="number">0.0</span>;</span><br></pre></td></tr></table></figure>

<p><code>Color</code>提供了<code>.setHex()</code>、<code>.setRGB()</code>、<code>.setStyle()</code>、<code>.set()</code>等修改颜色值的方法。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">color.<span class="title function_">setRGB</span>(<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>);<span class="comment">//RGB方式设置颜色</span></span><br><span class="line">color.<span class="title function_">setHex</span>(<span class="number">0x00ff00</span>);<span class="comment">//十六进制方式设置颜色</span></span><br><span class="line">color.<span class="title function_">setStyle</span>(<span class="string">&#x27;#00ff00&#x27;</span>);<span class="comment">//前端CSS颜色值设置颜色</span></span><br></pre></td></tr></table></figure>

<p><code>.setHex()</code>、<code>.setStyle()</code>风格的颜色值都可以作为<code>.set()</code>的参数。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">color.<span class="title function_">set</span>(<span class="number">0x00ff00</span>);<span class="comment">//十六进制方式设置颜色</span></span><br><span class="line">color.<span class="title function_">set</span>(<span class="string">&#x27;#00ff00&#x27;</span>);<span class="comment">//前端CSS颜色值设置颜色</span></span><br></pre></td></tr></table></figure>

<p>重置模型材质颜色。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">material.<span class="property">color</span>.<span class="title function_">set</span>(<span class="number">0x00ffff</span>);</span><br><span class="line">material.<span class="property">color</span>.<span class="title function_">set</span>(<span class="string">&#x27;#00ff00&#x27;</span>);</span><br><span class="line">material.<span class="property">color</span>.<span class="title function_">set</span>(<span class="string">&#x27;rgb(0,255,0)&#x27;</span>);</span><br></pre></td></tr></table></figure>

<h4 id="模型材质父类Material"><a href="#模型材质父类Material" class="headerlink" title="模型材质父类Material"></a>模型材质父类Material</h4><p>基础网格材质<code>MeshBasicMaterial</code>、漫反射网格材质<code>MeshLambertMaterial</code>、高光网格材质<code>MeshPhongMaterial</code>等网格材质都有一个共同的父类<code>Material</code>。</p>
<p>材质半透明设置。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">material.<span class="property">transparent</span> = <span class="literal">true</span>;<span class="comment">//开启透明</span></span><br><span class="line">material.<span class="property">opacity</span> = <span class="number">0.5</span>;<span class="comment">//设置透明度</span></span><br></pre></td></tr></table></figure>

<p>材质面属性。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">material.<span class="property">side</span> = <span class="variable constant_">THREE</span>.<span class="property">BackSide</span>;<span class="comment">//背面可以看到</span></span><br><span class="line">material.<span class="property">side</span> = <span class="variable constant_">THREE</span>.<span class="property">FrontSide</span>;<span class="comment">//正面面可以看到</span></span><br><span class="line">material.<span class="property">side</span> = <span class="variable constant_">THREE</span>.<span class="property">DoubleSide</span>;<span class="comment">//双面可见</span></span><br></pre></td></tr></table></figure>

<p><code>THREE.FrontSide</code>、<code>THREE.BackSide</code>、<code>THREE.DoubleSide</code>其实在theeejs内部都表示一个数字,可以通过浏览器控制打印查看验证。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;material.side&#x27;</span>,material.<span class="property">side</span>);</span><br></pre></td></tr></table></figure>

<h4 id="模型材质和几何体属性"><a href="#模型材质和几何体属性" class="headerlink" title="模型材质和几何体属性"></a>模型材质和几何体属性</h4><p>浏览器控制打印模型对象mesh，可以展开对象，查看对象的几何体<code>.geometry</code>和材质属性<code>.material</code>。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> mesh = <span class="keyword">new</span> <span class="variable constant_">THREE</span>.<span class="title class_">Mesh</span>(geometry, material);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;mesh&#x27;</span>,mesh);</span><br></pre></td></tr></table></figure>

<p>浏览器控制台打印模型的几何体属性<code>.geometry</code>和材质属性<code>.material</code>。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;mesh.geometry&#x27;</span>,mesh.<span class="property">geometry</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;mesh.material&#x27;</span>,mesh.<span class="property">material</span>);</span><br></pre></td></tr></table></figure>

<p>访问改变模型材质属性。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 访问模型材质,并设置材质的颜色属性</span></span><br><span class="line">mesh.<span class="property">material</span>.<span class="property">color</span>.<span class="title function_">set</span>(<span class="number">0xffff00</span>);</span><br></pre></td></tr></table></figure>

<p>访问改变模型几何体属性。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 访问模型几何体,并平移几何体顶点数据</span></span><br><span class="line">mesh.<span class="property">geometry</span>.<span class="title function_">translate</span>(<span class="number">0</span>,<span class="number">100</span>,<span class="number">0</span>);</span><br></pre></td></tr></table></figure>

<p>材质或几何体共享。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> mesh = <span class="keyword">new</span> <span class="variable constant_">THREE</span>.<span class="title class_">Mesh</span>(geometry, material);</span><br><span class="line"><span class="keyword">const</span> mesh1 = <span class="keyword">new</span> <span class="variable constant_">THREE</span>.<span class="title class_">Mesh</span>(geometry, material);</span><br><span class="line">mesh1.<span class="property">position</span>.<span class="title function_">set</span>(<span class="number">50</span>,<span class="number">50</span>,<span class="number">0</span>);</span><br><span class="line"><span class="comment">// 两个mesh共享一个材质，改变一个mesh的颜色，另一个mesh2的颜色也会跟着改变</span></span><br><span class="line"><span class="comment">// 三者等价：mesh.material、mesh2.material、material</span></span><br><span class="line">mesh.<span class="property">material</span>.<span class="property">color</span>.<span class="title function_">set</span>(<span class="number">0xffff00</span>);</span><br><span class="line"><span class="comment">// 三者等价：mesh.geometry、mesh2.geometry、geometry</span></span><br><span class="line">mesh.<span class="property">geometry</span>.<span class="title function_">translate</span>(<span class="number">0</span>,<span class="number">100</span>,<span class="number">0</span>);</span><br></pre></td></tr></table></figure>

<img src="https://cdn.jsdelivr.net/gh/echo468/picgo@main/img/202302052331753.png" alt="image-20230205233114699" style="zoom:50%;" />

<h4 id="克隆-clone-和复制-copy"><a href="#克隆-clone-和复制-copy" class="headerlink" title="克隆.clone()和复制.copy()"></a>克隆.clone()和复制.copy()</h4><p>克隆<code>.clone()</code>、复制<code>.copy()</code>是Three.js很多对象都具有的方法，比如三维向量对象<code>Vector3</code>、网格模型、几何体、材质。</p>
<p>克隆<code>.clone()</code>。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> v1 = <span class="keyword">new</span> <span class="variable constant_">THREE</span>.<span class="title class_">Vector3</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;v1&#x27;</span>,v1);</span><br><span class="line"><span class="comment">//v2是一个新的Vector3对象，和v1的.x、.y、.z属性值一样</span></span><br><span class="line"><span class="keyword">const</span> v2 = v1.<span class="title function_">clone</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;v2&#x27;</span>,v2);</span><br></pre></td></tr></table></figure>

<p>复制<code>.copy()</code>。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> v1 = <span class="keyword">new</span> <span class="variable constant_">THREE</span>.<span class="title class_">Vector3</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line"><span class="keyword">const</span> v3 = <span class="keyword">new</span> <span class="variable constant_">THREE</span>.<span class="title class_">Vector3</span>(<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>);</span><br><span class="line"><span class="comment">//读取v1.x、v1.y、v1.z的赋值给v3.x、v3.y、v3.z</span></span><br><span class="line">v3.<span class="title function_">copy</span>(v1);</span><br></pre></td></tr></table></figure>

<p>通过mesh克隆<code>.clone()</code>一个和mesh一样的新模型对象mesh2。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> mesh2 = mesh.<span class="title function_">clone</span>();</span><br><span class="line">mesh2.<span class="property">position</span>.<span class="property">x</span> = <span class="number">100</span>;</span><br></pre></td></tr></table></figure>

<p>通过克隆<code>.clone()</code>获得的新模型和原来的模型共享材质和几何体。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 改变材质颜色，或者说改变mesh2颜色，mesh和mesh2颜色都会改变</span></span><br><span class="line"><span class="comment">//material.color.set(0xffff00);</span></span><br><span class="line">mesh2.<span class="property">material</span>.<span class="property">color</span>.<span class="title function_">set</span>(<span class="number">0xffff00</span>);</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/echo468/picgo@main/img/202302052334395.png" alt="image-20230205233443346"></p>
<p>几何体和材质克隆<code>.clone()</code>。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> mesh2 = mesh.<span class="title function_">clone</span>();</span><br><span class="line"><span class="comment">// 克隆几何体和材质，重新设置mesh2的材质和几何体属性</span></span><br><span class="line">mesh2.<span class="property">geometry</span> = mesh.<span class="property">geometry</span>.<span class="title function_">clone</span>();</span><br><span class="line">mesh2.<span class="property">material</span> = mesh.<span class="property">material</span>.<span class="title function_">clone</span>();</span><br><span class="line"><span class="comment">// 改变mesh2颜色，不会改变mesh的颜色</span></span><br><span class="line">mesh2.<span class="property">material</span>.<span class="property">color</span>.<span class="title function_">set</span>(<span class="number">0xffff0000</span>);</span><br></pre></td></tr></table></figure>

<img src="https://cdn.jsdelivr.net/gh/echo468/picgo@main/img/202302052335397.png" alt="image-20230205233522340" style="zoom:67%;" />

<p>改变mesh的位置，使之位于mesh2的正上方(y)，距离100。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mesh.<span class="property">position</span>.<span class="title function_">copy</span>(mesh2.<span class="property">position</span>);<span class="comment">//1. 第1步位置重合</span></span><br><span class="line">mesh.<span class="property">position</span>.<span class="property">y</span> += <span class="number">100</span>;<span class="comment">//1. 第2步mesh在原来y的基础上增加100</span></span><br></pre></td></tr></table></figure>

<p>两个模型的姿态角度始终保持一样。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 渲染循环</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">    mesh.<span class="title function_">rotateY</span>(<span class="number">0.01</span>);<span class="comment">// mesh旋转动画</span></span><br><span class="line">    <span class="comment">// 同步mesh2和mesh的姿态角度一样，不管mesh姿态角度怎么变化，mesh2始终保持同步</span></span><br><span class="line">    mesh2.<span class="property">rotation</span>.<span class="title function_">copy</span>(mesh.<span class="property">rotation</span>);</span><br><span class="line">    renderer.<span class="title function_">render</span>(scene, camera);</span><br><span class="line">    <span class="title function_">requestAnimationFrame</span>(render);</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">render</span>();</span><br></pre></td></tr></table></figure> 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
    </footer>
  </div>

    
 
   
</article>

    
    <article
  id="post-几何体BufferGeometry"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2023/02/05/%E5%87%A0%E4%BD%95%E4%BD%93BufferGeometry/"
    >几何体BufferGeometry</a> 
</h2>
 

    </header>
     
    <div class="article-meta">
      <a href="/2023/02/05/%E5%87%A0%E4%BD%95%E4%BD%93BufferGeometry/" class="article-date">
  <time datetime="2023-02-05T07:19:37.000Z" itemprop="datePublished">2023-02-05</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/three-js/">three.js</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h4 id="通过BufferGeometry自定义任何几何形状"><a href="#通过BufferGeometry自定义任何几何形状" class="headerlink" title="通过BufferGeometry自定义任何几何形状"></a>通过BufferGeometry自定义任何几何形状</h4><p>Three.js的长方体<code>BoxGeometry</code>、球体<code>SphereGeometry</code>等几何体都是基于<code>BufferGeometry</code>类构建的，<code>BufferGeometry</code>是一个没有任何形状的空几何体，你可以通过<code>BufferGeometry</code>自定义任何几何形状，具体一点说就是定义顶点数据。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> geometry = <span class="keyword">new</span> <span class="variable constant_">THREE</span>.<span class="title class_">BufferGeometry</span>(); </span><br></pre></td></tr></table></figure>

<p>定义顶点坐标。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> vertices = <span class="keyword">new</span> <span class="title class_">Float32Array</span>([</span><br><span class="line">  <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">50</span>, <span class="number">0</span>, <span class="number">0</span>,</span><br><span class="line">  <span class="number">0</span>, <span class="number">100</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">10</span>, </span><br><span class="line">  <span class="number">0</span>, <span class="number">0</span>, <span class="number">100</span>, <span class="number">50</span>, <span class="number">0</span>, <span class="number">10</span></span><br><span class="line">]);</span><br></pre></td></tr></table></figure>

<p>属性缓冲区对象<code>BufferAttribute</code>表示Three.js几何体顶点数据（顶点坐标3个为一组）。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> attribue = <span class="keyword">new</span> <span class="variable constant_">THREE</span>.<span class="title class_">BufferAttribute</span>(vertices, <span class="number">3</span>); </span><br></pre></td></tr></table></figure>

<p>设置几何体顶点位置属性的值。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">geometry.<span class="property">attributes</span>.<span class="property">position</span> = attribue；</span><br></pre></td></tr></table></figure>

<h4 id="点模型"><a href="#点模型" class="headerlink" title="点模型"></a>点模型</h4><p>设置点模型的材质。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> material = <span class="keyword">new</span> <span class="variable constant_">THREE</span>.<span class="title class_">PointsMaterial</span>(&#123;</span><br><span class="line">  <span class="attr">color</span>: <span class="number">0xffff00</span>,</span><br><span class="line">  <span class="attr">size</span>: <span class="number">10.0</span><span class="comment">//点对象像素尺寸</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>几何体geometry作为点模型<code>Points</code>参数，会把几何体渲染为点。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> points = <span class="keyword">new</span> <span class="variable constant_">THREE</span>.<span class="title class_">Points</span>(geometry, material);</span><br></pre></td></tr></table></figure>

<h4 id="线模型"><a href="#线模型" class="headerlink" title="线模型"></a>线模型</h4><p>设置线模型的材质。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> material = <span class="keyword">new</span> <span class="variable constant_">THREE</span>.<span class="title class_">LineBasicMaterial</span>(&#123;</span><br><span class="line">  <span class="attr">color</span>: <span class="number">0xffff00</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>几何体geometry作为线模型参数，会把几何体渲染为线。</p>
<p>（1）渲染效果是从第一个点开始到最后一个点，依次连成线。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> line = <span class="keyword">new</span> <span class="variable constant_">THREE</span>.<span class="title class_">Line</span>(geometry, material);</span><br></pre></td></tr></table></figure>

<p>（2）渲染效果是从第一个点开始到最后一个点，依次连成线；最后一个点再与第一个点连线使图形封口。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> line = <span class="keyword">new</span> <span class="variable constant_">THREE</span>.<span class="title class_">LineLoop</span>(geometry, material);</span><br></pre></td></tr></table></figure>

<p>（3）渲染效果是每两个点连接成一条线，已经连线的点不会再与其他点连线。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> line = <span class="keyword">new</span> <span class="variable constant_">THREE</span>.<span class="title class_">LineSegments</span>(geometry, material);</span><br></pre></td></tr></table></figure>

<h4 id="网格模型构建矩形平面"><a href="#网格模型构建矩形平面" class="headerlink" title="网格模型构建矩形平面"></a>网格模型构建矩形平面</h4><p>网格模型Mesh其实就一个一个三角形(面)拼接构成。使用使用网格模型Mesh渲染几何体geometry，就是几何体所有顶点坐标三个为一组，构成一个三角形，多组顶点构成多个三角形，就可以用来模拟表示物体的表面。</p>
<ul>
<li>正面：逆时针</li>
<li>反面：顺时针</li>
</ul>
<p>空间中一个三角形有正反两面，相机对着三角形的一个面，如果三个顶点的顺序是逆时针方向，该面视为正面，如果三个顶点的顺序是顺时针方向，该面视为反面。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> material = <span class="keyword">new</span> <span class="variable constant_">THREE</span>.<span class="title class_">MeshLambertMaterial</span>(&#123;</span><br><span class="line">  <span class="attr">color</span>: <span class="number">0xffff00</span>,</span><br><span class="line">  <span class="attr">side</span>:<span class="variable constant_">THREE</span>.<span class="property">DoubleSide</span>,<span class="comment">//双面显示</span></span><br><span class="line">  <span class="comment">//side:THREE.FrontSide//显示正面</span></span><br><span class="line">  <span class="comment">//side:THREE.BackSide//显示反面</span></span><br><span class="line"></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>一个矩形平面，可以至少通过两个三角形拼接而成。而且两个三角形有两个顶点的坐标是重合的。注意三角形的正反面问题：保证矩形平面两个三角形的正面是一样的，也就是从一个方向观察，两个三角形都是逆时针或顺时针。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> vertices = <span class="keyword">new</span> <span class="title class_">Float32Array</span>([</span><br><span class="line">  <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">80</span>, <span class="number">0</span>, <span class="number">0</span>, </span><br><span class="line">  <span class="number">80</span>, <span class="number">80</span>, <span class="number">0</span>,<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, </span><br><span class="line">  <span class="number">80</span>, <span class="number">80</span>, <span class="number">0</span>,<span class="number">0</span>, <span class="number">80</span>, <span class="number">0</span></span><br><span class="line">]);</span><br></pre></td></tr></table></figure>

<p>使用<code>THREE.MeshLambertMaterial</code>设置网格模型材质，最后使用<code>THREE.Mesh</code>将几何体渲染成网格模型面。</p>
<h4 id="几何体顶点索引数据"><a href="#几何体顶点索引数据" class="headerlink" title="几何体顶点索引数据"></a>几何体顶点索引数据</h4><p>如果几何体有顶点索引<code>geometry.index</code>，那么可以三角形重复的顶点位置坐标删除。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> vertices = <span class="keyword">new</span> <span class="title class_">Float32Array</span>([</span><br><span class="line">    <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">80</span>, <span class="number">0</span>, <span class="number">0</span>,</span><br><span class="line">    <span class="number">80</span>, <span class="number">80</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">80</span>, <span class="number">0</span> </span><br><span class="line">]);</span><br></pre></td></tr></table></figure>

<p>通过javascript类型化数组<code>Uint16Array</code>创建顶点索引数据。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> indexes = <span class="keyword">new</span> <span class="title class_">Uint16Array</span>([</span><br><span class="line">    <span class="comment">//索引值对应顶点位置数据中的顶点坐标</span></span><br><span class="line">    <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">3</span>,</span><br><span class="line">])</span><br></pre></td></tr></table></figure>

<p>除了设置几何体顶点位置属性的值，还需要通过Three.js的属性缓冲区对象<code>BufferAttribute</code>表示几何体顶点索引数据。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">geometry.<span class="property">index</span> = <span class="keyword">new</span> <span class="variable constant_">THREE</span>.<span class="title class_">BufferAttribute</span>(indexes, <span class="number">1</span>); <span class="comment">//1个为一组</span></span><br></pre></td></tr></table></figure>

<h4 id="顶点法线数据"><a href="#顶点法线数据" class="headerlink" title="顶点法线数据"></a>顶点法线数据</h4><p>使用<code>MeshLambertMaterial</code>材质(受光照影响的材质），几何体<code>BufferGeometry</code>需要定义顶点法线数据。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 矩形平面，无索引，两个三角形，6个顶点(如果有索引可以定义四个法线顶点)</span></span><br><span class="line"><span class="comment">// 每个顶点的法线数据和顶点位置数据一一对应</span></span><br><span class="line"><span class="keyword">const</span> normals = <span class="keyword">new</span> <span class="title class_">Float32Array</span>([</span><br><span class="line">    <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, </span><br><span class="line">    <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>,</span><br><span class="line">    <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>，<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span></span><br><span class="line">]);</span><br><span class="line"><span class="comment">// 设置几何体的顶点法线属性</span></span><br><span class="line">geometry.<span class="property">attributes</span>.<span class="property">normal</span> = <span class="keyword">new</span> <span class="variable constant_">THREE</span>.<span class="title class_">BufferAttribute</span>(normals, <span class="number">3</span>);</span><br></pre></td></tr></table></figure>

<h4 id="查看Threejs自带几何体顶点"><a href="#查看Threejs自带几何体顶点" class="headerlink" title="查看Threejs自带几何体顶点"></a>查看Threejs自带几何体顶点</h4><p>Three.js提供的矩形平面<code>PlaneGeometry</code>、长方体<code>BoxGeometry</code>、球体<code>SphereGeometry</code>等各种形状的几何体，他们都有一个共同的父类<code>BufferGeometry</code>。</p>
<p>可以用顶点索引index数据构建几何体，也可以不用，three.js默认的大部分几何体都有三角形的顶点索引数据，具体可以通过浏览器控制台打印几何体数据查看。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> geometry = <span class="keyword">new</span> <span class="variable constant_">THREE</span>.<span class="title class_">PlaneGeometry</span>(<span class="number">100</span>,<span class="number">50</span>); <span class="comment">//矩形平面几何体</span></span><br><span class="line"><span class="comment">// const geometry = new THREE.BoxGeometry(50,50,50); //长方体</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;几何体&#x27;</span>,geometry);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;顶点位置数据&#x27;</span>,geometry.<span class="property">attributes</span>.<span class="property">position</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;顶点索引数据&#x27;</span>,geometry.<span class="property">index</span>);</span><br></pre></td></tr></table></figure>

<p>线条模式渲染，查看几何体三角形结构。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> material = <span class="keyword">new</span> <span class="variable constant_">THREE</span>.<span class="title class_">MeshLambertMaterial</span>(&#123;</span><br><span class="line">    <span class="attr">color</span>: <span class="number">0x00ffff</span>, </span><br><span class="line">    <span class="attr">wireframe</span>:<span class="literal">true</span>,<span class="comment">//线条模式渲染mesh对应的三角形数据</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>Three.js很多几何体都提供了细分数相关的参数，这里以矩形平面几何体<code>PlaneGeometry</code>为例，矩形平面几何体至少需要两个三角形拼接而成。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">//矩形几何体PlaneGeometry的参数3,4表示细分数，默认是1,1</span></span><br><span class="line"><span class="keyword">const</span> geometry = <span class="keyword">new</span> <span class="variable constant_">THREE</span>.<span class="title class_">PlaneGeometry</span>(<span class="number">100</span>,<span class="number">50</span>,<span class="number">1</span>,<span class="number">1</span>);</span><br></pre></td></tr></table></figure>

<p>把一个矩形分为2份，每个矩形2个三角形，总共就是4个三角形。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> geometry = <span class="keyword">new</span> <span class="variable constant_">THREE</span>.<span class="title class_">PlaneGeometry</span>(<span class="number">100</span>,<span class="number">50</span>,<span class="number">2</span>,<span class="number">1</span>);</span><br></pre></td></tr></table></figure>

<p>把一个矩形分为4份，每个矩形2个三角形，总共就是8个三角形。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> geometry = <span class="keyword">new</span> <span class="variable constant_">THREE</span>.<span class="title class_">PlaneGeometry</span>(<span class="number">100</span>,<span class="number">50</span>,<span class="number">2</span>,<span class="number">2</span>);</span><br></pre></td></tr></table></figure>

<p>球体<code>SphereGeometry</code>参数2、3分别代表宽、高度两个方向上的细分数，默认32,16。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> geometry = <span class="keyword">new</span> <span class="variable constant_">THREE</span>.<span class="title class_">SphereGeometry</span>( <span class="number">50</span>, <span class="number">32</span>, <span class="number">16</span> );</span><br></pre></td></tr></table></figure>

<p>如果球体细分数比较低，表面就不会那么光滑。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> geometry = <span class="keyword">new</span> <span class="variable constant_">THREE</span>.<span class="title class_">SphereGeometry</span>( <span class="number">15</span>, <span class="number">8</span>, <span class="number">8</span> );</span><br></pre></td></tr></table></figure>

<p>对于一个曲面而言，细分数越大，表面越光滑，但是三角形和顶点数量却越多。几何体三角形数量或者说顶点数量直接影响Three.js的渲染性能，在不影响渲染效果的情况下，一般尽量越少越好。</p>
<h4 id="旋转、缩放、平移几何体"><a href="#旋转、缩放、平移几何体" class="headerlink" title="旋转、缩放、平移几何体"></a>旋转、缩放、平移几何体</h4><p><code>BufferGeometry</code>通过<code>.scale()</code>、<code>.translate()</code>、<code>.rotateX()</code>、<code>.rotateY()</code>、<code>.rotateZ()</code>等方法可以对几何体本身进行缩放、平移、旋转,这些方法本质上都是改变几何体的顶点数据。（与Object3D的函数区分，此处函数的任何变化都是在局部坐标系中进行的，而局部坐标系原点的位置是通过模型的position属性定义的，Object3D的相关函数本质改变的是position属性）。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//缩放</span></span><br><span class="line">geometry.<span class="title function_">scale</span>(<span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>);</span><br><span class="line"><span class="comment">//平移</span></span><br><span class="line">geometry.<span class="title function_">translate</span>(<span class="number">50</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"><span class="comment">//旋转</span></span><br><span class="line">geometry.<span class="title function_">rotateX</span>(<span class="title class_">Math</span>.<span class="property">PI</span> / <span class="number">4</span>);</span><br><span class="line">geometry.<span class="title function_">rotateY</span>(<span class="title class_">Math</span>.<span class="property">PI</span> / <span class="number">4</span>);</span><br><span class="line">geometry.<span class="title function_">rotateZ</span>(<span class="title class_">Math</span>.<span class="property">PI</span> / <span class="number">4</span>);</span><br><span class="line"><span class="comment">// 居中：已经偏移的几何体居中，执行.center()，可以看到几何体重新与坐标原点重合</span></span><br><span class="line">geometry.<span class="title function_">center</span>();</span><br></pre></td></tr></table></figure>

<p>如下图通过<code>mesh.position.set(50,50,0);</code>将局部坐标系的中心设置在了世界坐标系x&#x3D;50,y&#x3D;50的地方，接下来用<code>geometry.rotateX(Math.PI/2);geometry.translate(50,0,0);</code>将物体相对于局部坐标系向x轴平移50，并且绕x轴旋转90°。可以看到物体中心相对于局部坐标系原点发生了改变，但是局部坐标系原点相对于世界坐标的原点的位置并没有发生改变。</p>
<p><img src="https://cdn.jsdelivr.net/gh/echo468/picgo@main/img/202302052237626.png" alt="image-20230205223715553"></p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
    </footer>
  </div>

    
 
   
</article>

    
    <article
  id="post-延迟渲染"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2023/01/28/%E5%BB%B6%E8%BF%9F%E6%B8%B2%E6%9F%93/"
    >延迟渲染</a> 
</h2>
 

    </header>
     
    <div class="article-meta">
      <a href="/2023/01/28/%E5%BB%B6%E8%BF%9F%E6%B8%B2%E6%9F%93/" class="article-date">
  <time datetime="2023-01-28T10:58:22.000Z" itemprop="datePublished">2023-01-28</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E5%AE%9E%E4%B9%A0/">实习</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h4 id="前向渲染"><a href="#前向渲染" class="headerlink" title="前向渲染"></a>前向渲染</h4><p>在VS中对每个物体的顶点做一系列的变换（主要是将顶点位置和法线变换到裁剪空间），然后在FS中对每个像素进行光照计算。由于每个物体上的每个像素只会调用一次FS，因此对于每个FS要传入所有的光源数据并计算每个光源的效果。</p>
<p>弊端：</p>
<p>（1）当一个场景非常复杂会有大量的物体以及复杂的深度，每个像素可能被多个物体重叠覆盖，这样会有大量的无效的GPU迭代计算。例如，如果某个像素深度复杂度为4，那么就会有3个像素计算是无效的，因为最后只有最顶部的像素会显示。</p>
<p>（2）在多光源情景下，例如大量点光源，光源很小照亮的区域也很小，只会照亮场景中的部分物体，但是FS还是会计算每个光源对每个像素的光照影响，即使光源离该像素很远。</p>
<h4 id="延迟渲染"><a href="#延迟渲染" class="headerlink" title="延迟渲染"></a>延迟渲染</h4><p>​	主要是解决大量光照渲染的方案，延迟渲染的实质是先不要迭代三角形做光照计算，而是先找出来能看到的所有像素，再去迭代光照。直接迭代三角形的话，由于大量三角形是看不到的，无疑是极大的浪费。</p>
<p>（1）第一个阶段几何pass：正常执行VS但并不是将处理后的属性变量数据继续传递给FS进行光照计算，而是将结果保存到G buffer中。G buffer是一组按照设计格式存储的一组2D贴图，保存着顶点每个属性的数据。将数据分离并一次性写入到不同的贴图中，保存这些贴图的地方是借助于OpenGL的MRT特性支持。由于是在FS中写入属性值进行片段计算，因此G buffer中最终的值是光栅化器对顶点属性执行插值的结果。由于进行了深度测试，因此当几何pass阶段完成时，G缓冲区中的贴图最终保存的将是离相机最近的像素的插值属性值，留在G buffer中的像素都是之后必须要进行光照计算的。</p>
<p>（2）第二个阶段Lighting Pass：会依次遍历G buffer中的每个像素，从不同的贴图中读取每个像素对应的属性值然后进行光照计算。由于在创建G buffer的时候，经过深度测试除了离相机最近的像素其他的全部被抛弃了，所以现在每个像素对应只会进行一次光照计算。</p>
<p>在延迟渲染中对于点光源可以计算围绕光源的球体的尺寸（对于spot light聚光灯光源我们则计算光锥体的尺寸）。那个球体表示的是点光源影响的区域，而在球体之外的则会忽视这个光源的影响不进行该光源的光照计算。可以使用一个有少量多边形的粗糙的球体模型，并以光源为中心来进行渲染。VS阶段只需要将position数据变换到裁剪空间而不用干别的。FS阶段只在受光源影响的的相关像素上执行并进行光照计算。</p>
<h3 id="几何pass"><a href="#几何pass" class="headerlink" title="几何pass"></a>几何pass</h3><h4 id="填充G-buffer"><a href="#填充G-buffer" class="headerlink" title="填充G buffer"></a>填充G buffer</h4><p>​	初始化G缓冲区。首先为顶点属性（位置和法线）和深度缓冲区创建FBO和纹理。然后在执行以下操作的循环中创建纹理的存储区域（不进行初始化），将纹理附加到FBO作为目标。为了进行MRT需要启用对所有两种纹理的写入。通过向glDrawBuffers（）函数提供一个附件位置数组来实现这一点。位置纹理写入GL_COLOR_ATTACHMENT0；法线纹理写入GL_COLOR_ATTACHMENT1。（下面只展示了纹理附件的定义过程）</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">glGenTextures</span>(<span class="number">2</span>, textures);</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">unsigned</span> <span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i++) &#123;</span><br><span class="line">		<span class="built_in">glBindTexture</span>(GL_TEXTURE_2D, textures[i]);</span><br><span class="line">		<span class="built_in">glTexImage2D</span>(GL_TEXTURE_2D, <span class="number">0</span>, GL_RGB32F, <span class="number">1024</span>, <span class="number">1024</span>, <span class="number">0</span>, GL_RGB, GL_FLOAT, <span class="literal">NULL</span>);</span><br><span class="line">		<span class="built_in">glFramebufferTexture2D</span>(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0 + i, GL_TEXTURE_2D, textures[i], <span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	GLenum DrawBuffers[] = &#123; GL_COLOR_ATTACHMENT0, GL_COLOR_ATTACHMENT1&#125;;</span><br><span class="line">	<span class="built_in">glDrawBuffers</span>(<span class="number">2</span>, DrawBuffers);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="绘制物体"><a href="#绘制物体" class="headerlink" title="绘制物体"></a>绘制物体</h4><p>绘制完成时，G buffer区将包含最近像素的属性。使用函数glDepthMask（）允许写入深度缓冲区，几何 pass需要深度缓冲区，以便用最接近的像素填充G buffer，而光照pass没有可以写入深度缓冲区的。深度测试限制在几何pass上，在没有竞争的情况下，在光 pass上做深度测试毫无意义。禁用混合，在几何过程中，这是无关紧要的。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">glBindFramebuffer</span>(GL_DRAW_FRAMEBUFFER, fbo);</span><br><span class="line"><span class="built_in">glClear</span>(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);</span><br><span class="line"><span class="built_in">glDepthMask</span>(GL_TRUE);</span><br><span class="line"><span class="built_in">glEnable</span>(GL_DEPTH_TEST);</span><br><span class="line"><span class="built_in">glDisable</span>(GL_BLEND);</span><br><span class="line"><span class="comment">/*绘制物体*/</span></span><br><span class="line"><span class="built_in">glDepthMask</span>(GL_FALSE);</span><br><span class="line"><span class="built_in">glDisable</span>(GL_DEPTH_TEST);<span class="comment">//这两行顺序不能反</span></span><br><span class="line"><span class="built_in">glBindFramebuffer</span>(GL_FRAMEBUFFER, <span class="number">0</span>);</span><br></pre></td></tr></table></figure>
<h4 id="VS"><a href="#VS" class="headerlink" title="VS"></a>VS</h4><p>简单地执行通常的转换并将需要的结果传递给FS</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#version 330</span></span><br><span class="line"><span class="built_in">layout</span> (location = <span class="number">0</span>) in vec3 Position;</span><br><span class="line"><span class="built_in">layout</span> (location = <span class="number">1</span>) in vec3 Normal;</span><br><span class="line">uniform mat4 gWVP;uniform mat4 gWorld;</span><br><span class="line">out vec3 Normal0;out vec3 WorldPos0;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    gl_Position = gWVP * <span class="built_in">vec4</span>(Position, <span class="number">1.0</span>);</span><br><span class="line">    Normal0 = (gWorld * <span class="built_in">vec4</span>(Normal, <span class="number">0.0</span>)).xyz;</span><br><span class="line">    WorldPos0 = (gWorld * <span class="built_in">vec4</span>(Position, <span class="number">1.0</span>)).xyz;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="FS"><a href="#FS" class="headerlink" title="FS"></a>FS</h4><p>负责进行MRT，它不输出单个向量，而是输出多个向量。这些向量中的每一个都指向数组中先前由glDrawBuffers（）设置的相应索引。因此，在每次FS调用中，都会写入G缓冲区的两个纹理。location &#x3D; 0的WorldPosOut写入GL_COLOR_ATTACHMENT0；location &#x3D; 1的NormalOut写入GL_COLOR_ATTACHMENT1。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#version 330</span></span><br><span class="line">in vec3 Normal0;</span><br><span class="line">in vec3 WorldPos0;</span><br><span class="line"><span class="built_in">layout</span> (location = <span class="number">0</span>) out vec3 WorldPosOut;</span><br><span class="line"><span class="built_in">layout</span> (location = <span class="number">1</span>) out vec3 NormalOut;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    WorldPosOut = WorldPos0;</span><br><span class="line">    NormalOut = <span class="built_in">normalize</span>(Normal0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="光照pass"><a href="#光照pass" class="headerlink" title="光照pass"></a>光照pass</h3><h4 id="基本设置"><a href="#基本设置" class="headerlink" title="基本设置"></a>基本设置</h4><p>此处有点光源和平行光两种光源，混合这两种光源类型，因为每个光源都由自己的draw调用处理。在正向渲染中，我们积累了FS中所有光源的结果，但现在每个FS调用只处理一个光源。在我们的例子中，我们将混合方程设置为GL_FUNC_ADD。这意味着GPU只需添加源和目标。因为我们想要真正的加法，所以将源和目标的混合函数设置为gluOne。结果是：1<em>src+1</em>dst。哦，我们需要在做这件事之前启用混合。。。在处理好混合后，我们将G缓冲区设置为读取</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">glEnable</span>(GL_BLEND);</span><br><span class="line"><span class="built_in">glBlendEquation</span>(GL_FUNC_ADD);</span><br><span class="line"><span class="built_in">glBlendFunc</span>(GL_ONE, GL_ONE);</span><br><span class="line"><span class="built_in">glBindFramebuffer</span>(GL_READ_FRAMEBUFFER, fbo);</span><br><span class="line"><span class="built_in">glClear</span>(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);</span><br></pre></td></tr></table></figure>
<h4 id="点光源"><a href="#点光源" class="headerlink" title="点光源"></a>点光源</h4> 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
    </footer>
  </div>

    
 
   
</article>

    
    <article
  id="post-三维拾取"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2023/01/27/%E4%B8%89%E7%BB%B4%E6%8B%BE%E5%8F%96/"
    >三维拾取</a> 
</h2>
 

    </header>
     
    <div class="article-meta">
      <a href="/2023/01/27/%E4%B8%89%E7%BB%B4%E6%8B%BE%E5%8F%96/" class="article-date">
  <time datetime="2023-01-27T14:56:03.000Z" itemprop="datePublished">2023-01-27</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E5%AE%9E%E4%B9%A0/">实习</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>​	让每一个像素都有自己独特的索引，当鼠标点击时获取鼠标点击处的像素和像素索引（一般glReadPixels函数是获取鼠标点击处的指定的数据，比如说3d拾取就选择获取rgb颜色数据 ，但是此处并不是真正的获取颜色数据，而是在颜色纹理中填充的是三元索引，所以从颜色纹理中获取的是三元索引），就可知道点击的像素属于哪个对象 ，就可以知道点击到了哪个对象。</p>
<p>​	通过创建帧缓冲， 将三元索引代替每个顶点像素的颜色rgb存储进入帧缓冲的颜色缓冲，从而使像素位置和索引相对应。这样在点击的时候就可以知道点击到了哪个索引。</p>
<p>三元索引：</p>
<ol>
<li>第一级是像素所在物体的索引值，场景中的每一个物体都会得到一个唯一的索引；</li>
<li>物体的draw call的索引，这个索引会在开始渲染新物体时重置；</li>
<li>每个draw call中图元的索引值，每次新的draw call开始时该索引会重置；</li>
</ol>
<h4 id="拾取阶段"><a href="#拾取阶段" class="headerlink" title="拾取阶段"></a>拾取阶段</h4><p>把模型相应数据传进拾取着色器，绘制一遍模型，把相应的顶点和索引绘制进帧缓冲。</p>
<h5 id="step1-创建帧缓冲，绑定颜色和深度纹理"><a href="#step1-创建帧缓冲，绑定颜色和深度纹理" class="headerlink" title="step1:创建帧缓冲，绑定颜色和深度纹理"></a>step1:创建帧缓冲，绑定颜色和深度纹理</h5><p>把模型的各个顶点放入帧缓冲的深度纹理，把模型的对象索引，绘制索引，原始索引放入帧缓冲的颜色纹理。下面只显示了基于阴影贴图init代码（只用了深度纹理）后添加的部分：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//注意颜色纹理的参数设置GL_RGB32F、GL_RGB</span></span><br><span class="line">    <span class="built_in">glGenTextures</span>(<span class="number">1</span>, &amp;pickingTexture);</span><br><span class="line">	<span class="built_in">glBindTexture</span>(GL_TEXTURE_2D, pickingTexture);</span><br><span class="line">	<span class="built_in">glTexImage2D</span>(GL_TEXTURE_2D, <span class="number">0</span>, GL_RGB32F, <span class="number">1024</span>, <span class="number">1024</span>,<span class="number">0</span>, GL_RGB, GL_FLOAT, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="comment">//将此纹理附加到FBO的GL_COLOR_ATTACHMENT0目标，这将使其成为片段着色器输出的目标。</span></span><br><span class="line">	<span class="built_in">glFramebufferTexture2D</span>(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0, GL_TEXTURE_2D,pickingTexture, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">glDrawBuffer</span>(GL_COLOR_ATTACHMENT0);</span><br><span class="line">	<span class="built_in">glBindTexture</span>(GL_TEXTURE_2D, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">//重置读取缓冲区和帧缓冲区</span></span><br><span class="line">    <span class="built_in">glReadBuffer</span>(GL_NONE);</span><br><span class="line">	<span class="built_in">glBindFramebuffer</span>(GL_FRAMEBUFFER, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="step2-拾取着色器"><a href="#step2-拾取着色器" class="headerlink" title="step2:拾取着色器"></a>step2:拾取着色器</h5><p>顶点着色器进行正常的MVP变换，片段着色器代码如下：</p>
<p>​	在同一次绘图调用中对象索引和绘图索引对于所有像素都是相同的，因此它们来自统一的变量。为了获得原始索引，使用内置变量gl_PimitiveID（渲染过程中的图元数量）。这是系统自动维护的原语的运行索引。系统在绘图开始时将gl_PimitiveID重置为零。这使得很难区分“背景”像素和实际被对象覆盖的像素。为了克服这个问题，在将索引写入输出之前先将其递增一。这意味着可以识别背景像素，因为它们的图元ID为零，而对象覆盖的像素具有1…n作为图元ID。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#version 330</span></span><br><span class="line">uniform uint gDrawIndex;</span><br><span class="line">uniform uint gObjectIndex;</span><br><span class="line">out vec3 FragColor;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  FragColor = <span class="built_in">vec3</span>(<span class="built_in">float</span>(gObjectIndex), <span class="built_in">float</span>(gDrawIndex),<span class="built_in">float</span>(gl_PrimitiveID + <span class="number">1</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="step3-写入帧缓冲"><a href="#step3-写入帧缓冲" class="headerlink" title="step3:写入帧缓冲"></a>step3:写入帧缓冲</h5><p>主循环中：开启拾取帧缓冲-开启拾取着色器-把模型相应数据传进拾取着色器-绘制一遍模型-恢复默认缓冲</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">glBindFramebuffer</span>(GL_DRAW_FRAMEBUFFER, fbo);</span><br><span class="line"><span class="comment">/*绘制图形*/</span></span><br><span class="line"><span class="built_in">glBindFramebuffer</span>(GL_FRAMEBUFFER, <span class="number">0</span>);</span><br></pre></td></tr></table></figure>
<h4 id="绘制阶段"><a href="#绘制阶段" class="headerlink" title="绘制阶段"></a>绘制阶段</h4><p>如果左键点击了，获取鼠标点击处的像素的三元索引（此处将点击处改成了光标位置处）<br>如果该像素不是背景，通过得到的该像素的绘制索引和原始索引绘制出相应片段（此处将绘制出相应片段改成了设置不同的颜色）</p>
<h5 id="step1-从点击的像素中获取三元索引"><a href="#step1-从点击的像素中获取三元索引" class="headerlink" title="step1:从点击的像素中获取三元索引"></a>step1:从点击的像素中获取三元索引</h5><p>​	函数参数为鼠标点击的屏幕上的xy坐标。要读取FBO，必须将其绑定到GL_read_FRAMEBUFFER目标。然后需要使用函数glReadBuffer（）指定从哪个颜色缓冲区读取，原因是FBO可以包含多个颜色缓冲区。函数glReadPixels执行实际读取，它使用左下角（第一对参数）和宽度&#x2F;高度（第二对参数）指定的矩形，并将结果读入最后一个参数给出的地址，此处矩形的大小是一个纹素。因为需要原始数据，因此使用GL_RGB作为格式，使用GL_FLOAT作为类型。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">PixelInfo</span> &#123;</span><br><span class="line">	<span class="type">float</span> ObjectID;<span class="type">float</span> DrawID;<span class="type">float</span> PrimID;</span><br><span class="line">	<span class="built_in">PixelInfo</span>() &#123;ObjectID = <span class="number">0.0f</span>;DrawID = <span class="number">0.0f</span>;PrimID = <span class="number">0.0f</span>;&#125;&#125;;</span><br><span class="line"><span class="function">PixelInfo <span class="title">ReadPixel</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> x, <span class="type">unsigned</span> <span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">glBindFramebuffer</span>(GL_READ_FRAMEBUFFER, fbo);</span><br><span class="line">	<span class="built_in">glReadBuffer</span>(GL_COLOR_ATTACHMENT0);</span><br><span class="line">	PixelInfo Pixel;</span><br><span class="line">	<span class="built_in">glReadPixels</span>(x, y, <span class="number">1</span>, <span class="number">1</span>, GL_RGB, GL_FLOAT, &amp;Pixel);</span><br><span class="line">    <span class="comment">//必须重置读取缓冲区和帧缓冲区</span></span><br><span class="line">	<span class="built_in">glReadBuffer</span>(GL_NONE);</span><br><span class="line">	<span class="built_in">glBindFramebuffer</span>(GL_READ_FRAMEBUFFER, <span class="number">0</span>);</span><br><span class="line">	<span class="keyword">return</span> Pixel;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="step2-绘制"><a href="#step2-绘制" class="headerlink" title="step2:绘制"></a>step2:绘制</h5><p>​	此处绘制一个物体正方体，但是利用不同的MVP矩阵将其draw两次。两次的gObjectIndex都为0，第一次draw的DrawIndex是0，第二次draw的DrawIndex是1。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">glUniform1ui</span>(gObjectIndexID, <span class="number">0</span>);</span><br><span class="line"><span class="built_in">glUniform1ui</span>(gDrawIndexID, <span class="number">1</span>);</span><br></pre></td></tr></table></figure>
<p>glfwGetCursorPos获取窗口上光标的位置，存入xy中。注意y轴的计算方式：height-int(y)+1(屏幕y轴与世界空间的y轴相反)。通过如下代码：如果光标在第一个物体的第一个三角形，则为红色；第一个物体的第二个三角形，则为墨绿色；如果光标在第二个物体的第一个三角形，则为蓝色；第二个物体的第二个三角形，则为灰色；光标不在物体上则为绿色。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">    <span class="built_in">glfwGetCursorPos</span>(window,&amp;x,&amp;y);</span><br><span class="line">PixelInfo Pixel = <span class="built_in">ReadPixel</span>(<span class="built_in">int</span>(x), <span class="number">768</span>-<span class="built_in">int</span>(y)+<span class="number">1</span>);</span><br><span class="line"><span class="keyword">if</span> (Pixel.PrimID != <span class="number">0</span>) &#123;</span><br><span class="line">	glm::uint a = (uint)Pixel.DrawID;</span><br><span class="line">	glm::uint b = (uint)Pixel.PrimID;</span><br><span class="line">	<span class="keyword">if</span> (a == <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span>(b == <span class="number">1</span>)&#123;<span class="built_in">glColor4f</span>(<span class="number">0.4f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">1.0f</span>);&#125;</span><br><span class="line">		<span class="keyword">if</span> (b == <span class="number">2</span>) &#123;<span class="built_in">glColor4f</span>(<span class="number">0.4f</span>, <span class="number">0.4f</span>, <span class="number">0.0f</span>, <span class="number">1.0f</span>);&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (a == <span class="number">1</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span> (b == <span class="number">1</span>) &#123;<span class="built_in">glColor4f</span>(<span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">0.4f</span>, <span class="number">1.0f</span>);&#125;</span><br><span class="line">		<span class="keyword">if</span> (b == <span class="number">2</span>) &#123;<span class="built_in">glColor4f</span>(<span class="number">0.4f</span>, <span class="number">0.4f</span>, <span class="number">0.4f</span>, <span class="number">1.0f</span>);&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">	<span class="built_in">glColor4f</span>(<span class="number">0.0f</span>, <span class="number">0.4f</span>, <span class="number">0.0f</span>, <span class="number">1.0f</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="真正绘制阶段"><a href="#真正绘制阶段" class="headerlink" title="真正绘制阶段"></a>真正绘制阶段</h4><p>主循环中正常绘制，使物体显示在屏幕。</p>
<p>效果：</p>
<table>
<thead>
<tr>
<th><img src="https://cdn.jsdelivr.net/gh/echo468/picgo@main/img/202301281856762.png" alt="img"></th>
<th><img src="https://cdn.jsdelivr.net/gh/echo468/picgo@main/img/202301281857280.png" alt="image-20230128185721248"></th>
</tr>
</thead>
<tbody><tr>
<td><img src="https://cdn.jsdelivr.net/gh/echo468/picgo@main/img/202301281857475.png" alt="image-20230128185707432"></td>
<td><img src="https://cdn.jsdelivr.net/gh/echo468/picgo@main/img/202301281857155.png" alt="image-20230128185729121"></td>
</tr>
<tr>
<td><img src="https://cdn.jsdelivr.net/gh/echo468/picgo@main/img/202301281857598.png" alt="image-20230128185734563"></td>
<td></td>
</tr>
</tbody></table>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
    </footer>
  </div>

    
 
   
</article>

    
    <article
  id="post-实例渲染"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2023/01/26/%E5%AE%9E%E4%BE%8B%E6%B8%B2%E6%9F%93/"
    >实例渲染</a> 
</h2>
 

    </header>
     
    <div class="article-meta">
      <a href="/2023/01/26/%E5%AE%9E%E4%BE%8B%E6%B8%B2%E6%9F%93/" class="article-date">
  <time datetime="2023-01-26T07:52:06.000Z" itemprop="datePublished">2023-01-26</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E5%AE%9E%E4%B9%A0/">实习</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <p>假设想渲染一个有一支庞大军队经过的场景，要用一个士兵的模型渲出成千上万的士兵大军。一种方法是每次绘制一个士兵都调用一次draw call，并更新当前士兵相关的一致变量（位置、尺寸等）。例如，每个士兵都处于不同的位置，每个士兵都可以更高或者更矮尺寸不一等。因此，每次draw call都要更新当前士兵模型的WVP矩阵，这样开销会很大。</p>
<p>实例渲染：一个实例就是要渲染的模型在场景的一次实际出现，这里例子中就是一个士兵。实例化渲染意味着可以在一次draw call中渲染多个实例，并为每个实例提供其特有的属性。</p>
<p>方法1：在一个单独的顶点缓冲VB中定义实例的属性（例如：WVP矩阵）。通常顶点处理器会逐顶点每次处理一个顶点数据，有了存放实例数据的顶点缓冲VB后，定点处理器在每次处理一个顶点时要等所有顶点都已经被绘制，存有实例数据的VB提供的属性数据是针对所有顶点公共的。(第一种是将实例数据作为顶点属性传递)</p>
<p>方法2：使用一个内置的叫做gl_InstanceID的shader变量，它是用来告诉当前的实例索引index的。我们可以根据这个索引值来定位一致变量数组中对应的实例数据来进行相应的渲染操作。</p>
<img src="https://cdn.jsdelivr.net/gh/echo468/picgo@main/img/202301271615735.png" alt="image-20230127161506622" style="zoom:50%;" />

<p>这里有一个包含100个顶点的模型，每个顶点都有位置、法线、纹理坐标属性，三个属性中每个属性都有他们自己的顶点缓冲。另外，还有第四个顶点缓冲buffer存放着三个WVP矩阵。先使用第一个WVP矩阵应用到100个顶点pos位置的绘制上，然后再使用第二个WVP矩阵绘制一遍，然后再使用第三个绘制，并且这个过程是在一个draw call中实现的，而不是三个。WVP矩阵会作为输入参数传送到顶点处理器中，但由于第四个VB被标记为存有实例数据，所以WVP矩阵在所有顶点绘制完之前是不会变化的。</p>
<p>cpp文件：</p>
<p>​	由于WVP矩阵是一个4x4矩阵，不能仅为其启用一个顶点属性，因为顶点属性最多只能包含4个浮点或整数。因此需要启用和配置4个连续顶点属性的循环。每个属性将包含矩阵中的一个向量（第一个属性1包含三个MVP矩阵的第一个向量，第二个属性2包含三个MVP矩阵的第二个向量……）。四个属性中的每一个都由四个浮点组成，一个矩阵中的属性与下一个矩阵之间的距离是4x4矩阵的大小，因此一共占了1、2、3、4顶点属性。</p>
<p>​	glVertexAttribDivisitor（）函数使其成为实例数据而不是顶点数据。它采用两个参数：第一个是顶点数组属性，第二个参数告诉OpenGL在实例化渲染过程中属性前进的速度。默认情况下，除数为零。如果除数是10，这意味着前10个实例将使用缓冲区中的第一条数据，接下来的10个实例会使用第二条数据。此处希望每个实例都有一个专用的WVP矩阵，因此使用1的除数。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建存储了3个MPV矩阵的顶点属性数组，glm::mat4类型</span></span><br><span class="line"><span class="type">static</span> glm::mat4 WVPMats[] = &#123;MVP1,MVP2,MVP3&#125;;</span><br><span class="line"><span class="comment">//创建并绑定缓冲区</span></span><br><span class="line">GLuint MVPbuffer;</span><br><span class="line"><span class="built_in">glGenBuffers</span>(<span class="number">1</span>, &amp;MVPbuffer);</span><br><span class="line"><span class="built_in">glBindBuffer</span>(GL_ARRAY_BUFFER, MVPbuffer);</span><br><span class="line"><span class="built_in">glBufferData</span>(GL_ARRAY_BUFFER, <span class="built_in">sizeof</span>(glm::mat4)* <span class="number">3</span>, WVPMats, GL_DYNAMIC_DRAW);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">unsigned</span> <span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">	<span class="built_in">glEnableVertexAttribArray</span>(<span class="number">1</span> + i);</span><br><span class="line">	<span class="built_in">glVertexAttribPointer</span>(<span class="number">1</span> + i, <span class="number">4</span>, GL_FLOAT, GL_FALSE, <span class="built_in">sizeof</span>(glm::mat4),</span><br><span class="line">		(<span class="type">const</span> GLvoid*)(<span class="built_in">sizeof</span>(GLfloat) * i * <span class="number">4</span>));</span><br><span class="line">	<span class="built_in">glVertexAttribDivisor</span>(<span class="number">1</span> + i, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该函数的唯一变化是将实例数作为第四个参数。</p>
<p>对于（i&#x3D;0；i&lt;NumInstance；i++）</p>
<p>如果（i mod除数&#x3D;&#x3D;0）</p>
<p>从带有实例数据的VBs中获取属性i&#x2F;除数</p>
<p>对于（j&#x3D;0；j&lt;NumVertices；j++）</p>
<p>从带有顶点数据的VBs获取属性j</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">glDrawArraysInstanced</span>(GL_TRIANGLES, <span class="number">0</span>, <span class="number">36</span>, <span class="number">3</span>);</span><br></pre></td></tr></table></figure>

<p>顶点着色器中：</p>
<p>不再将WVP和世界矩阵作为统一变量，而是将它们作为顶点属性。VS不关心它们的值只会在每个实例中更新一次，而不会在每个顶点中更新。WVP矩阵占据位置1-4。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#version 330</span></span><br><span class="line"><span class="built_in">layout</span> (location = <span class="number">0</span>) in vec3 Position;</span><br><span class="line"><span class="built_in">layout</span> (location = <span class="number">1</span>) in mat4 MVP;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    gl_Position = MVP * <span class="built_in">vec4</span>(Position, <span class="number">1.0</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>如果使用第二种方法</p>
<p>顶点着色器</p>
<p>​	gl_InstanceID是一个内置变量，仅在VS中可用。由于计划在FS中使用它，因此必须在此处访问它，并在常规输出变量中传递它。gl_InstanceID的类型是整数，因此使用相同类型的输出变量。由于光栅化器无法对整数进行插值，必须将输出变量标记为“flat”。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">flat out int InstanceID;</span><br><span class="line">void main()</span><br><span class="line">&#123;</span><br><span class="line">  InstanceID = gl_InstanceID;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>片段着色器</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">#version 330</span><br><span class="line">flat in int InstanceID;</span><br><span class="line">out vec4 FragColor;</span><br><span class="line">vec4 gColor[4] = &#123;</span><br><span class="line">	vec4(0.5, 0.0, 0.0,0.0),</span><br><span class="line">	vec4(0.0, 0.5, 0.0,0.0),</span><br><span class="line">	vec4(0.0, 0.0, 0.5,0.0),</span><br><span class="line">	vec4(0.0, 0.0, 0.0,0.0)</span><br><span class="line">&#125;;</span><br><span class="line"> void main()</span><br><span class="line"> &#123;  </span><br><span class="line"> FragColor = gColor [InstanceID % 4];</span><br><span class="line"> &#125;;</span><br></pre></td></tr></table></figure>

<p>效果如下：</p>
<img src="https://cdn.jsdelivr.net/gh/echo468/picgo@main/img/202301271722256.png" alt="image-20230127172248210" style="zoom:50%;" /> 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
    </footer>
  </div>

    
 
   
</article>

    
    <article
  id="post-法线贴图"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2023/01/25/%E6%B3%95%E7%BA%BF%E8%B4%B4%E5%9B%BE/"
    >法线贴图</a> 
</h2>
 

    </header>
     
    <div class="article-meta">
      <a href="/2023/01/25/%E6%B3%95%E7%BA%BF%E8%B4%B4%E5%9B%BE/" class="article-date">
  <time datetime="2023-01-25T09:16:14.000Z" itemprop="datePublished">2023-01-25</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E5%AE%9E%E4%B9%A0/">实习</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <p>表面光滑的法线：在三角形的三个顶点法向量之间进行平滑插值来得到三角形上每个点的法向量。</p>
<p>法线贴图：从‘法线贴图’上进行采样得到对应的法线方向，表面上的所有法向量都是可以被计算并且存储在法线贴图中。在片段着色器阶段进行光照计算的时候，每个像素的特定法线也是根据纹理坐标采样来获取使用。</p>
<p>切线空间：坐标系需要三个正交单位向量。物体表面确定了原法线后会有多个切线X和副切线Y，由于新法线是2D纹理的的一部分，而2D纹理有两个正交单位向量U和V，因此通常做法是将X分量对应到U轴（Tangent），而Y分量对应到V轴在（Bitangent），将切线方向与纹理空间对齐。由原法线、与纹理空间对齐的切线和副切线组成的矩阵是TBN矩阵，该矩阵向量定义的坐标系是切线空间。</p>
<p>法线纹理：对于新法线，即使是在非常凹凸不平的表面，仍然认为法线的方向是从纹理朝外的。在切线空间定义法向量，并存储在纹理的RGB文素中。Z分量主导的一个分量，X和Y分量只能起到让其略微倾斜的作用。将XYZ向量存储在RGB文素中会使得法线纹理偏蓝色。但是法线坐标[-1,1]需要变成rgb文素[0,1]。</p>
<p>切线和副切线的计算：</p>
<img src="https://pic4.zhimg.com/80/v2-f89f1ddfc04a94294520b57a43dbaf33_720w.webp" alt="img" style="zoom: 50%;" />

<p>找到物体本地空间下的向量T（表示tangent）和B（表示bitangent），可以看到两个三角形边E1和E2可以写成T和B的线性组合：</p>
<img src="https://pic1.zhimg.com/80/v2-ff93301c5fa92878ab35e0cea8eaa7e8_720w.webp" alt="img" style="zoom: 67%;" />

<p>也可以写成下面的形式：</p>
<img src="https://pic2.zhimg.com/80/v2-6b58b632273e1268377495c13ff15731_720w.webp" alt="img" style="zoom:67%;" />

<p>现在可以很容易的转换成矩阵公式的形式：</p>
<img src="https://pic2.zhimg.com/80/v2-480cb4f3bff672a721db1c83b27e5241_720w.webp" alt="img" style="zoom:67%;" />

<p>现在想把矩阵转换到等式的右边，为此可以两边乘以上面标红的矩阵的逆矩阵：</p>
<img src="https://pic3.zhimg.com/80/v2-78d0b4ac1486170ab44a968782960566_720w.webp" alt="img" style="zoom:67%;" />

<p>计算如下:</p>
<img src="https://pic4.zhimg.com/80/v2-a217ef03cf87b58dc57e1fd857db5243_720w.webp" alt="img" style="zoom:67%;" />

<p>算出逆矩阵的值得到：</p>
<img src="https://pic4.zhimg.com/80/v2-410d78592022a7307711cd67634974d7_720w.webp" alt="img" style="zoom:67%;" />

<p>​	对每一个三角形执行上述过程，可以为每个三角形通过三角形的边和UV坐标计算出tangent向量和bitangent向量（对三角形的三个顶点来说这两个向量都是一样的）。通常的做法是为每一个顶点都保存一个tangent&#x2F;bitangent值，每个顶点的tangent&#x2F;bitangent值由共享这个顶点的所有三角面的平均tangent&#x2F;bitangent值确定（这与顶点法线是一样的）。这样做的原因是使整个三角面的效果比较平滑，防止相邻三角面之间的不平滑过渡。这个坐标系空间的第三个分量——法线分量，是tangent和bitangent的叉乘积。</p>
<p>向着色器中将法线数组、切线数组和副切线数组作为顶点属性传入着色器，同时用GLuint类型变量加载法线纹理。</p>
<p>在顶点着色器中新增代码：</p>
<p>计算都摄像机空间中做，因为在这一空间中更容易获取片段坐标。使用3*3的模型视图矩阵乘T、B、N向量：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vec3 vertexTangent_cameraspace = MV3x3 * vertexTangent_modelspace;</span><br><span class="line">vec3 vertexBitangent_cameraspace = MV3x3 * vertexBitangent_modelspace;</span><br><span class="line">vec3 vertexNormal_cameraspace = MV3x3 * vertexNormal_modelspace;</span><br></pre></td></tr></table></figure>

<p>这三个向量确定了TBN矩阵，此矩阵是从世界空间到MV下的切线空间的变换：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mat3 TBN = <span class="built_in">transpose</span>(<span class="built_in">mat3</span>(</span><br><span class="line">	vertexTangent_cameraspace,</span><br><span class="line">	vertexBitangent_cameraspace,</span><br><span class="line">	vertexNormal_cameraspace ));</span><br></pre></td></tr></table></figure>

<p>利用它计算切线空间中的光线方向和视线方向：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">LightDirection_tangentspace = TBN * LightDirection_cameraspace;</span><br><span class="line">EyeDirection_tangentspace =  TBN * EyeDirection_cameraspace;</span><br></pre></td></tr></table></figure>
<p>在片段着色器中添加如下代码：</p>
<p>先获取法线数据，从rgb的[0,1]变换到齐次坐标的[-1,1]，再进行归一化作为计算光照的n向量。由于该n向量是在切线空间计算的，因此为了保证计算都在同一个空间进行，需要在顶点着色器中相关参数TBN矩阵：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vec3 TextureNormal_tangentspace = normalize(texture( NormalTextureSampler, UV ).rgb*2.0 - 1.0);</span><br></pre></td></tr></table></figure>

 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
    </footer>
  </div>

    
 
   
</article>

    
  </article>
  

  
  <nav class="page-nav">
    
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/2/">下一页</a>
  </nav>
  
</section>
</div>

      <footer class="footer">
  <div class="outer">
    <ul>
      <li>
        Copyrights &copy;
        2020-2023
        <i class="ri-heart-fill heart_icon"></i> John Doe
      </li>
    </ul>
    <ul>
      <li>
        
        
        
        Powered by <a href="https://hexo.io" target="_blank">Hexo</a>
        <span class="division">|</span>
        Theme - <a href="https://github.com/Shen-Yu/hexo-theme-ayer" target="_blank">Ayer</a>
        
      </li>
    </ul>
    <ul>
      <li>
        
        
        <span>
  <span><i class="ri-user-3-fill"></i>Visitors:<span id="busuanzi_value_site_uv"></span></s>
  <span class="division">|</span>
  <span><i class="ri-eye-fill"></i>Views:<span id="busuanzi_value_page_pv"></span></span>
</span>
        
      </li>
    </ul>
    <ul>
      
        <li>
          <a href="http://www.beian.miit.gov.cn/" target="_black">赣ICP备2021001676号</a>
        </li>
        
    </ul>
    <ul>
      <li>
        <!-- cnzz统计 -->
        
        <script type="text/javascript" src='https://s9.cnzz.com/z_stat.php?id=1278069914&amp;web_id=1278069914'></script>
        
      </li>
    </ul>
  </div>
</footer>
      <div class="float_btns">
        <div class="totop" id="totop">
  <i class="ri-arrow-up-line"></i>
</div>

<div class="todark" id="todark">
  <i class="ri-moon-line"></i>
</div>

      </div>
    </main>
    <aside class="sidebar on">
      <button class="navbar-toggle"></button>
<nav class="navbar">
  
  <div class="logo">
    <a href="/"><img src="/images/ayer-side.svg" alt="Hexo"></a>
  </div>
  
  <ul class="nav nav-main">
    
    <li class="nav-item">
      <a class="nav-item-link" href="/">主页</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/archives">归档</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/categories">分类</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/tags">标签</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/friend">友链</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/journal">日志</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/2019/about">关于我</a>
    </li>
    
  </ul>
</nav>
<nav class="navbar navbar-bottom">
  <ul class="nav">
    <li class="nav-item">
      
      <a class="nav-item-link nav-item-search"  title="Search">
        <i class="ri-search-line"></i>
      </a>
      
      
      <a class="nav-item-link" target="_blank" href="/atom.xml" title="RSS Feed">
        <i class="ri-rss-line"></i>
      </a>
      
    </li>
  </ul>
</nav>
<div class="search-form-wrap">
  <div class="local-search local-search-plugin">
  <input type="search" id="local-search-input" class="local-search-input" placeholder="Search...">
  <div id="local-search-result" class="local-search-result"></div>
</div>
</div>
    </aside>
    <script>
      if (window.matchMedia("(max-width: 768px)").matches) {
        document.querySelector('.content').classList.remove('on');
        document.querySelector('.sidebar').classList.remove('on');
      }
    </script>
    <div id="mask"></div>

<!-- #reward -->
<div id="reward">
  <span class="close"><i class="ri-close-line"></i></span>
  <p class="reward-p"><i class="ri-cup-line"></i>请我喝杯咖啡吧~</p>
  <div class="reward-box">
    
    <div class="reward-item">
      <img class="reward-img" src="https://cdn.jsdelivr.net/gh/Shen-Yu/cdn/img/alipay.jpg">
      <span class="reward-type">支付宝</span>
    </div>
    
    
    <div class="reward-item">
      <img class="reward-img" src="https://cdn.jsdelivr.net/gh/Shen-Yu/cdn/img/wechat.jpg">
      <span class="reward-type">微信</span>
    </div>
    
  </div>
</div>
    
<script src="/js/jquery-2.0.3.min.js"></script>


<script src="/js/lazyload.min.js"></script>

<!-- Tocbot -->

<script src="https://cdn.jsdelivr.net/npm/jquery-modal@0.9.2/jquery.modal.min.js"></script>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/jquery-modal@0.9.2/jquery.modal.min.css">
<script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/js/jquery.justifiedGallery.min.js"></script>

<script src="/dist/main.js"></script>

<!-- ImageViewer -->

<!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                <!--  Controls are self-explanatory. Order can be changed. -->

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" style="display:none" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                        <div class="pswp__preloader__cut">
                            <div class="pswp__preloader__donut"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div>

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.css">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.min.css">
<script src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js"></script>

<script>
    function viewer_init() {
        let pswpElement = document.querySelectorAll('.pswp')[0];
        let $imgArr = document.querySelectorAll(('.article-entry img:not(.reward-img)'))

        $imgArr.forEach(($em, i) => {
            $em.onclick = () => {
                // slider展开状态
                // todo: 这样不好，后面改成状态
                if (document.querySelector('.left-col.show')) return
                let items = []
                $imgArr.forEach(($em2, i2) => {
                    let img = $em2.getAttribute('data-idx', i2)
                    let src = $em2.getAttribute('data-target') || $em2.getAttribute('src')
                    let title = $em2.getAttribute('alt')
                    // 获得原图尺寸
                    const image = new Image()
                    image.src = src
                    items.push({
                        src: src,
                        w: image.width || $em2.width,
                        h: image.height || $em2.height,
                        title: title
                    })
                })
                var gallery = new PhotoSwipe(pswpElement, PhotoSwipeUI_Default, items, {
                    index: parseInt(i)
                });
                gallery.init()
            }
        })
    }
    viewer_init()
</script>

<!-- MathJax -->

<!-- Katex -->

<!-- busuanzi  -->


<script src="/js/busuanzi-2.3.pure.min.js"></script>


<!-- ClickLove -->

<!-- ClickBoom1 -->

<script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script>

<script src="/js/clickBoom1.js"></script>


<!-- ClickBoom2 -->

<!-- CodeCopy -->


<link rel="stylesheet" href="/css/clipboard.css">

<script src="https://cdn.jsdelivr.net/npm/clipboard@2/dist/clipboard.min.js"></script>
<script>
  function wait(callback, seconds) {
    var timelag = null;
    timelag = window.setTimeout(callback, seconds);
  }
  !function (e, t, a) {
    var initCopyCode = function(){
      var copyHtml = '';
      copyHtml += '<button class="btn-copy" data-clipboard-snippet="">';
      copyHtml += '<i class="ri-file-copy-2-line"></i><span>COPY</span>';
      copyHtml += '</button>';
      $(".highlight .code pre").before(copyHtml);
      $(".article pre code").before(copyHtml);
      var clipboard = new ClipboardJS('.btn-copy', {
        target: function(trigger) {
          return trigger.nextElementSibling;
        }
      });
      clipboard.on('success', function(e) {
        let $btn = $(e.trigger);
        $btn.addClass('copied');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-checkbox-circle-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPIED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-checkbox-circle-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
      clipboard.on('error', function(e) {
        e.clearSelection();
        let $btn = $(e.trigger);
        $btn.addClass('copy-failed');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-time-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPY FAILED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-time-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
    }
    initCopyCode();
  }(window, document);
</script>


<!-- CanvasBackground -->


<script src="/js/dz.js"></script>



    
    <div id="music">
    
    
    
    <iframe frameborder="no" border="1" marginwidth="0" marginheight="0" width="200" height="52"
        src="//music.163.com/outchain/player?type=2&id=1441758494&auto=1&height=32"></iframe>
</div>

<style>
    #music {
        position: fixed;
        right: 15px;
        bottom: 0;
        z-index: 998;
    }
</style>
    
  </div>
</body>

</html>
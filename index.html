<!DOCTYPE html>


<html lang="en">


<head>
  <meta charset="utf-8" />
    
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />
  <title>
     Hexo
  </title>
  <meta name="generator" content="hexo-theme-ayer">
  
  <link rel="shortcut icon" href="/favicon.ico" />
  
  
<link rel="stylesheet" href="/dist/main.css">

  
<link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Shen-Yu/cdn/css/remixicon.min.css">

  
<link rel="stylesheet" href="/css/custom.css">

  
  
<script src="https://cdn.jsdelivr.net/npm/pace-js@1.0.2/pace.min.js"></script>

  
  

  

</head>

</html>

<body>
  <div id="app">
    
      <canvas class="fireworks"></canvas>
      <style>
        .fireworks {
          position: fixed;
          left: 0;
          top: 0;
          z-index: 99999;
          pointer-events: none;
        }
      </style>
      
      
    <main class="content on">
      
<section class="cover">
    
      
      <a class="forkMe" href="https://github.com/Shen-Yu/hexo-theme-ayer"
        target="_blank"><img width="149" height="149" src="/images/forkme.png"
          class="attachment-full size-full" alt="Fork me on GitHub" data-recalc-dims="1"></a>
    
  <div class="cover-frame">
    <div class="bg-box">
      <img src="/images/cover1.jpg" alt="image frame" />
    </div>
    <div class="cover-inner text-center text-white">
      <h1><a href="/">Hexo</a></h1>
      <div id="subtitle-box">
        
        <span id="subtitle"></span>
        
      </div>
      <div>
        
        <img
          src="/images/ayer.svg"
          class="cover-logo"
          alt="Hexo"
        />
        
      </div>
    </div>
  </div>
  <div class="cover-learn-more">
    <a href="javascript:void(0)" class="anchor"><i class="ri-arrow-down-line"></i></a>
  </div>
</section>



<script src="https://cdn.jsdelivr.net/npm/typed.js@2.0.11/lib/typed.min.js"></script>


<!-- Subtitle -->

  <script>
    try {
      var typed = new Typed("#subtitle", {
        strings: ['keep learning!!!!', '', ''],
        startDelay: 0,
        typeSpeed: 200,
        loop: true,
        backSpeed: 100,
        showCursor: true
      });
    } catch (err) {
      console.log(err)
    }
  </script>
  
<div id="main">
  <section class="outer">
  <article class="articles">
    
    
    
    
    <article
  id="post-games202-2"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2023/07/08/games202-2/"
    >games202-2</a> 
</h2>
 

    </header>
     
    <div class="article-meta">
      <a href="/2023/07/08/games202-2/" class="article-date">
  <time datetime="2023-07-08T05:44:01.000Z" itemprop="datePublished">2023-07-08</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/games202/">games202</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h4 id="渲染管线"><a href="#渲染管线" class="headerlink" title="渲染管线"></a>渲染管线</h4><p>1、三维物体：用点和连接关系（如obj文件）表示</p>
<p>2、顶点处理：MVP矩阵变换，从三维空间中的点变换到屏幕上的点（但是连接关系没有改变）</p>
<p>3、光栅化：将三角形离散成片元（像素），根据遮挡关系保留最终能看见的片元（深度测试）</p>
<p>4、着色：计算片元的颜色值（不同的着色模型，如blinn-phong，可以很好的处理直接光照，但是不适合处理全局光照，如阴影和光线的多次弹射&#x2F;纹理映射（涉及重心坐标插值）等）</p>
<p>5、屏幕显示</p>
<p>关于先进行深度测试还是先计算片元的颜色值，会有不同的处理导致不同的顺序。硬件渲染管线在GPU上运行，速度快，并行性。</p>
<h4 id="OpenGL"><a href="#OpenGL" class="headerlink" title="OpenGL"></a>OpenGL</h4><p>在CPU端执行的API调动GPU（快，很多操作封装成API可以直接调用），跨平台。缺点：版本太多；C风格代码没有面向对象的说法；很多年前不方便debug。</p>
<p>使用：</p>
<p>1、确定要绘制的模型     VBO：GPU中的一块内存，存储顶点属性</p>
<p>2、定义矩阵进行顶点变换，使用变换相关API，不需要自己推导矩阵（M变换）</p>
<p>3、确定相机位置（VP变换），创建&#x2F;指定帧缓冲（指定了帧缓冲可以渲染一次，获得多张图（多目标渲染，由片元着色器指定渲染到哪一个纹理，第一次渲染得到的纹理可以在第二次渲染使用），以及为了防止屏幕撕裂，可能需要使用双重&#x2F;三重缓冲）</p>
<p>4、着色器</p>
<p>顶点着色器：每个顶点进行变换如MVP变换；</p>
<p>在两个着色器中间会进行光栅化，需要插值的属性插值好送往片段着色器。</p>
<p>片段着色器：顶点着色器的输出是片段着色器的输入，顶点的属性会被插值到片段。为每一个片段着色。（可以手动进行深度测试）</p>
<p>除了顶点和片段很多都是可封装的。在渲染前，一定要设置清楚GPU应该如何渲染。</p>
<h4 id="GLSL"><a href="#GLSL" class="headerlink" title="GLSL"></a>GLSL</h4><p>着色语言写出来的着色器需要先编译，GPU再执行。</p>
<p>（1）create shader（本质是字符串，可以存在文件中）</p>
<p>（2）compile shader(编译)</p>
<p>（3）attach shader to program（结合所有自定义的shader）</p>
<p>（4）link program（链接，查看各个shader能否链接在一起，有无问题）</p>
<p>（5）use program</p>
<p>上述步骤可以封装。</p>
<p><img src="https://cdn.jsdelivr.net/gh/echo468/picgo@main/img/202307081609629.png" alt="image-20230708160920521"></p>
<p>attribute顶点属性，只会出现在顶点着色器。（）</p>
<p>varrying片段着色器需要使用的，要插值的量。（片段着色器有相同的变量）</p>
<p>uniform全局变量，着色器都可以访问</p>
<p>着色器不需要使用for循环，只是针对单个顶点&#x2F;单个片元要如何执行。</p>
<p>texture2D:查一个纹理，在哪里查</p>
<p>gl_Fragment、gl_Position内置变量，写入最终片段呈现的值&#x2F;变换后拿去视口变换的顶点（）</p>
<h4 id="Debugging-shader"><a href="#Debugging-shader" class="headerlink" title="Debugging shader"></a>Debugging shader</h4><p>工具：</p>
<p>Nsight Graphic</p>
<p>RenderDoc</p>
<p>将得出的值，当成颜色显示在屏幕（负数可以先偏移）</p>
<h4 id="渲染方程"><a href="#渲染方程" class="headerlink" title="渲染方程"></a>渲染方程</h4><img src="https://cdn.jsdelivr.net/gh/echo468/picgo@main/img/202307081623378.png" alt="image-20230708162309332" style="zoom: 80%;" />

<img src="https://cdn.jsdelivr.net/gh/echo468/picgo@main/img/202307081624775.png" alt="image-20230708162427731" style="zoom:80%;" />

<p>全局光照：直接光照+间接光照（计算复杂）</p>
<p>解决实时光照：解决多一次bounce的间接光照</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
    </footer>
  </div>

    
 
   
</article>

    
    <article
  id="post-环境配置"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2023/06/25/%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/"
    >环境配置</a> 
</h2>
 

    </header>
     
    <div class="article-meta">
      <a href="/2023/06/25/%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/" class="article-date">
  <time datetime="2023-06-25T03:23:34.000Z" itemprop="datePublished">2023-06-25</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/Learnopengl/">Learnopengl</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h4 id="vs下freetype环境配置"><a href="#vs下freetype环境配置" class="headerlink" title="vs下freetype环境配置"></a>vs下freetype环境配置</h4><p>1.下载并解压freetype-2.10.2.tar.gz，放在项目适当的目录下</p>
<p>2.进入freetype-2.10.2&#x2F;builds&#x2F;windows&#x2F;vc2010，双击freetype.sln</p>
<p><img src="https://cdn.jsdelivr.net/gh/echo468/picgo@main/img/202306251139739.png" alt="image-20230625113913617"></p>
<p>3.在Win32位下，右键项目点击生成</p>
<p><img src="https://cdn.jsdelivr.net/gh/echo468/picgo@main/img/202306251138342.png" alt="image-20230625113841193"></p>
<p>4.如果生成成功，在freetype-2.10.2&#x2F;objs&#x2F;Win32&#x2F;Debug目录下会出现freetype.dll和freetype.lib</p>
<p><img src="https://cdn.jsdelivr.net/gh/echo468/picgo@main/img/202306251138526.png" alt="image-20230625113817362"></p>
<p>5.cmake项目时选择Visual Studio 15 2017而不是Visual Studio 15 2017（Win64），不然之后运行会找不到freetype.lib，lib的x86与目标项目的x64冲突。</p>
<p>6.将freetype.dll复制到项目生成的Debug目录下，否则之后运行会出错</p>
<p><img src="https://cdn.jsdelivr.net/gh/echo468/picgo@main/img/202306251140235.png" alt="image-20230625114033076"></p>
<p><img src="https://cdn.jsdelivr.net/gh/echo468/picgo@main/img/202306251141972.png" alt="image-20230625114100871"></p>
<p>7.右击项目，选择属性</p>
<p>配置属性-VC++目录-包含目录：源文件#include需要的头文件所在目录</p>
<p>D:\practice\case_learn\ogl-2.1_branch_tutorial\ogl-2.1_branch_tutorial\external\freetype-2.10.2\include</p>
<p>配置属性-VC++目录-库目录：lib&#x2F;dll所在的库目录（为了以防万一将该目录添加进环境变量）</p>
<p>D:\practice\case_learn\ogl-2.1_branch_tutorial\ogl-2.1_branch_tutorial\external\freetype-2.10.2\objs\Win32\Debug</p>
<p><img src="https://cdn.jsdelivr.net/gh/echo468/picgo@main/img/202306251150581.png" alt="image-20230625115053397"></p>
<p>链接器-输入-附加依赖项：添加freetype.lib（为了以防万一将文件目录写全，而不是只写freetype.lib）</p>
<p><img src="https://cdn.jsdelivr.net/gh/echo468/picgo@main/img/202306251154084.png" alt="image-20230625115426929"></p>
<p>8.准备好需要的字体文件.ttf，在需要freetype的源文件中添加如下两行：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ft2build.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> FT_FREETYPE_H  </span></span><br></pre></td></tr></table></figure>

 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
    </footer>
  </div>

    
 
   
</article>

    
    <article
  id="post-games101-22-Animation"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2023/05/22/games101-22-Animation/"
    >games101-22-Animation</a> 
</h2>
 

    </header>
     
    <div class="article-meta">
      <a href="/2023/05/22/games101-22-Animation/" class="article-date">
  <time datetime="2023-05-22T13:50:41.000Z" itemprop="datePublished">2023-05-22</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/games101/">games101</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h4 id="速度场"><a href="#速度场" class="headerlink" title="速度场"></a>速度场</h4><p>​		模拟单个粒子在速度场中的运动情况（速度场指的就是一种函数，在任意时刻t和位置x，都有对应的速度取值v(x,t)。速度场是一种理想化情况，实际上只能通过对物体进行受力分析得到加速度进而得到速度。粒子在不同起点会有不同的运动轨迹，切线方向即该点的速度方向。</p>
<img src="https://cdn.jsdelivr.net/gh/echo468/picgo@main/img/202305172305775.png" alt="image-20230517230558683" style="zoom: 67%;" />

<p>​		速度可以用路程对时间的一阶导数获得，因此求解下面方程即可获得对应时刻粒子的位置（上一次位置+位移）。这个方程只有一个变量t，因此是一阶常微分方程。</p>
<img src="https://cdn.jsdelivr.net/gh/echo468/picgo@main/img/202305172309233.png" alt="image-20230517230949140" style="zoom: 67%;" />

<p>​		如下使用欧拉方法（前向欧拉 显示欧拉）将时间离散化进行求解，Δt称为步长。用上一时刻的数据求解下一时刻。</p>
<img src="https://cdn.jsdelivr.net/gh/echo468/picgo@main/img/202305172313259.png" alt="image-20230517231357154" style="zoom: 50%;" />

<p>​		可以通过减小步长来减小误差（增加时间步长，误差会不断积累）：</p>
<img src="https://cdn.jsdelivr.net/gh/echo468/picgo@main/img/202305172314099.png" alt="image-20230517231432970" style="zoom:67%;" />

<p>​		但是该方法具有不稳定性，不稳定是指无论如何减小Δt，有一些情况始终无法通过模拟得到。如下两种情况，场中的曲线是在不同位置理想的运动轨迹，切线方向是速度。细微的影响会被无限放大。</p>
<img src="https://cdn.jsdelivr.net/gh/echo468/picgo@main/img/202305172316050.png" alt="image-20230517231617880" style="zoom: 67%;" />

<h5 id="中点法-x2F-修正欧拉"><a href="#中点法-x2F-修正欧拉" class="headerlink" title="中点法&#x2F;修正欧拉"></a>中点法&#x2F;修正欧拉</h5><p>​		首先在某一个位置根据该位置的速度用显示欧拉计算出下一个位置在a，取a和初始点的中点b的速度作为初始点的速度，用显示欧拉再计算一次下一个位置，得到点c。用二次项进行模拟，更加准确。</p>
<img src="https://cdn.jsdelivr.net/gh/echo468/picgo@main/img/202305172344969.png" alt="image-20230517234452830" style="zoom: 67%;" />

<h5 id="自适应改变步长方法"><a href="#自适应改变步长方法" class="headerlink" title="自适应改变步长方法"></a>自适应改变步长方法</h5><p>​		首先在某一个位置根据该位置的速度用显示欧拉计算出下一个位置在a，将Δt分成两个Δt&#x2F;2，在第一个Δt&#x2F;2的位置，用该位置的速度和Δt&#x2F;2的时间计算出位置在b。对比a和b，若小于误差阈值则无需继续细分步长, 若大于则继续细分步长。效果更好，但是可能需要更小的步长。</p>
<p><img src="https://cdn.jsdelivr.net/gh/echo468/picgo@main/img/202305180002029.png" alt="image-20230518000231928"></p>
<h5 id="隐式方法"><a href="#隐式方法" class="headerlink" title="隐式方法"></a>隐式方法</h5><p>​		该方法是用未来的一些量（速度、加速度）来求解这个时刻的位移。计算复杂。</p>
<img src="https://cdn.jsdelivr.net/gh/echo468/picgo@main/img/202305180007709.png" alt="image-20230518000753635" style="zoom:67%;" />

<h5 id="如何量化稳定性"><a href="#如何量化稳定性" class="headerlink" title="如何量化稳定性"></a>如何量化稳定性</h5><p>​		 使用局部误差（每一步）和总累积误差（整体）判断稳定性。但是比起这两个绝对值，与步长的阶数的关系更值得探究。例如隐式欧拉的阶数为 1，这意味着局部截断误差O(h^2) ，全局截断误差O(h) （h 是步长，即 Δt）。对O(h) 的理解：如果将 h 减半，预期误差也会减半。对O(h^2) 的理解：如果将 h 减半，预期误差也会减1&#x2F;4。阶数越高，效果越好。</p>
<h5 id="Runge-Kutta-Families"><a href="#Runge-Kutta-Families" class="headerlink" title="Runge-Kutta Families"></a>Runge-Kutta Families</h5><p>​		求解 ODE 的一系列高级方法，特别擅长处理非线性。它的四阶版本是使用最广泛的版本，即 RK4。用更复杂的方法更新位置。</p>
<img src="https://cdn.jsdelivr.net/gh/echo468/picgo@main/img/202305180043977.png" alt="image-20230518004327829" style="zoom:67%;" />

<h5 id="刚体模拟"><a href="#刚体模拟" class="headerlink" title="刚体模拟"></a>刚体模拟</h5><p>​		刚体不会发生形变，运动时内部所有点按照同一种方式运动。类似于模拟大量粒子，但是要考虑更多属性。</p>
<img src="https://cdn.jsdelivr.net/gh/echo468/picgo@main/img/202305180047864.png" alt="image-20230518004753600" style="zoom:67%;" />

<h4 id="Position-Based-x2F-Verlet-Integration"><a href="#Position-Based-x2F-Verlet-Integration" class="headerlink" title="Position-Based &#x2F; Verlet Integration"></a>Position-Based &#x2F; Verlet Integration</h4><p>​		不是基于物理的方法，用一些规则调整位置。没有能量守恒的性质，不基于物理计算速度快。</p>
<h5 id="流体模拟"><a href="#流体模拟" class="headerlink" title="流体模拟"></a>流体模拟</h5><p>（1）假设水是由无数小的刚体球体组成</p>
<p>（2）假设水无法被压缩，即任意处水的密度相等</p>
<p>（模拟和渲染分开进行）</p>
<p>​		要知道水的任意处密度发生了改变，就需要改变刚体球体的位置来修正这一部分的密度（梯度下降）；需要知道任意一个点的密度关于每一个刚体小球位置的导数，也就是和每一个刚体小球的位置变化会如何影响该点密度。如果小球距离该点位置越远，影响就越小。需要加入有关能量损失的方法，使得最后的运动可以停下。</p>
<h4 id="Eulerian-vs-Lagrangian"><a href="#Eulerian-vs-Lagrangian" class="headerlink" title="Eulerian vs. Lagrangian"></a>Eulerian vs. Lagrangian</h4><p>模拟大规模物质：</p>
<p>拉格朗日质点法（依次模拟空间中每个粒子，也需要考虑相互作用）</p>
<p>网格法（将空间划分为不同格子，考虑不同格子的运动和密度变化）</p>
<p>MPM：将上述两种方法结合</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
    </footer>
  </div>

    
 
   
</article>

    
    <article
  id="post-games101-21-Animation"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2023/05/21/games101-21-Animation/"
    >games101-21-Animation</a> 
</h2>
 

    </header>
     
    <div class="article-meta">
      <a href="/2023/05/21/games101-21-Animation/" class="article-date">
  <time datetime="2023-05-21T01:38:11.000Z" itemprop="datePublished">2023-05-21</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/games101/">games101</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h4 id="动画"><a href="#动画" class="headerlink" title="动画"></a>动画</h4><p>将场景模型表示为时间的函数, 输出：当顺序查看时提供运动感的图像序列</p>
<p>• 电影：每秒 24 帧</p>
<p>• 视频（一般）：30 fps</p>
<p>• 虚拟现实：90 fps</p>
<h5 id="动画历史"><a href="#动画历史" class="headerlink" title="动画历史"></a>动画历史</h5><p>•1931，Phenakistoscope圆盘，通过转动圆盘来做动画（右边是可见的窗口，通过旋转时钟，能在窗口看到不同的动作，从而形成动画）</p>
<img src="https://cdn.jsdelivr.net/gh/echo468/picgo@main/img/202305151023040.png" alt="image-20230515102349693" style="zoom:50%;" />

<p>•1878，第一部电影Sallie Gardner，早期电影用来做科学研究，而不是用来娱乐</p>
<p>•1937，第一部剧场版手绘电影-白雪公主与七个小矮人（每秒24帧）</p>
<p>•1963，第一个计算机生成的动画</p>
<p>•1972，早期计算机动画 — 人脸动画</p>
<p>•1993，侏罗纪公园（里程碑作品,电脑生成的恐龙直接使用在电影里）</p>
<p>•1995，玩具总动员，第一部完全计算机生成的CG动画电影(用的光栅化方法)</p>
<h5 id="Keyframe-Animation关键帧动画"><a href="#Keyframe-Animation关键帧动画" class="headerlink" title="Keyframe Animation关键帧动画"></a>Keyframe Animation关键帧动画</h5><p>​		关键帧定义整个动画的走向，早期由最厉害的艺术家画出关键帧，再让助手把中间的过程补齐。（如软件flash可以通过关键帧自动生成中间的过度）</p>
<img src="https://cdn.jsdelivr.net/gh/echo468/picgo@main/img/202305150957430.png" alt="image-20230515095720277" style="zoom: 67%;" />

<p>​		该方法的本质是插值。例如找到第k帧各个顶点的位置，再找到k+1帧各个顶点的位置，插值中二者中间过程的顶点位置。</p>
<img src="https://cdn.jsdelivr.net/gh/echo468/picgo@main/img/202305151000646.png" alt="image-20230515100020509" style="zoom:67%;" />

<p>​		但是插值不是简单的线性插值，如果是线性插值，其结果是折线，但是很多时候需要曲线（如可能需要通过样条的方法）。</p>
<img src="https://cdn.jsdelivr.net/gh/echo468/picgo@main/img/202305151001080.png" alt="image-20230515100139977" style="zoom:50%;" />

<h5 id="Physical-Simulation物理模拟-x2F-仿真"><a href="#Physical-Simulation物理模拟-x2F-仿真" class="headerlink" title="Physical Simulation物理模拟&#x2F;仿真"></a>Physical Simulation物理模拟&#x2F;仿真</h5><p>​		牛顿定律，知道加在物体上的力就可以获得加速度，从而获得速度和新的位置（已知一些初始条件，如开始的位置、速度），来动态更新位置。</p>
<img src="https://pic1.zhimg.com/80/v2-0d8447cded709d389189acc62d085abc_720w.webp" alt="img" style="zoom: 33%;" />

<p>​		该方法通过正确建立真实的受力模型来模拟出真实的动画系统。如布料模拟、流体模拟，头发（重力，头发间的摩擦力，风力）。</p>
<p>​		布料可以视为三角形网格，对于每个点，有自己的重力和来自其他点的拉力。建立相互作用力，从而模拟正确效果（模拟得不好，就有反物理现象：比如穿模，布料穿过人体模型）。如下图，布料可以看成质点弹簧网：</p>
<img src="https://cdn.jsdelivr.net/gh/echo468/picgo@main/img/202305151009986.png" alt="image-20230515100952739" style="zoom:50%;" />

<img src="https://cdn.jsdelivr.net/gh/echo468/picgo@main/img/202305151038667.png" alt="image-20230515103857485" style="zoom:50%;" />

<p>​		在流体模拟中，先模拟这些水是怎么运动的，水滴在各种地方是怎么形成的；模拟了水的位置、形状等之后，拿去渲染，得出最后的结果。</p>
<h5 id="Mass-Spring-System质点弹簧系统-（最简单，也非常实用的系统）"><a href="#Mass-Spring-System质点弹簧系统-（最简单，也非常实用的系统）" class="headerlink" title="Mass Spring System质点弹簧系统 （最简单，也非常实用的系统）"></a>Mass Spring System质点弹簧系统 （最简单，也非常实用的系统）</h5><p>​		质点弹簧系统是一系列相互连接的质点和弹簧。最基本的单元：一个弹簧，左右各连着一个质点。假设理想化的弹簧没有初始长度，只考虑拉伸的情况。对于a来说，弹簧对a的力从a指向b，弹力大小和ab的距离成正比，所以此处b-a是一个向量，表示了力的大小和方向，ks是弹簧系数。</p>
<img src="https://cdn.jsdelivr.net/gh/echo468/picgo@main/img/202305151039537.png" alt="image-20230515103947449" style="zoom:50%;" />

<p>​		在实际情况下，弹簧有初始长度。弹力大小和拉伸的长度成正比，所以弹力大小用（||b-a||-l）表示，弹力方向用a指向b的单位向量表示。但是由于没有能量损失，动力和势力会相互转换，拉伸后的弹簧会不断震荡而不会最终停止。因此，弹簧系统需要添加阻力。</p>
<img src="https://cdn.jsdelivr.net/gh/echo468/picgo@main/img/202305151102397.png" alt="image-20230515110202293" style="zoom:50%;" />

<p>​		计算机图形学中，如果x表示为位移，x上一点是速度（一阶导数）点两个点是加速度（二阶导数）。如果按照如下方式定义阻力，对于b来说，b的阻力与速度相反，速度越大阻力越大。kd是阻尼系数，速度定义了力的大小和方向。引入阻尼的目的是让震荡的弹簧不会永远震荡下去，会因为阻尼的存在而停下，弹簧长度恢复到原长。目前引入的阻尼确实能达到目的，但还会阻止一个处于常态的弹簧的一切非震荡运动。比如弹簧两端相对静止，但是处于自由落体状态，都有向下的速度，则此阻尼力会使其落得越来越慢，这不正常。</p>
<img src="https://cdn.jsdelivr.net/gh/echo468/picgo@main/img/202305151429644.png" alt="image-20230515142929565" style="zoom:50%;" />

<p>​		完整公式如下，f只与相对速度大小有关（也就是弹簧长度发生变化才有阻力），而与弹簧拉伸长度无关。如下对于b来说，阻力从b指向a，所以要添加-号，之后一项表示方向。红色点乘表示力的大小，b-a是相对速度大小，点乘后为该速度在a到b方向上的投影（对于ab不伸长的圆周运动，作用在b上的力垂直于ab，在ab方向上的投影为0，此时无阻力）。</p>
<img src="https://cdn.jsdelivr.net/gh/echo468/picgo@main/img/202305151112803.png" alt="image-20230515111251697" style="zoom: 50%;" />

<p>​		单个模型可以组成更复杂的模型：</p>
<img src="https://cdn.jsdelivr.net/gh/echo468/picgo@main/img/202305151134053.png" alt="image-20230515113408957" style="zoom:50%;" />

<p>​		布料可以抵抗切变，但是如下模型不能抵抗切变（当有如下两个力拉动时，两端会被拉伸，中间会向内部收缩）。以及布料能力对抗“折”的力，例如纸很容易对折：</p>
<img src="https://cdn.jsdelivr.net/gh/echo468/picgo@main/img/202305151148629.png" alt="image-20230515114817530" style="zoom:50%;" />

<p>​		这种结构将抵抗切变, 当中间想往里收缩时，中间的弹簧因为阻力会阻碍收缩。但具有各向异性偏差(朝↖拉有弹簧,↗无)不对称, 也不会抵抗平面外弯曲，比如右上角和左下角可以对折（且不改变弹簧形状）。</p>
<img src="https://cdn.jsdelivr.net/gh/echo468/picgo@main/img/202305151242052.png" alt="image-20230515124234960" style="zoom:67%;" />

<p>​		这种结构将抵抗切变, 方向偏差较小, 也无法抵抗平面外弯曲，因为可以沿着竖线或者横线对折。</p>
<img src="https://cdn.jsdelivr.net/gh/echo468/picgo@main/img/202305151243715.png" alt="image-20230515124344616" style="zoom: 67%;" />

<pre><code>     这种结构将抵抗切变, 方向偏差较小, 也可以抵抗平面外弯曲。相比青色弹簧, 红色的弹簧相连接的力应该弱得多 (因为青色相连代表布的韧性, 红色则代表布放在桌边, 布会自然下垂, 红色线就会被拉扯)，所以不能只用红线，红线只是辅助作用。
</code></pre>
<img src="https://cdn.jsdelivr.net/gh/echo468/picgo@main/img/202305151244150.png" alt="image-20230515124450068" style="zoom:67%;" />

<p>​		如可以用质点弹簧裙子+人物，有时会采用更好的有限元法FEM代替弹簧系统。</p>
<h5 id="粒子系统"><a href="#粒子系统" class="headerlink" title="粒子系统"></a>粒子系统</h5><p>​		用大量的粒子模拟，例如模拟流体、灰尘等。定义每一个粒子受到的力从而定义粒子运动，例如重力、粒子间的相互作用力（如碰撞、引力等，对于引力需要找到粒子周围最近的一些粒子，但是粒子间的位置会不断改变，因此计算较为复杂）、或者粒子很小可能具有风给的浮力。粒子越多模拟的越精细，但是计算量更大。粒子除了模拟点（如水滴），还可以模拟一大群中的一个个体，如鸟群中的一个鸟。本质是在定义个体和群体的关系。</p>
<p>对于动画中的每一帧，粒子系统大概制作过程：</p>
<p>① [如果需要] 创建新的粒子</p>
<p>② 计算作用于每个粒子的力（决定了最后的效果，如根据万有引力考虑粒子间的引力）</p>
<p>③ 更新每个粒子的位置和速度（通过受力解出位置和速度）</p>
<p>④ [如果需要] 去除死粒子</p>
<p>⑤ 渲染粒子</p>
<p>对于渲染鸟群：</p>
<img src="https://cdn.jsdelivr.net/gh/echo468/picgo@main/img/202305151303288.png" alt="image-20230515130332172" style="zoom:80%;" />

<p>① 对邻居中心的吸引力(不离群)</p>
<p>② 来自个别邻居的排斥力(不靠太近)</p>
<p>③ 与邻居的平均轨迹对齐(一起飞)</p>
<h5 id="运动学"><a href="#运动学" class="headerlink" title="运动学"></a>运动学</h5><p>（1）正向运动学</p>
<p>​		可以创作骨骼动画，如下图先定义拓扑关系（结构间的连接关系），树状结构等（此处不做详细讨论），再定义连接类型：Pin（平面上的旋转）、Ball(空间内的旋转)、Prismatic joint（平移）。</p>
<img src="https://cdn.jsdelivr.net/gh/echo468/picgo@main/img/202305151308038.png" alt="image-20230515130844902" style="zoom:67%;" />

<p>​		例如有两部分构成的手臂，第一部分旋转θ1，第二部分旋转θ2，问端点p的位置在哪？计算方法非常简单，说明只要定义好骨骼连接方式，任何时刻只要知道角度，就能算出尖端p应该停在哪里。</p>
<img src="https://cdn.jsdelivr.net/gh/echo468/picgo@main/img/202305151452811.png" alt="image-20230515145235688" style="zoom:67%;" />

<p>​		动画被描述为作为时间函数的角度参数值。已知根据时间两个角度值的变换，就可以知道任何时间点的位置，从而创建出动画。该方法的优点是实施很简单，动画可能和实际物理不太一致使得动画创作者耗时。</p>
<img src="https://cdn.jsdelivr.net/gh/echo468/picgo@main/img/202305151453433.png" alt="image-20230515145308329" style="zoom:67%;" />

<p>（2）逆向运动学</p>
<p>​		实现如抓住手移动使得整个手臂跟着移动的动画。</p>
<img src="https://cdn.jsdelivr.net/gh/echo468/picgo@main/img/202305151457892.png" alt="image-20230515145720652" style="zoom:50%;" />

<p>​		也就是通过控制尖端位置，反算出应该旋转多少。动画师提供末端执行器的位置p：</p>
<img src="https://cdn.jsdelivr.net/gh/echo468/picgo@main/img/202305151500023.png" alt="image-20230515150008918" style="zoom: 50%;" />

<p>​		计算机必须算出满足约束的关节角度：</p>
<img src="https://cdn.jsdelivr.net/gh/echo468/picgo@main/img/202305151500743.png" alt="image-20230515150034617" style="zoom: 50%;" />

<p>​		会出现的问题是，对于同一个位置p，可能有多组解：</p>
<table>
<thead>
<tr>
<th align="right"><img src="https://cdn.jsdelivr.net/gh/echo468/picgo@main/img/202305151501651.png" alt="image-20230515150156467"  /></th>
<th><img src="https://cdn.jsdelivr.net/gh/echo468/picgo@main/img/202305151502680.png" alt="image-20230515150215565"></th>
</tr>
</thead>
<tbody><tr>
<td align="right"></td>
<td></td>
</tr>
</tbody></table>
<p>​		还可能出现没有解的情况，如下图顶点p到达不了第三个半圆外和第一个半圆内：</p>
<img src="https://cdn.jsdelivr.net/gh/echo468/picgo@main/img/202305151503053.png" alt="image-20230515150302939" style="zoom: 67%;" />

<p>​		对于上述情况有多种优化方式。</p>
<h5 id="Rigging绑定"><a href="#Rigging绑定" class="headerlink" title="Rigging绑定"></a>Rigging绑定</h5><p>​		一种对角色更高层次的控制，允许更快速且直观的调整姿势、表情等。类似提线木偶，是逆运动学的一种应用。在角色身体、脸部等位置创造一系列控制点，艺术家通过调整控制点的位置，带动脸部其他从点移动，从而实现表情变化，动作变化等（类似贝塞尔曲线）。缺点：需要艺术能力也需要技术，全手工制作费时费力费钱。</p>
<img src="https://cdn.jsdelivr.net/gh/echo468/picgo@main/img/202305151514964.png" alt="image-20230515151414884" style="zoom:67%;" />

<h5 id="Blend-Shapes"><a href="#Blend-Shapes" class="headerlink" title="Blend Shapes"></a>Blend Shapes</h5><p>​		类似关键帧动画，给定两个时间的两个状态，对于每一个控制点进行插值。</p>
<h5 id="Motion-Capture"><a href="#Motion-Capture" class="headerlink" title="Motion Capture"></a>Motion Capture</h5><p>​		在真人身上放置许多控制点，在不同时刻对人进行拍照，记录控制点的位置，同步到对应的虚拟人物上。真实感很强，比起用计算机调节，可以迅速获得大量数据。但是昂贵，准备工作麻烦。捕捉的动画跟预期艺术需要不太符合，需要调整，以及控制点被遮挡问题。很多控制控制点的方法，有些方法也可以避免控制点遮挡。</p>
<img src="https://cdn.jsdelivr.net/gh/echo468/picgo@main/img/202305151524557.png" alt="image-20230515152447453" style="zoom:67%;" />

<p>​		众多动捕设备中最常用的还是光学动捕设备，在人身上贴光学贴片。最重要的被遮挡问题，可以通过增加摄像机等方法避免</p>
<img src="https://cdn.jsdelivr.net/gh/echo468/picgo@main/img/202305151525261.png" alt="image-20230515152558181" style="zoom:67%;" />

<p>​		得到的数据是每个控制点在三维空间中的运动数据。</p>
<img src="https://cdn.jsdelivr.net/gh/echo468/picgo@main/img/202305151526281.png" alt="image-20230515152621228" style="zoom:67%;" /> 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
    </footer>
  </div>

    
 
   
</article>

    
    <article
  id="post-games101-20-Color-Perception"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2023/05/20/games101-20-Color-Perception/"
    >games101-20-Color_Perception</a> 
</h2>
 

    </header>
     
    <div class="article-meta">
      <a href="/2023/05/20/games101-20-Color-Perception/" class="article-date">
  <time datetime="2023-05-20T12:04:20.000Z" itemprop="datePublished">2023-05-20</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/games101/">games101</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h4 id="光场"><a href="#光场" class="headerlink" title="光场"></a>光场</h4><p>​		我们看到这个三维世界，在人眼里类似就是一幅二维的图 ，那如果直接看到一幅图，这幅图完全记录了之前看到的光线信息，也能得到同样的结果（类似虚拟现实设备的应用）</p>
<img src="https://cdn.jsdelivr.net/gh/echo468/picgo@main/img/202305142021885.png" alt="image-20230514202102820" style="zoom:67%;" />

<h5 id="全光函数"><a href="#全光函数" class="headerlink" title="全光函数"></a>全光函数</h5><p>​		假设在一个场景中，位置固定，可以四面八方地去看，则用极坐标可以定义看的方向，全光函数描述了向某个方向看会看到什么样的值：</p>
<img src="https://cdn.jsdelivr.net/gh/echo468/picgo@main/img/202305142022397.png" alt="image-20230514202215347" style="zoom: 67%;" />

<p>​	引入波长（引入不同的颜色）：</p>
<img src="https://cdn.jsdelivr.net/gh/echo468/picgo@main/img/202305142023512.png" alt="image-20230514202302428" style="zoom:67%;" />

<p>​	引入时间t，类似电影，在不同时间显示不同的东西：</p>
<img src="https://cdn.jsdelivr.net/gh/echo468/picgo@main/img/202305142025475.png" alt="image-20230514202540398" style="zoom:67%;" />

<p>​		人可以站在任何位置，在任何位置往任何方向看在任何时间看到所有的颜色，即看到的整个世界：</p>
<img src="https://cdn.jsdelivr.net/gh/echo468/picgo@main/img/202305142024090.png" alt="image-20230514202420012" style="zoom:67%;" />

<p>​		可以从全光函数中提取一部分信息出来，表示更复杂的光的信息，这个概念比在一个点各个方向的光信息更多，首先来定义光线。前两个维度是方向，后三个维度是起点位置（也可以通过两点确定一条直线来定义光线）：</p>
<img src="https://cdn.jsdelivr.net/gh/echo468/picgo@main/img/202305142028598.png" alt="image-20230514202839568" style="zoom:67%;" />

<p>​		要记录一个物体向四周展示的样子，只需要记录包围盒上表面各个点往各个方向发射的光线的信息，也就是记录了其光场信息（在物体表面任何一个位置去向任何一个方向的光线强度）。当相机看向物体，两点确定一条光线，可以查询该光线的信息 。物体的表面是二维的（根据纹理坐标的原理），方向也是二维的（用两个角度定义），所以用这个四个信息当变量的函数就是光场（全光函数的一部分只有位置和方向）。</p>
<img src="https://cdn.jsdelivr.net/gh/echo468/picgo@main/img/202305142034612.png" alt="image-20230514203419565" style="zoom:50%;" />

<p>​		记录下物体的光场后，就可以根据摄像机的位置和摄像机看向物体哪一点（相机可以看见很多点，因为视锥体是一个区域），连接一个光线，查询其相应的光线强度（记录了物体任意一个点朝任意一个方向的光场强度）</p>
<img src="https://cdn.jsdelivr.net/gh/echo468/picgo@main/img/202305142042946.png" alt="image-20230514204228880" style="zoom: 33%;" />

<p>​		还可以理解成取一个平面，平面右边是一个物体，它的光会穿过这个平面来到左边，我们不需要知道右边有什么，只需要知道对于平面上任意一个点的任意一个方向会发出什么（就好比在最初的例子中，看一个平面和看窗外的几何体效果相同，注意相机在平面外侧）</p>
<img src="https://cdn.jsdelivr.net/gh/echo468/picgo@main/img/202305142052842.png" alt="image-20230514205203793" style="zoom: 50%;" />

<p>​		通过定义一个平面上点和角度，也可以定义两个平面上的点，通过两个坐标信息来表示一个光线，这是一个经典的参数化表示的方法。用两个平面来定义光场，便于降维也就是从上面的 位置+方向 变成 位置+位置 两个平面两点一连就得到一个光线。</p>
<img src="https://cdn.jsdelivr.net/gh/echo468/picgo@main/img/202305142052186.png" alt="image-20230514205246138" style="zoom:50%;" />

<p>​		</p>
<pre><code>    现实中也有人用第一种方式记录光场
</code></pre>
<p>这样参数化有两种理解方式</p>
<ul>
<li>a. 一种是固定(u,v)(<em>u</em>,<em>v</em>), 所有的(s,t)(<em>s</em>,<em>t</em>)组成一张图，也就是从(u,v)点看到的外部世界的样子</li>
<li>b. 另一种是固定(s,t)(<em>s</em>,<em>t</em>), 所有的(u,v)(<em>u</em>,<em>v</em>)组成一张图，也就是显示从不同方向看同一个点的样子</li>
</ul>
<p>相当于不同的位置(u, v)，拍摄同一张图(s,t)</p>
<img src="https://cdn.jsdelivr.net/gh/echo468/picgo@main/img/202305142108397.png" alt="image-20230514210849259" style="zoom: 67%;" />

<img src="https://cdn.jsdelivr.net/gh/echo468/picgo@main/img/202305142109272.png" alt="image-20230514210951197" style="zoom:50%;" />

<p>自然界中苍蝇的复眼就是类似于第二种理解<br>我们在照片中任意一个像素记录的是irradiance，不区分方向，但是对于复眼来说，它们记录的分光之后的分量，也就是记录的是radiance</p>
<p>微透镜原理：把一个pixel替换成透镜，可以把来自于不同方向的光分开再记录下来<br>支持后期聚焦（可以先拍照再调焦）<br>光场camera的原理：（其实就是光场的原理）</p>
<p>光场照相机的图怎么还原成普通相机呢？<br>我们把分散的光，每个透镜都选一条，然后把得到的结果都记录在一个像素的结果上，现在一个透镜就对应一个值了，和之前一样<br>选光线的步骤就相当于是重新聚焦，虚拟地移动相机的位置<br>我们不涉及重新聚焦具体怎么做，只介绍思想，我们从四维光场中按需查询选取光线</p>
<p>光场照相机的问题：<br>分辨率不足，因为原来一个位置可能只需要一个像素，但是透镜把光分开以后，可能会需要好几个像素来记录不同方向的光，同样的胶片尺寸下，光场相机的分辨率不足<br>高成本、难设计<br>再次体现trade-offs</p>
<h4 id="颜色"><a href="#颜色" class="headerlink" title="颜色"></a>颜色</h4><p>​		太阳光被折射成不同的颜色-太阳光由多种波长的光组成，不同波长的光有不同的折射率。</p>
<p>​		一种光对应一个光谱，就是光的能量在不同波长上的分布。波长越小频率越高。在图形学中主要关心可见光光谱（波长大约在400nm到700nm）。光谱也叫做SPD普功率密度，光在不同波长有不同的强度。</p>
<img src="https://cdn.jsdelivr.net/gh/echo468/picgo@main/img/202305142343407.png" alt="image-20230514234310285" style="zoom:67%;" />

<p>​		不同光有不同的光谱，也就是不同的普功率密度：</p>
<img src="https://cdn.jsdelivr.net/gh/echo468/picgo@main/img/202305142342803.png" alt="image-20230514234258648" style="zoom:67%;" />

<p>​		普功率密度有线性性质，两种光一起照射的谱功率密度等于两种光单独照射的普功率密度之和。</p>
<img src="https://cdn.jsdelivr.net/gh/echo468/picgo@main/img/202305142342560.png" alt="image-20230514234246453" style="zoom: 67%;" />

<p>​		颜色是人的感知，它不是光的一种根本的属性，也就是波长不是颜色。人的眼睛类似一个摄像机，晶状体类似透镜，视网膜类似于成像的地方（光最终达到的地方），瞳孔类似光圈。</p>
<img src="https://cdn.jsdelivr.net/gh/echo468/picgo@main/img/202305142342540.png" alt="image-20230514234226356" style="zoom: 67%;" />

<p>​		视网膜具有如下两种细胞：</p>
<p>​		（1）杆细胞（Rods cells）：棒状，数量多，只感知光的强度而非颜色</p>
<p>​		（2）视锥细胞（Cones cells）：锥形，数量少，用来感知颜色</p>
<p>​		（3）视锥细胞又被分为S, M, L三种，用来感知不同波长的光，三种细胞对不同波长的光的相应能力不同，如下是三种细胞对光的相应曲线：</p>
<img src="https://cdn.jsdelivr.net/gh/echo468/picgo@main/img/202305142341831.png" alt="image-20230514234136685" style="zoom: 67%;" />

<p>​		不同的人这三种视锥细胞分布非常不同，所以对于相同的光，感知不同，看到的结果也不同，因此颜色是人的感知。</p>
<img src="https://cdn.jsdelivr.net/gh/echo468/picgo@main/img/202305142347634.png" alt="image-20230514234741409" style="zoom:67%;" />

<p>​		人眼无法测量，大脑也无法接收有关每种光波长的信息（已经被积分掉了），光谱到视网膜上，眼形成3个响应值(S,M,L)(<em>S</em>,<em>M</em>,<em>L</em>)并最终由大脑接受。不同视锥细胞感知结果的计算方式如下：假如一个光的光谱分布在430-490，通过光谱获得光在430波长的强度，通过下图获得S细胞对430波长的感知数，二者相乘，在从430积分到490，就获得S细胞对这个光的感知结果，以此类推获得M值和L值。</p>
<img src="https://cdn.jsdelivr.net/gh/echo468/picgo@main/img/202305142356418.png" alt="image-20230514235619301" style="zoom: 67%;" />

<p>​		同色异谱是指两个不同的光谱，它们最终投射到相同的(S,M,L)响应值（也就是两种不一样的光谱最后的积分结果相同）。如下四种光能被人感知相同的结果：</p>
<img src="https://cdn.jsdelivr.net/gh/echo468/picgo@main/img/202305150012650.png" alt="image-20230515001230547" style="zoom:67%;" />

<p>​		同色异谱会导致人感知到相同的颜色，其存在对于色彩再现至关重要，这个过程也叫颜色匹配(Color Matching)过程。一个例子：同色异谱使得只有三种颜色的显示器上可以再现真实场景的感知颜色，即使他们波谱完全不同，也能被人眼感知为相同的颜色。</p>
<img src="https://cdn.jsdelivr.net/gh/echo468/picgo@main/img/202305150014184.png" alt="image-20230515001406059" style="zoom: 67%;" />

<p>颜色混合</p>
<p>​		我们认为计算机中使用的成像系统是加色系统 Additive Color。给定三种原色 $s _ { R } ( X ) , s _ { G } ( X ) , s _ { B } ( X )$，调整这些原色的强度，将他们混合在一起 $Rs _ { R } ( X ) + Gs _ { G } ( X ) +Bs _ { B } ( X )$。利用混合三种颜色的系数来描述颜色 R*,<em>G</em>,*B。加色系统很多颜色都可以通过三原色混合合成。但是有的颜色怎么都混合不出来，这时候的系数可能是负的（因为是加色系统值不能为负数，所以只能给左边要匹配的颜色加）：</p>
<img src="https://cdn.jsdelivr.net/gh/echo468/picgo@main/img/202305150023574.png" alt="image-20230515002342430" style="zoom:67%;" />

<p>​		CIE是一个组织，它们定义了RGB的系统，与之前的加色匹配设置相同，只有三种原色，但原色和测试光都是单波长的光，通过测试来测量多少强度的三种原色加起来与测试光相同。</p>
<img src="https://cdn.jsdelivr.net/gh/echo468/picgo@main/img/202305150027057.png" alt="image-20230515002704933" style="zoom:67%;" />

<p>​		如下的颜色匹配函数描述了每个 CIE RGB 原色光各自多少强度相加起来才能匹配 x 轴上给定波长的单色光（红色部分确实会存在负数）。每一列得到的是对应的是单一波长的光，但是现实的光线SPD是很多波长组合在一起的，所以在表示现实颜色时要把每一个波长都考虑进去，要使用积分表示。</p>
<img src="https://cdn.jsdelivr.net/gh/echo468/picgo@main/img/202305150027494.png" alt="image-20230515002718396" style="zoom:67%;" />

<p>​		标准sRGB，是一种被广泛运用于各种设备的色彩系统，但是RGB所能形成的色域是有限的。</p>
<p>​		CIE XYZ系统不是实验得到的，而是人造的，认为规定某个单波长光由多少红绿蓝组成。这个系统使用XYZ表示颜色，红色区域不再存在负数，并且由于绿色部分在轴上分布比较均匀，Y也表示亮度，与RGB的区别其实就是匹配函数的不同。</p>
<p><img src="https://cdn.jsdelivr.net/gh/echo468/picgo@main/img/202305150048100.png" alt="image-20230515004845995"></p>
<p>​		如果想要把XYZ系统表示的颜色都可视化显示出来，需要将这些三维的数表示成二维，要使用归一化，又由于Y表示亮度，可以将其固定下来，这样就可以得到了xy图，这就是色域。纯的颜色都在边界，接近单波，白色是最不纯的颜色。</p>
<img src="https://cdn.jsdelivr.net/gh/echo468/picgo@main/img/202305150053890.png" alt="image-20230515005305748" style="zoom:67%;" />

<p>​		不同色彩空间所覆盖的色域范围也有所区别，它们能表示的颜色范围各不相同：</p>
<img src="https://cdn.jsdelivr.net/gh/echo468/picgo@main/img/202305150056381.png" alt="image-20230515005605185" style="zoom:67%;" />

<p>​		HSV色彩空间被广泛地运用于颜色选择器（色调、饱和度（越饱和越接近单波）、亮度）</p>
<img src="https://cdn.jsdelivr.net/gh/echo468/picgo@main/img/202305150102860.png" alt="image-20230515010248637" style="zoom:67%;" />

<p>​		CIE还有一种Lab色彩空间。L为亮度、a表示红绿、b表示蓝黄，这个空间认为轴的两端都是互补色。互补色是通过实验得到的，可以通过视觉暂留效果验证。</p>
<img src="https://cdn.jsdelivr.net/gh/echo468/picgo@main/img/202305150103720.png" alt="image-20230515010340610" style="zoom:67%;" />

<p>CMYK是一种减色系统 CMYK: A Subtractive Color Space</p>
<ul>
<li>CMYK用的是靛蓝、品红、黄色、黑色 Cyan, Magenta, Yellow, and Key</li>
<li>CMYK系统在印刷时很常见 Widely used in printing</li>
<li>通过混合CMY可以得到黑色，但是由于打印成本原因，黑色墨水成本低需求大，故存在黑色 黑色墨水好造</li>
</ul>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
    </footer>
  </div>

    
 
   
</article>

    
    <article
  id="post-games101-19-Cameras"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2023/05/19/games101-19-Cameras/"
    >games101-19-Cameras</a> 
</h2>
 

    </header>
     
    <div class="article-meta">
      <a href="/2023/05/19/games101-19-Cameras/" class="article-date">
  <time datetime="2023-05-19T10:33:50.000Z" itemprop="datePublished">2023-05-19</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/games101/">games101</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h4 id="成像"><a href="#成像" class="headerlink" title="成像"></a>成像</h4><p>1.存在的物体：捕捉</p>
<p>2.不存在的合成的物体：光栅化和光追</p>
<p>​		传感器用于捕捉并记录光。</p>
<img src="https://cdn.jsdelivr.net/gh/echo468/picgo@main/img/202305121852319.png" alt="image-20230512185246238" style="zoom:67%;" />

<p>​		感光元件不能直接与光源接触，感光元件不区分来自各个方向的光，所以感光元件上任意一个点都会混合来自各个方向的光。</p>
<img src="https://cdn.jsdelivr.net/gh/echo468/picgo@main/img/202305121854905.png" alt="image-20230512185420851" style="zoom:67%;" />

<p>​		针孔相机拍出来的结果不会出现虚化。</p>
<h4 id="FOV视场"><a href="#FOV视场" class="headerlink" title="FOV视场"></a>FOV视场</h4><p>​		视场分为水平和竖直，此处以竖直为例，并且此处不考虑棱镜只考虑针孔摄像机。视场大小受传感器的大小和传感器与小孔的距离也就是焦距影响。市场对于焦距的定义，都是以传感器35mm为标准。在此标准下，每一个焦距都对应一个视场：17mm-104°；50mm-47°；200mm-12°。以手机为例，如果手机写的焦距为28mm（然而手机厚度并没有28mm，实际焦距会更小），手机通过减小传感器大小，来等效35mm传感器28mm焦距的视场。</p>
<img src="https://cdn.jsdelivr.net/gh/echo468/picgo@main/img/202305121859414.png" alt="image-20230512185925369" style="zoom:67%;" />

<p>​		传感器大小不变的情况下焦距越长，可视范围越小，对于相同大小的图片相当于把远处的物体拉大。（焦距不变的情况下，传感器越小，视场越小）实际上传感器用于记录光的信息，胶片用于将信息保存为指定格式，此处不做严格区分。</p>
<img src="https://cdn.jsdelivr.net/gh/echo468/picgo@main/img/202305121908026.png" alt="image-20230512190820795" style="zoom: 50%;" />

<h4 id="Exposure曝光"><a href="#Exposure曝光" class="headerlink" title="Exposure曝光"></a>Exposure曝光</h4><p>​		曝光度&#x3D;进来多少光（光圈-F数）*光进来多长时间（快门-Shutter speed（越快，开放时间越短））</p>
<p><img src="https://cdn.jsdelivr.net/gh/echo468/picgo@main/img/202305121936650.png" alt="image-20230512193636600"></p>
<h5 id="ISO感光度"><a href="#ISO感光度" class="headerlink" title="ISO感光度"></a>ISO感光度</h5><p>​		ISO也会影响曝光度，可以理解为是后期处理 ，将接收到的光*某个数 。如对于一张暗图乘以某个数，然后使图更亮。任何信号都会存在噪声，对整个信息乘以一个很大的数，在放大信号的同时也放大了噪声。（将光理解为光子，简单理解是快门不够，进入传感器的光子少，光子少会产生噪声）ISO是线性的，ISO200一定是ISO100的两倍。</p>
<img src="https://cdn.jsdelivr.net/gh/echo468/picgo@main/img/202305122008746.png" alt="image-20230512200802700" style="zoom: 80%;" />

<h5 id="快门"><a href="#快门" class="headerlink" title="快门"></a>快门</h5><p>​		快门会发生运动模糊的现象(关心从关闭到打开的过程)。加入快门的开放时间是t，在t&#x2F;3时运动运动位置为A，在t&#x2F;2时物体运动位置为B，物体运动的中间过程都会被传感器记录，传感器将记录结果平均，形成模糊。如果快门时间更长，物体在这段时间内的运动过程更长，结果就越模糊。如果快门时间不变，物体运动越快，越容易模糊。较小快门时间可以减轻模糊，但也会减小曝光度（调ISO或者光圈）。</p>
<img src="https://cdn.jsdelivr.net/gh/echo468/picgo@main/img/202305122021932.png" alt="image-20230512202130885" style="zoom:67%;" />

<p>​		运动模糊存在一定的反走样效果。因为快门打开需要时间，所以会导致不同的地方记录不同时间的图像，出现了螺旋桨扭曲。</p>
<img src="https://cdn.jsdelivr.net/gh/echo468/picgo@main/img/202305122037367.png" alt="image-20230512203703294" style="zoom:67%;" />

<p>​		减少曝光时间，就会减小曝光度，需要调大光圈，即减小F数。如下图每一列的F数和快门时间可以基本达到相同的曝光度。但是拍照结果不太一样，大光圈即小F数会有景深现象，长快门时间会有运动模糊，所以运动模糊和景深不能同时发生。</p>
<img src="https://cdn.jsdelivr.net/gh/echo468/picgo@main/img/image-20230512204405151.png" style="zoom:67%;" />

<p>​		高速摄影（更大光圈或者更大ISO）：</p>
<img src="https://cdn.jsdelivr.net/gh/echo468/picgo@main/img/202305122048605.png" alt="image-20230512204857544" style="zoom:67%;" />

<p>​		延时摄影（小光圈，用更长的曝光时间记录物体的运动过程(运动模糊)）：</p>
<img src="https://cdn.jsdelivr.net/gh/echo468/picgo@main/img/202305122052243.png" alt="image-20230512205245169" style="zoom: 50%;" />

<h5 id="透镜"><a href="#透镜" class="headerlink" title="透镜"></a>透镜</h5><p>​		实际的透镜很复杂，此处研究理想化薄透镜（不考虑透镜的厚度）。对于平行射入透镜的光，射出透镜会聚焦到一个点，该点为焦点，焦点到透镜中心的距离为焦距。反之如果摄入透镜的光线经过焦点，射出时会变成平行于透镜的光。任意一个过透镜中心的光线，射出透镜时不会改变方向。（假设可以任意改变焦距（现代技术通过多个透镜的组合模拟一个可以任意改变焦距的薄透镜））</p>
<img src="https://cdn.jsdelivr.net/gh/echo468/picgo@main/img/202305122059997.png" alt="image-20230512205925953" style="zoom:67%;" />

<p>​		z0物距，zi像距，f焦距。通过相似三角形推三者关系。</p>
<img src="https://cdn.jsdelivr.net/gh/echo468/picgo@main/img/202305122103393.png" alt="image-20230512210354341" style="zoom: 50%;" />

<h5 id="模糊现象及F数"><a href="#模糊现象及F数" class="headerlink" title="模糊现象及F数"></a>模糊现象及F数</h5><p>​		假设物体在focal plane，最后会在sensor plane有一个清晰的成像。如果物体在focal plane后面的object，清晰的成像位置一定在sensor plane之前的image处。如果还是想在sensor plane上成像，光穿过iamge会继续传播，最后一个点会在sensor plane上呈现出一个区域而不是一个点（coc）。coc大小计算如下：</p>
<img src="https://cdn.jsdelivr.net/gh/echo468/picgo@main/img/202305122126154.png" alt="image-20230512212620103" style="zoom:67%;" />

<p>​		F数的写法：FN或者F&#x2F;N，N即F数，F数的值为焦距&#x2F;光圈的直径。在zs和zi不变的情况下，coc的大小受光圈大小的影响。F数越小，光圈越大，模糊越明显。光圈越小越接近小孔成像，形成的图像清晰范围越大，景深就越大。</p>
<img src="https://cdn.jsdelivr.net/gh/echo468/picgo@main/img/202305122128900.png" alt="image-20230512212816841" style="zoom:50%;" />

<h5 id="利用薄棱镜渲染"><a href="#利用薄棱镜渲染" class="headerlink" title="利用薄棱镜渲染"></a>利用薄棱镜渲染</h5><p>​		定义成像平面的大小，定义薄棱镜的大小和焦距，定义物距z0，可以计算出像距zi。在成像平面上选一点x’，连接透镜上一点x’’，根据光经过透镜中心方向不变的性质可以找到x’x’’光线穿过透镜后会到物体的点x’’’。那么此时就找到了一条到成像平面某一点的光线，从而计算成像平面上某一点的值。</p>
<img src="https://cdn.jsdelivr.net/gh/echo468/picgo@main/img/202305122346440.png" alt="image-20230512234608362" style="zoom:67%;" />

<h5 id="景深"><a href="#景深" class="headerlink" title="景深"></a>景深</h5><p>​	光圈会影响模糊的范围。在清晰的成像平面附近一小段距离的coc非常小，可以认为这个范围内的成像都是清晰的。</p>
<img src="https://cdn.jsdelivr.net/gh/echo468/picgo@main/img/202305122355823.png" alt="image-20230512235555713" style="zoom: 67%;" />

<p>​		如下右边蓝色区域为可以认为是清晰的成像区域，左边蓝色的区域为景深。物距、 焦距和光圈都会影响景深的范围。</p>
<img src="https://cdn.jsdelivr.net/gh/echo468/picgo@main/img/202305122357532.png" alt="image-20230512235747426" style="zoom:67%;" /> 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
    </footer>
  </div>

    
 
   
</article>

    
    <article
  id="post-games101-18-Advanced-Rendering"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2023/05/18/games101-18-Advanced-Rendering/"
    >games101-18-Advanced_Rendering</a> 
</h2>
 

    </header>
     
    <div class="article-meta">
      <a href="/2023/05/18/games101-18-Advanced-Rendering/" class="article-date">
  <time datetime="2023-05-18T15:38:39.000Z" itemprop="datePublished">2023-05-18</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/games101/">games101</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h4 id="有偏与无偏的计算方法"><a href="#有偏与无偏的计算方法" class="headerlink" title="有偏与无偏的计算方法"></a>有偏与无偏的计算方法</h4><p>​		无偏积分的期望值总是正确的值，无论使用多少样本。反之就是有偏。但是如果取的样本无限多，最后期望会收敛到一定值，但这种情况也是有偏 ，但是一致。</p>
<h5 id="BDPT（无偏）"><a href="#BDPT（无偏）" class="headerlink" title="BDPT（无偏）"></a>BDPT（无偏）</h5><p>单向光线追踪:从相机产生一条光线，连接最后一个点和光源</p>
<p>双向光线追踪： 从光源和相机分别产生一些半路径，连接两个半路径的端点形成一条完整的光路。</p>
<img src="https://cdn.jsdelivr.net/gh/echo468/picgo@main/img/202305190911290.png" alt="image-20230519091135260" style="zoom:67%;" />

<p>​		对于如下场景，几乎整个场景都是通过漫反射照亮。如果从相机开始计算，找到带有很多能量的光路较为复杂。如果第一个点是漫反射点，很难控制光路打到光线集中的地方。这种情况下，从光源开始便于计算。但是该方法实现困难并且计算慢。</p>
<img src="https://cdn.jsdelivr.net/gh/echo468/picgo@main/img/202305190917374.png" alt="image-20230519091728291" style="zoom:67%;" />

<h5 id="MLT（无偏）"><a href="#MLT（无偏）" class="headerlink" title="MLT（无偏）"></a>MLT（无偏）</h5><p>​		用马尔科夫链作为采样工具。当前有一个样本，基于当前样本在附近生成新样本，用这些样本估计函数值。对于蒙特卡洛，采样的pdf和要积分的函数形状一值时，误差最小。马尔科夫链可以形成符合这种特性的样本。</p>
<p>​		在光线传播上，在有一个路径的情况下，可以生成周围更多相似的路径。如下图对蓝色光路进行局部扰动获得新路径，最后可以找到所有路径。适合做复杂的光路传播，擅长从局部探索困难的路径。例如光线在水底聚焦被相机看到，经历了相机-折射-漫反射-折射-光源（SDS），但是光经过漫反射后只有在很小一部分区域才能折射出来。使用马尔科夫链就可以在折射出来的光线附近找到新的光线。</p>
<img src="https://cdn.jsdelivr.net/gh/echo468/picgo@main/img/202305190021893.png" alt="image-20230519002121754" style="zoom: 80%;" />

<p>​		简单的蒙特卡洛方法可以根据样本数分析其收敛速度。但是MLT很难估计收敛速度，不能保证每一个像素收敛速度相同，会产生噪声。因为每一张图收敛结果不确定且不同，因此不能渲染动画。</p>
<h5 id="光子映射（有偏）"><a href="#光子映射（有偏）" class="headerlink" title="光子映射（有偏）"></a>光子映射（有偏）</h5><p>​		适合光在折射&#x2F;反射后聚焦产生新的图案及SDS下用该方法。</p>
<p>一种光子映射的方法如下：</p>
<p>1.从光源出发进行光线追踪，直至光线到达漫反射物体</p>
<p>2.从相机出发进行光线追踪，直至光线到达漫反射物体</p>
<p>3.局部的密度估计：对任意一个着色点，通过最邻近算法取离它最近的N个光子，计算这些光子所占的面积，得到光子的密度，也就是用光子数N除以面积。密度大的地方更亮。</p>
<p>​		当取的光子数N比较少，采样点少，就会产生比较大的噪声。而光子取多图像就会比较模糊，对于临近的点计算出的结果可能相同。计算光子密度的时候，正确的方法应该是对当前一个点的一个微小的面积dA进行计算它的光子数从而计算密度，但是此处是对一定的光子数的实际面积进行的计算，所以两者本质上并不相等。</p>
<p>​		当光源发出的光子足够多的时候，同样数量的光子覆盖的面积ΔA会更小，也就会更接近dA，最终的结果也会更准确，当打出的光子接近极限，ΔA&#x3D;dA，则结果正确，所以光子映射是一个有偏但是一致的方法。</p>
<p>​		如果给定一个微小面积计算每个微小面积的光子密度，也就是ΔA是常数，则确定了光子范围。但是给定的常数始终不等于dA，所以得到的结果有偏但是不一致。</p>
<h5 id="VCM（有偏）"><a href="#VCM（有偏）" class="headerlink" title="VCM（有偏）"></a>VCM（有偏）</h5><p>​		该方法是BDPT和光子映射的组合。对于两条半路径，如果两者的端点无法连接但是很接近，不要浪费两个子路径，使用光子映射来处理临近的光子。</p>
<h5 id="实时辐射度-Instant-Radiosity-IR-（有偏）"><a href="#实时辐射度-Instant-Radiosity-IR-（有偏）" class="headerlink" title="实时辐射度 Instant Radiosity (IR)（有偏）"></a>实时辐射度 Instant Radiosity (IR)（有偏）</h5><p>​		已经被照亮的面都可以认为是光源，光源可以再照亮其他物体。光源首先发出光线，最后光线停住的点可以视作新的虚拟光源照亮着色点。在有很多细小光源的场景很适合，但是当虚拟光源接近着色点时会出现闪光点。该方法不适合毛玻璃材质。</p>
<h4 id="外观建模"><a href="#外观建模" class="headerlink" title="外观建模"></a>外观建模</h4><p>​		对于表面模型，其材质就是BRDF，下面讨论非表面模型。</p>
<h5 id="散射介质（如云、雾）"><a href="#散射介质（如云、雾）" class="headerlink" title="散射介质（如云、雾）"></a>散射介质（如云、雾）</h5><p>​		以光线穿过云为例，云由许多冰晶组成，不考虑自发光。光经过冰晶可能被吸收、被散射到各个方向，冰晶也可能接受别的方向散射来的光。</p>
<p>​		光如何散射通过Phase Function定义（类似BRDF决定光如何反射）。从相机开始找光路，能走多远由散射介质的吸收能力决定，停下时考虑光的散射方向。最后找到的光路类似光在物体表面弹射，只是在光路了上的任何一点都可能发生方向的改变。此处不是光与表面作用而是和体积作用，因此不能使用渲染方程，但是都需要找光路。</p>
<p>​		很多物体光都有进去的可能，只是穿透能力不强，光进去一段时间就消失。</p>
<h5 id="头发"><a href="#头发" class="headerlink" title="头发"></a>头发</h5><p>​		头发是一根根，不能当作是一个表面。如下图，对于头发有无色的高光和有色的高光。计算量大，需要计算光线和每一根头发的作用。</p>
<p> （1）Kajiya-Kay Model		</p>
<p>​		将头发当作一个圆柱，光会散射成一个圆锥的形状，剩下一部分类似漫反射。但是渲染效果不真实。</p>
<p>（2）Marschner Model</p>
<p>​		将头发当成玻璃圆柱。光与头发的作用有三种情况，R-在表面直接被反射；TT-折射进头发再被折射出去；TRT-折射进头发，在头发内壁发生反射再折射出去。（将头发分为表面和内部，内部也会有色素，会发生光线被吸收）</p>
<h5 id="动物毛发"><a href="#动物毛发" class="headerlink" title="动物毛发"></a>动物毛发</h5><p>​		动物毛发比人的头发的髓质更大，因此不能用头发模型来计算动物毛发。</p>
<p>（1）Double Cylinder Model</p>
<p>R:光再毛发表面直接被反射</p>
<p>TT：光与髓质没有作用，折射进头发再被折射出去</p>
<p>TRT：光与髓质没有作用，折射进头发，在头发内壁反射，再被折射出去</p>
<p>TTs：折射进入, 第一次穿过髓质时, 产生散射, 再次折射出去</p>
<p>TRTs:折射进入, 第一次穿过髓质后并未折射出去, 而是在头发内壁反射回来, 第二次穿过髓质, 再产生一次折射后出去（散射两次）</p>
<h5 id="颗粒材质"><a href="#颗粒材质" class="headerlink" title="颗粒材质"></a>颗粒材质</h5><p>​		下面讨论几种表面模型。</p>
<p>玉石</p>
<p>​		光线从某个点进入物体表面，在物体内部发生大量散射，再从物体表面另一位置出去。也称作次表面散射。</p>
<p>​		BRDF：对于任意方向来的光，到达某一个着色点，从任意方向反射出去</p>
<p>​		BSSRDF:对于任意方向来的光，到达某一个着色点，从任意方向反射出去,但是反射点的位置可以表面任意一个位置。所以除了对立体角积分，还需要对物体表面积分。BSSRDF需要四个参数定义（入射点位置，入射点方向，出射点位置，入出射点方向）</p>
<p>​		还可以将该模型模拟成两个光源，一个在物体内部，一个在物体外部。</p>
<h5 id="布料"><a href="#布料" class="headerlink" title="布料"></a>布料</h5><p>纤维fibers-股ply-线yarn-布料</p>
<p>​		计算表面与光的作用，结果与织法有关。给定编织模式，计算整体行为。但是表面渲染有限制，羊毛绒是往外一根一根, 不是一个平面。</p>
<p>​		一种方法是不再把布料当成纤维，而是当成体积。对空间划分格子，在每一个格子内部将布料当成类似云的散射介质计算。但是计算量庞大。</p>
<p>​		另一种方法是，知道每一个纤维的缠绕方式，渲染每一个纤维（如渲染每一根头发）。</p>
<h5 id="详细外观"><a href="#详细外观" class="headerlink" title="详细外观"></a>详细外观</h5><p>​		看起来不真实，现实世界更复杂，车会有划痕等等, 鼠标会有大小不一的高光。用微表面模型得到的结果不太真实。</p>
<p>​		在微表面模型中，D（h）采用简单的模型，如符合正态分布，因此效果不真实。真实情况是，D（h）基本符合统计规律，但是又自己的细节。</p>
<p>​		在这种情况下路径采样困难。每一个微表面是一个镜面, 再假设一个针孔摄像机和点光源。无论从针孔摄像机, 还是点光源连接微表面, 发生镜面反射。都很难反射到点光源或者针孔摄像机.</p>
<p>​		一个像素覆盖很多的微表面形成一个区域, 把这个区域的法线分布算出来, 然后替代原本的光滑的法线分布, 用在原本的微表面模型里.</p>
<p>​		一个像素覆盖法线贴图的面积, 导致不同特征的法线分布。 不同的法线贴图, 有不同的法线分布。</p>
<h5 id="通过波动光学研究材质"><a href="#通过波动光学研究材质" class="headerlink" title="通过波动光学研究材质"></a>通过波动光学研究材质</h5><p>​		波动光学得到的BRDF与几何得到的不太相同，有自己的特点。</p>
<h4 id="程序化生成"><a href="#程序化生成" class="headerlink" title="程序化生成"></a>程序化生成</h4><p>​		定义三维纹理，但是内存开销较大。可以不进行存储，在需要的时候查询。如3D噪声函数，空间中任意一个坐标, 返回需要查询的值(纹理细节)。通过任意方式处理噪声函数，就可以得到任意的效果。</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
    </footer>
  </div>

    
 
   
</article>

    
    <article
  id="post-games101-15-Ray-Tracing3"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2023/05/15/games101-15-Ray-Tracing3/"
    >games101-15-Ray-Tracing3</a> 
</h2>
 

    </header>
     
    <div class="article-meta">
      <a href="/2023/05/15/games101-15-Ray-Tracing3/" class="article-date">
  <time datetime="2023-05-15T03:39:40.000Z" itemprop="datePublished">2023-05-15</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/games101/">games101</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h4 id="Irradiance"><a href="#Irradiance" class="headerlink" title="Irradiance"></a>Irradiance</h4><p>​		每单位照射面积所接收到的能量。此处面积必须与光线垂直，如果是不垂直的光线，需要类似Blinn-Phong的漫反射光照，乘以一个cosθ。</p>
<img src="https://cdn.jsdelivr.net/gh/echo468/picgo@main/img/202305141342934.png" alt="image-20230514134205834" style="zoom:67%;" />

<p>​		当光线垂直照射平面时，如上图左边所示，照射到平面上的面积与光线本身垂直。但当光线斜着照射到平面时，此时真正与光线垂直的面积为A2cosθ。</p>
<img src="https://cdn.jsdelivr.net/gh/echo468/picgo@main/img/202305141409681.png" alt="image-20230514140908635" style="zoom:67%;" />

<p>​		对于之前Blinn-Phong的例子，此处认为光每单位时间辐射出来的能量是一个定值，这些能量会均匀分布在球壳上，所以对于单位为1的球壳和单位r的球壳，总能量都是Φ。但是单位为r的球壳面积更大，计算出的irradiance就更小。（此处itensity没有变，对于同一个方向而言，根据计算公式微分立体角不随球壳的大小改变。能量衰减相当于能量分散）</p>
<img src="https://cdn.jsdelivr.net/gh/echo468/picgo@main/img/202305141354164.png" alt="image-20230514135419108" style="zoom:50%;" />

<h4 id="radiance"><a href="#radiance" class="headerlink" title="radiance"></a>radiance</h4><p>​		每单位垂直面积（所以dA要乘以cosθ）、每单位立体角（每个方向）上单位时间光辐射出的能量（所以做两次导数）&#x2F; 单位垂直面积，在单位时间内接收到某个方向的能量。也就是在irradiance的基础上增加的方向性。</p>
<img src="https://cdn.jsdelivr.net/gh/echo468/picgo@main/img/202305141412287.png" alt="image-20230514141247249" style="zoom:67%;" />

<p>​		该方程也可以转换成如下两个方程：</p>
<img src="https://cdn.jsdelivr.net/gh/echo468/picgo@main/img/202305141541083.png" alt="image-20230514154139046" style="zoom: 50%;" />

<p>​		在单位时间单位面积上会接收不同方向来的能量，将E对立体角求导，得到具体某一个方向上的能量。</p>
<img src="https://cdn.jsdelivr.net/gh/echo468/picgo@main/img/202305141541496.png" alt="image-20230514154149459" style="zoom:50%;" />

<p>​		在单位时间单位面积光会向各个方向辐射出能量，得到具体向某一个方向辐射出的能量。</p>
<img src="https://cdn.jsdelivr.net/gh/echo468/picgo@main/img/202305141541897.png" alt="image-20230514154158860" style="zoom:50%;" />

<p>​		对于一个单位面积，会接收到来自各个方向的能量，这里只考虑正半球，因为负半球来的光照射不到单位面积（Blinn-Phong模型中也会把cos最小值限制在0）。通过对各个方向的radiance积分求和，就可以得到对于一个单位面积的irradiance。如下式子的含义式，一个点(微分面积元)所接收到的亮度(irradiance)，由所有不同方向的入射光线亮度(radiance)共同贡献得到。</p>
<img src="https://cdn.jsdelivr.net/gh/echo468/picgo@main/img/202305141450693.png" alt="image-20230514145032647" style="zoom:67%;" />

<h4 id="BRDF双向反射分布函数"><a href="#BRDF双向反射分布函数" class="headerlink" title="BRDF双向反射分布函数"></a>BRDF双向反射分布函数</h4><p>​		此处认为所谓反射，是指物体吸收了一部分能量（入射，接收光），再将一部分能量辐射出去（出射，反射光）。单位面积dA接收到 ωi 方向来的Radiance，下图中用 L(ωi) 表示，也能理解成iradicance的一个微元dE(ωi)&#x3D; L(ωi)cosθidwi，然后再辐射到四面八方 ωr 中去，这时候辐射出去的又是Radiance（因为反射出去无数多条，power会被分散，此处关注其中的一个反射方向），用 dLr(x, ωr))表示。</p>
<img src="https://cdn.jsdelivr.net/gh/echo468/picgo@main/img/202305141519355.png" alt="image-20230514151942291" style="zoom: 50%;" />

<p>​		BRDF描述了入射光线经过某个表面反射后在各个可能的出射方向上能量分布。比如已经知道入射方向 ωi ，对于任意 ωr反射方向，能得到值域在[0,1]的浮点数返回值。返回值意义：定义某个点在 ωr 方向的反射光线的能量跟 ωi 方向射入的光线能量的比值。比如镜面反射，则镜面反射的方向能量接近百分之百，其他反射方向接近0比如漫反射，则所有方向的能量比例相同，均分；该函数描述了物体表面与光线如何作用，可以定义不同材质。</p>
<img src="https://cdn.jsdelivr.net/gh/echo468/picgo@main/img/202305141559470.png" alt="image-20230514155905411" style="zoom: 50%;" />

<h4 id="反射方程"><a href="#反射方程" class="headerlink" title="反射方程"></a>反射方程</h4><p>​		即摄像机所接受到的ωr，是由所有不同方向上入射光线的irradiance贡献得到的，图中的L，而不同方向入射光irradiance对反射方向ωr的贡献程度由BRDF函数决定。将所有irradiance对反射方向的贡献积分，得到一个单位面积（一点）在整个光照环境下,对出射方向（观测方向）的贡献。</p>
<img src="https://cdn.jsdelivr.net/gh/echo468/picgo@main/img/202305141559858.png" alt="image-20230514155930809" style="zoom:50%;" />

<p>​		入射光线的radiance不仅仅是光源所造成，还有可能是其他物体上着色点的反射光线的radiance，恰好反射到当前的着色点p。所以一个物体的反射光会成为另一个物体的入射光，因此是一个递归的过程。</p>
<h4 id="渲染方程"><a href="#渲染方程" class="headerlink" title="渲染方程"></a>渲染方程</h4><p>​		此处所有方向认为朝外，从点p指向外。认为下半球的贡献为0。此处cos用法线和微分立体角（方向）的点积表示。</p>
<img src="https://cdn.jsdelivr.net/gh/echo468/picgo@main/img/202305141608886.png" alt="image-20230514160826844" style="zoom:67%;" />

<p>​		对于一个点光源，该点只会接收到来自点光源的一根光线：</p>
<img src="https://cdn.jsdelivr.net/gh/echo468/picgo@main/img/202305141612720.png" alt="image-20230514161236661" style="zoom:67%;" />

<p>​		对于多个点光源：</p>
<img src="https://cdn.jsdelivr.net/gh/echo468/picgo@main/img/202305141613487.png" alt="image-20230514161340411" style="zoom: 50%;" />

<p>​		对于面光源，就相当于无穷多个点光源的集合，只需要对面光源所在的立体角范围进行积分：</p>
<img src="https://cdn.jsdelivr.net/gh/echo468/picgo@main/img/202305141616903.png" alt="image-20230514161626837" style="zoom: 67%;" />

<p>​		如果场景中有加入其他物体，可以把其他物体同样考虑成面光源，对其所占的立体角进行积分。只不过对其它物体的立体角积分不像是面光源所有入射方向都有radiance，物体的立体角可能只有个别几个方向有入射的radiance(即多次物体间光线反射之后恰好照射到着色点x)，其它方向没有，但本质上都可以视作是面光源。如下对于物体x’：</p>
<img src="https://cdn.jsdelivr.net/gh/echo468/picgo@main/img/202305141622884.png" alt="image-20230514162240837" style="zoom:67%;" />

<p>​		其中各项与原渲染方程中一一对应，(这里其实是有数学严格推导的，不过只是为了接下来构建直观的物理解释，对于这些推导不必在意，默认成立即可	</p>
<img src="https://cdn.jsdelivr.net/gh/echo468/picgo@main/img/202305141629833.png" alt="image-20230514162954768" style="zoom: 67%;" />

<p>​		进一步简写：</p>
<img src="https://cdn.jsdelivr.net/gh/echo468/picgo@main/img/202305141632301.png" alt="image-20230514163214255" style="zoom:67%;" />

<p>​		E为物体自己发光，KE则代表对光源反射一次的结果，即直接光照，那么前两项之和就是光栅化当中着色所考虑的结果。对于全局光照来说，还考虑了一次弹射的间接照明、两次弹射的间接照明，依次类推。着色点的值就是物体自发光加上直接光照与多次间接光照的结果，而这一切都是从渲染方程推导而来的，因此这也正是渲染方程的物理意义。</p>
<img src="https://cdn.jsdelivr.net/gh/echo468/picgo@main/img/202305141633270.png" alt="image-20230514163328230" style="zoom:67%;" />

<p>​		如下是一个示例：</p>
<p>​		（1）一次反射直接光照（光栅化），能被光照亮的部分就是有颜色的，不能被光照亮的部分就是黑色：</p>
<img src="https://cdn.jsdelivr.net/gh/echo468/picgo@main/img/202305141641229.png" alt="image-20230514164109124" style="zoom: 50%;" />

<p>​		（2）两次反射，考虑到一次弹射的间接光照：</p>
<img src="https://cdn.jsdelivr.net/gh/echo468/picgo@main/img/202305141641516.png" alt="image-20230514164122323" style="zoom: 50%;" />

<p>​		（3）3次反射，考虑到两次弹射的间接光照：</p>
<img src="https://cdn.jsdelivr.net/gh/echo468/picgo@main/img/202305141641029.png" alt="image-20230514164142826" style="zoom:50%;" />

<p>​		（4）4次反射,灯亮的原因：光经过两层玻璃折射进去，经过两层玻璃折射出来被照相机看到</p>
<img src="https://cdn.jsdelivr.net/gh/echo468/picgo@main/img/202305141642498.png" alt="image-20230514164254408" style="zoom:50%;" />

<p>​		考虑次数越多越接近真实图片效果，如果经过无限次数，由于能量守恒，最后趋近收敛。与快门时间越长接收越来越多光照 导致曝光是两回事。</p>
<h4 id="基础概率论"><a href="#基础概率论" class="headerlink" title="基础概率论"></a>基础概率论</h4><p>​		X：随机变量（可以取某些值的一个数）。</p>
<p>​		X~p(x)：随机变量的概率分布，描述随机过程选择值 x 的相对概率，必须包含所有能取到的值。</p>
<p>​		概率分布对于离散型随机变量按照如下方式表示：</p>
<img src="https://cdn.jsdelivr.net/gh/echo468/picgo@main/img/202305141811301.png" alt="image-20230514181104266" style="zoom:50%;" />

<p>​		例如对于骰子：p(1)&#x3D;p(2)&#x3D;p(3)&#x3D;p(4)&#x3D;p(5)&#x3D;p(6)&#x3D;1&#x2F;6。</p>
<p>​		对于所有可能取值的概率，概率必须大于0，这些概率和相加为1：</p>
<img src="https://cdn.jsdelivr.net/gh/echo468/picgo@main/img/202305141715860.png" alt="image-20230514171530816" style="zoom: 67%;" />

<p>​		期望：从随机分布中重复抽取样本所获得的平均值。</p>
<img src="https://cdn.jsdelivr.net/gh/echo468/picgo@main/img/202305141716502.png" alt="image-20230514171636464" style="zoom:67%;" />

<p>​		X~p(x)在连续情况下，一个随机变量 X，可以取任意一组连续值，其概率分布由连续概率密度函数PDF 给出。通过对该函数积分得到一段区间内的面积，即为X在这段区间内的概率值。也就是每个x对应的值并不是概率值，积分的面积才是。（就好比v-t的图，每个t对应的v并不是路程，积分的面积才是路程）</p>
<img src="https://cdn.jsdelivr.net/gh/echo468/picgo@main/img/202305141753930.png" alt="image-20230514175327878" style="zoom:67%;" />

<p>​		 随机变量X的函数Y,也是随机变量，随机变量函数的期望值计算如下：</p>
<img src="https://cdn.jsdelivr.net/gh/echo468/picgo@main/img/202305141753995.png" alt="image-20230514175300955" style="zoom:67%;" /> 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
    </footer>
  </div>

    
 
   
</article>

    
    <article
  id="post-games101-14-Ray-Tracing2"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2023/05/14/games101-14-Ray-Tracing2/"
    >games101-14-Ray-Tracing2</a> 
</h2>
 

    </header>
     
    <div class="article-meta">
      <a href="/2023/05/14/games101-14-Ray-Tracing2/" class="article-date">
  <time datetime="2023-05-14T01:45:04.000Z" itemprop="datePublished">2023-05-14</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/games101/">games101</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <p>​		如果整个场景只有一个极其复杂的单一人物模型，那么只对这一个物体做包围盒的话，相当于对效率没有任何提升。如果整个场景充斥着大量的细小模型，如草，花之类的，每个模型可能只有很少的面，如果此时对每个物体求包围盒，得到的包围盒数量会相当之多，对于光线追踪效率来说效率提升有限。基于以上两点考虑，AABB并不应只局限于以物体模型为单位，因此如何更好的划分场景形成不同的AABB，使得划分之后的AABB能够更好的加速光线追踪，就是接下来要考虑的问题关键。</p>
<h4 id="均匀空间划分"><a href="#均匀空间划分" class="headerlink" title="均匀空间划分"></a>均匀空间划分</h4><p>（1）对所要考虑的场景找一个包围盒：</p>
<img src="https://cdn.jsdelivr.net/gh/echo468/picgo@main/img/202305131029114.png" alt="image-20230513102915947" style="zoom:50%;" />

<p>（2）在光线追踪之前，均匀用小格子划分这个大包围盒（相当于把场景均匀划分成更小的AABB包围盒）：</p>
<img src="https://cdn.jsdelivr.net/gh/echo468/picgo@main/img/202305131029151.png" alt="image-20230513102934066" style="zoom:50%;" />

<p>（3）标记出与物体表面相交的格子(不包括物体内部)，存储物体模型信息:</p>
<img src="https://cdn.jsdelivr.net/gh/echo468/picgo@main/img/202305131029586.png" alt="image-20230513102953483" style="zoom:50%;" />

<p>（4）根据光线的方向与判断出所有与光线相交的格子(这一步可以利用bresenham算法，如对于朝右上方的光线，光线经过的下一个格子为当前格子的右边或者上边的格子，求交点找更近的格子)，倘若格子还与物体表面相交，就说明光线可能会和物体相交，再进一步将光线与格子中的物体模型或是三角形面求交。</p>
<img src="https://cdn.jsdelivr.net/gh/echo468/picgo@main/img/202305131030156.png" alt="image-20230513103007070" style="zoom:50%;" />

<p>问题1：小格子的大小</p>
<p>​		在该方法中，更多的计算是光线与AABB包围盒（小格子）而不是物体，通过包围盒把计算的三角形面限制在更小的范围内，所以某种程度上可以加速计算。但是格子的大小也会影响计算速度。在极端情况下，假如格子的大小为1✖1,相当于没有进行划分。如果格子太过密集，要计算的小格子很多，也会影响计算速度。较好的划分程度为格子数&#x3D;C✖物体个数，在3维情况下C的值一般取27。</p>
<img src="https://cdn.jsdelivr.net/gh/echo468/picgo@main/img/202305131046138.png" alt="image-20230513104601004" style="zoom: 50%;" />

<p>问题2：均匀划分场景引发的问题</p>
<p>​		如果说场景较为空旷，物体较小且分离得比较开，那么均匀分割的效果就会很差了，因为会有很多无效的方格与光线的求交过程。例如对于一个空旷的操场，操场中间放置了一个茶壶，光线到达茶壶之前，需要计算光线和很多空格子求交过程。因此空旷的地方不适合划分太多小格子，用大格子快速跳过空旷位置的计算。均匀划分的方法适合的场景是空间中均匀布满了三角形面，如下图这种场景，物体多的地方适合划分更多的小格子，将需要计算的三角形面限制在更小范围，如果格子太大，就需要将光线和更多的三角面求交：</p>
<img src="https://cdn.jsdelivr.net/gh/echo468/picgo@main/img/202305131120079.png" alt="image-20230513112034871" style="zoom:67%;" />

<p>如下是其他划分方法：</p>
<p>（1）八叉树，每次将空间分为8个相等的部分，再递归的对子空间进行划分。当划分的子空间足够小或是空间中三角形面的数量很少的时候会停止划分。这种方法的显著缺点是，随着维度的上升划分的空间数量会呈指数级增长。</p>
<p>（2）KD-Tree，每次将空间划分为两部分，且划分依次沿着x-axis，y-axis，z-axis交替进行，使得空间划分相对均匀，终止条件与八叉树类似。</p>
<p>（3）BSP-Tree，其与KD-Tree类似，唯一不同的是划分不再沿着固定一轴，可以任意方向划分，缺点是划分的空间没有规则性，对比于AABB来说，求交困难。</p>
<img src="https://cdn.jsdelivr.net/gh/echo468/picgo@main/img/202305131059825.png" alt="image-20230513105950720" style="zoom:67%;" />

<h4 id="KD-Tree空间划分"><a href="#KD-Tree空间划分" class="headerlink" title="KD-Tree空间划分"></a>KD-Tree空间划分</h4><p>​		如下所有操作都在光线追踪之前，对场景预处理，以2维为例。</p>
<p>​		先将整个场景放在包围盒中，将空间分为两部分：</p>
<img src="https://cdn.jsdelivr.net/gh/echo468/picgo@main/img/202305131412006.png" alt="image-20230513141209956" style="zoom: 50%;" />

<p>​		对左右两个子空间换个方向再分为两部分(这里只画出了右半部分，其实左边也是一样)，之后以此类推进一步分割，形成KD-tree。</p>
<p>（1）依次沿着x-axis,y-axis,z-axis划分，使得空间被划分的更加平衡<br>（2）划分的位置由空间中三角面的分布决定，具体细节不展开<br>（3） 叶子节点存储对应空间的所有物体或三角面信息，中间节点仅存储指针指向两个子空间<br>（4） 当划分空间太小或是子空间内只有少量三角形则停止划分</p>
<table>
<thead>
<tr>
<th><img src="https://cdn.jsdelivr.net/gh/echo468/picgo@main/img/202305131412784.png" alt="image-20230513141218740" style="zoom:50%;" /></th>
<th><img src="https://cdn.jsdelivr.net/gh/echo468/picgo@main/img/202305131416122.png" alt="image-20230513141650076" style="zoom:67%;" /></th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td></td>
</tr>
</tbody></table>
<p>​		对于一条光线，第一步判断光线是否与最外层的包围盒相交，如果相交进一步判断是否与对应的两个子空间相交：</p>
<img src="https://cdn.jsdelivr.net/gh/echo468/picgo@main/img/202305131412799.png" alt="image-20230513141228752" style="zoom:50%;" />

<p>​		因图中做了简化，最大包围盒的左半边并没继续进行划分(实际上应该要划分的)，所以左半部分对应的1号空间是叶子节点，如果光线与之相交，进一步判断与存储在叶子节点的物体求交。</p>
<img src="https://cdn.jsdelivr.net/gh/echo468/picgo@main/img/202305131412090.png" alt="image-20230513141238041" style="zoom:50%;" />

<p>​		左半边判断完之后，接着判断右半部分，如果对于右半部分存在相交情况，则对于右半部分的所有子空间，递归的执行这个步骤即可：</p>
<table>
<thead>
<tr>
<th><img src="https://cdn.jsdelivr.net/gh/echo468/picgo@main/img/202305131444748.png" alt="image-20230513144410699" style="zoom: 50%;" /></th>
<th><img src="https://cdn.jsdelivr.net/gh/echo468/picgo@main/img/202305131412368.png" alt="image-20230513141258321" style="zoom:50%;" /></th>
</tr>
</thead>
<tbody><tr>
<td><img src="https://cdn.jsdelivr.net/gh/echo468/picgo@main/img/202305131427636.png" alt="image-20230513142703588"></td>
<td><img src="https://cdn.jsdelivr.net/gh/echo468/picgo@main/img/202305131427025.png" alt="image-20230513142754978"></td>
</tr>
</tbody></table>
<p>​		利用KD-Tree的结构来对空间划分AABB包围盒的好处是倘若光线与哪一部分空间不相交，那么则可以省略该部分空间所有子空间的判断过程，提升了效率。缺点是判断包围盒与三角面的是否相交较难，因此划分的过程不是那么想象的简单，其次同一个三角形面或物体可能被不同的包围盒同时占有，不同包围盒内的叶节点会同时存储这一个三角形面或物体。</p>
<h4 id="BVH物体划分"><a href="#BVH物体划分" class="headerlink" title="BVH物体划分"></a>BVH物体划分</h4><p>​		BVH与前几种方法最显著的区别就是，不再以空间作为划分依据，而是从对象的角度考虑，即三角形面（物体）。<br>​		第一步同样找出场景的整体包围盒作为根节点:</p>
<img src="https://cdn.jsdelivr.net/gh/echo468/picgo@main/img/202305131453263.png" alt="image-20230513145329220" style="zoom:50%;" />

<p>​		第二步找到合适的划分点，将最大包围盒内的三角形面分为两部分，再分别重新就算新的包围盒:</p>
<img src="https://cdn.jsdelivr.net/gh/echo468/picgo@main/img/202305131454548.png" alt="image-20230513145402505" style="zoom:50%;" />

<p>​		注意到这里，包围盒会重叠，但一个三角形面只会被存储在唯一的包围盒内，而这也就解决了KD-Tree的缺点。接下来与KD-Tree的建立类似，递归的对所有子空间重复该步骤（如何划分使得重叠部分更少很有讲究），当叶子节点三角形个数足够少停止（一般≤5）：</p>
<img src="https://cdn.jsdelivr.net/gh/echo468/picgo@main/img/202305131454256.png" alt="image-20230513145433211" style="zoom:50%;" />

<p>​		划分顺序可以按照xyz轴。为了划分均匀，也可以每次划分一般选择最长的那一轴划分，假设是x轴，n个三角形从左到右，找到中位数的三角形进行左右划分（对于x轴，将三角形重心按照x排序，找到中间的三角形），如此便能保证划分的左右两边三角形数量尽可能差不多。之后判断光线与包围盒求交的步骤同KD-Tree。BVH不需要判断包围盒和三角形面的关系。</p>
<h4 id="辐射度量学Radiometry"><a href="#辐射度量学Radiometry" class="headerlink" title="辐射度量学Radiometry"></a>辐射度量学Radiometry</h4><p>​		在Blinn-Phong模型中，光的能量用常数I表示，没有单位和一个准确的定义。该模型在计算高光的时候，只考虑是否能看见高光，不考虑实际接收到的能量，即光线方向和法线的关系。whited-style的光线追踪模型中，认为所有反射都是完美镜面反射，对于漫反射的光线没有进行追踪，直接用当前点的颜色。并且光在多次折射和反射中会有能量损失，能量损失的值是自定义的。</p>
<p>（1）Radiant Energy:光源辐射出能量Q[J]</p>
<p>（2）Radiant flux:单位时间内光源辐射出的能量（时间越长能量越多，在辐射度量学中考虑单位时间的性质）</p>
<img src="https://cdn.jsdelivr.net/gh/echo468/picgo@main/img/202305131520260.png" alt="image-20230513152037223" style="zoom: 67%;" />

<p>（3）Radiant intensity：单位时间光源在单位立体角（某个方向）上辐射出的能量</p>
<img src="https://cdn.jsdelivr.net/gh/echo468/picgo@main/img/202305131526426.png" alt="image-20230513152636391" style="zoom: 67%;" />

<p>​		弧度制，数学术语，指用弧长与半径之比度量对应圆心角角度的方式。用符号rad表示，读作弧度。等于半径长的圆弧所对的圆心角叫做1弧度的角。由于圆弧长短与圆半径之比，不因为圆的大小而改变，所以弧度数也是一个与圆的半径无关的量。（圆周长2 πR，面积 πR^2）整个圆的弧度为2 π。</p>
<img src="https://cdn.jsdelivr.net/gh/echo468/picgo@main/img/202305131529358.png" alt="image-20230513152911322" style="zoom:67%;" />

<p>​		对应在三维上的球的弧度(立体角)的计算方式如下，立体角度所对应球上的投影面积比上半径的平方，整个球的立体角为4 π 。（球表面积 4πR^2）</p>
<img src="https://cdn.jsdelivr.net/gh/echo468/picgo@main/img/202305131529984.png" alt="image-20230513152919949" style="zoom:67%;" />

<p>​		利用微分立体角dw定义一个方向（就好比用一个浮点数定义一个时间），计算如下：通过θ,ϕ确定空间中一个方向，在这两个角度上分别增加一个微分值，其中rdθ 是微分面积元的高，rsinθdϕ 是微分面积元的宽，二者相乘是微分立体角在球面上的面积。用该微分面积除以半径的平方即为微分立体角的值。</p>
<img src="https://cdn.jsdelivr.net/gh/echo468/picgo@main/img/202305131534431.png" alt="image-20230513153447386" style="zoom: 67%;" />

<p>​		对dw在整个球上积分，积分结果为4π。</p>
<img src="https://cdn.jsdelivr.net/gh/echo468/picgo@main/img/202305131536006.png" alt="image-20230513153620960" style="zoom: 67%;" />

<img src="C:\Users\华为\AppData\Roaming\Typora\typora-user-images\image-20230513153752040.png" alt="image-20230513153752040" style="zoom:67%;" />

<p>​		对各向同性点光源，所有方向上的亮度都与方向无关，所以I是一个常数，因此对Φ积分时只用对立体角积分。最后推算出的I是一个常数。</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
    </footer>
  </div>

    
 
   
</article>

    
    <article
  id="post-games101-13-Ray-Tracing1"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2023/05/13/games101-13-Ray-Tracing1/"
    >games101-13-Ray_Tracing1</a> 
</h2>
 

    </header>
     
    <div class="article-meta">
      <a href="/2023/05/13/games101-13-Ray-Tracing1/" class="article-date">
  <time datetime="2023-05-13T05:44:01.000Z" itemprop="datePublished">2023-05-13</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/games101/">games101</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h4 id="光线追踪如何处理全局光照"><a href="#光线追踪如何处理全局光照" class="headerlink" title="光线追踪如何处理全局光照"></a>光线追踪如何处理全局光照</h4><p>​		光栅化不适合处理全局的效果。如软阴影、磨砂材质、间接光照（光反射多次后到达相机）。在之前的光栅化处理中，只考虑光的一次反射，从光源到达着色点再到达相机。光栅化渲染快，常用于实时渲染（每秒超过30帧）</p>
<p>假设：</p>
<p>（1）光线沿着直线传播</p>
<p>（2）光线和光线不会发生碰撞</p>
<p>（3）光线路径可逆，即从A发出的到B的光线，一定也可以从B发出到A（中途可发生反射和折射）</p>
<p>​		从人眼或摄像机向近投影平面上的每一个像素点发射一条光线，判断与场景物体的交点。一条光线可能会与不止一个物体相交，但是考虑遮挡关系，只去找最近的交点（相当于进行了深度测试）。</p>
<img src="https://cdn.jsdelivr.net/gh/echo468/picgo@main/img/202305121407903.png" alt="image-20230512140740839" style="zoom:67%;" />

<p>​		接着连接该交点和光源，只要判断这条连线之间是否有物体存在就可以知道该交点是否在阴影之中。如果该点不在阴影中，知道该点的法线、相机位置和光源位置，可以计算出该点对应的像素值。遍历所有近投影平面上的像素就能得到一张完整的图像。此时效果与局部光照模型是一样的，只考虑了光一次反射。</p>
<img src="https://cdn.jsdelivr.net/gh/echo468/picgo@main/img/202305121409264.png" alt="image-20230512140905212" style="zoom:67%;" />

<p>​		上一个例子中光线第一个与圆球物体相交，假设该圆球是一个玻璃球，那么便会发生镜面反射。除了镜面反射之外，也存在折射，同时反射与折射出去的光线可能与场景中的物体再次碰撞，发生第二次折射与反射。下图以两个光线，以两次折射或反射的部分光线为例。</p>
<img src="https://cdn.jsdelivr.net/gh/echo468/picgo@main/img/202305121413323.png" alt="image-20230512141359281" style="zoom:67%;" />

<p>​		此时每一个像素的颜色贡献来自直接光照，反射方向间接光，折射方向间接光（如果有折射的话）。下一步将这些所有交点（上图中4个交点）与光源连接，计算这些所有点的局部光照模型的结果（被遮挡就不用计算），将其按照光线能量权重累加(光在传播过程中会有损失，如果不添加权值最后会发生曝光)，最终得到近投影平面上该像素点的颜色。这是一个全局光照模型，不仅仅考虑了直接光源的贡献，还考虑各种折射与反射光线的贡献。</p>
<img src="https://cdn.jsdelivr.net/gh/echo468/picgo@main/img/202305121414958.png" alt="image-20230512141440915" style="zoom:67%;" />

<p>​		上图中的光线分成三种类别，相机到物体为primary ray；中间反射和折射的蓝线为secondary  ray；最后交点与光源的连线为shadow ray，因为要考虑遮挡。</p>
<h4 id="如何判断光线与物体的交点"><a href="#如何判断光线与物体的交点" class="headerlink" title="如何判断光线与物体的交点"></a>如何判断光线与物体的交点</h4><h5 id="光线与隐式几何求交"><a href="#光线与隐式几何求交" class="headerlink" title="光线与隐式几何求交"></a>光线与隐式几何求交</h5><p>​		通过光源位置O和光线方向d定义一条光线（光线是射线）：</p>
<img src="https://cdn.jsdelivr.net/gh/echo468/picgo@main/img/202305121420925.png" alt="image-20230512142046886" style="zoom: 50%;" />

<p>​		光线与球求交，t值对应的点需要满足两个表达式：</p>
<img src="https://cdn.jsdelivr.net/gh/echo468/picgo@main/img/202305121424656.png" alt="image-20230512142416606" style="zoom: 67%;" />

<p>​		光线与球求交可能会没有交点、有一个交点或者有两个交点。在有两个交点的情况下，取更小的t值。（t必须是实数且为非负数）</p>
<img src="https://cdn.jsdelivr.net/gh/echo468/picgo@main/img/202305121424151.png" alt="image-20230512142454099" style="zoom: 50%;" />

<p>​		对于光线与隐式表面的交点，只要将光线方程代入求解 t 即可：</p>
<img src="https://cdn.jsdelivr.net/gh/echo468/picgo@main/img/202305121502542.png" alt="image-20230512150218495" style="zoom:67%;" />

<h5 id="光线与显示几何求交"><a href="#光线与显示几何求交" class="headerlink" title="光线与显示几何求交"></a>光线与显示几何求交</h5><p>​		对于显示表面，最重要的是判断光线如何与三角形求交（只考虑0&#x2F;1个交点）。如下图可以将该光线与所有三角形面求交，找到最小的t值。对于多个像素（多条光线）都与所有面计算，计算量相当大。总计算量为像素数（一个像素一个光线）✖三角形面。</p>
<img src="https://cdn.jsdelivr.net/gh/echo468/picgo@main/img/202305121507126.png" alt="image-20230512150709077" style="zoom:67%;" />

<p>​		判断光线与三角形所在平面是否有交点，如果有交点再判断该点是否在三角形内部。</p>
<p>​		首先通过一个点和法线定义一个平面。如果任意一点和该点的连线与法线垂直，则说明该点在平面上。将p和n用xyz定义，展开后如右式。</p>
<img src="https://cdn.jsdelivr.net/gh/echo468/picgo@main/img/202305121515786.png" alt="image-20230512151503743" style="zoom:67%;" />

<p>​		得到参数 t 之后，可以计算出交点，并且再去计算出重心坐标就能判断该交点是否在三角形内。</p>
<img src="https://cdn.jsdelivr.net/gh/echo468/picgo@main/img/202305121520092.png" alt="image-20230512152052037" style="zoom: 50%;" />

<p>​		如下方法直接判断光线在三角形内部是否有交点。假设该点在三角形内，则可以通过重心坐标表示。通过如下方法解出t,b1,b2。如果t,b1,b2,1-b1-b2都是非负数，则该点在三角形内部。</p>
<p>​		<img src="https://cdn.jsdelivr.net/gh/echo468/picgo@main/img/202305121520552.png" alt="image-20230512152025494" style="zoom: 50%;" /></p>
<h5 id="光线与包围盒求交"><a href="#光线与包围盒求交" class="headerlink" title="光线与包围盒求交"></a>光线与包围盒求交</h5><p>​		使用包围盒加速光线与物体求交。三维空间常用的包围盒是AABB包围盒，即一个长方体。包围盒是由3个对面形成的交集。以二维为例，计算出光线进入两个对面的时间，和光线出两个对面的时间。将第一幅图和第二幅图的线段做交集。</p>
<img src="https://cdn.jsdelivr.net/gh/echo468/picgo@main/img/202305121549035.png" alt="image-20230512154907983" style="zoom:67%;" />

<p>​		对于三维场景来说，光线进入一个盒子，就说明三个对面都要满足光线已经进入（对所有的进入时间tmin取最大值）；光线离开一个盒子，只要满足光线离开任意一个对面（对所有的离开时间tmax取最小值）。如果进入时间小于离开时间，光线一定会在盒子中停留一段时间，即有交点。</p>
<img src="https://cdn.jsdelivr.net/gh/echo468/picgo@main/img/202305121559857.png" alt="image-20230512155903819" style="zoom: 67%;" />

<p>​		使用AABB便于计算，之前计算光线与任意平面求交计算很复杂。</p>
<img src="https://cdn.jsdelivr.net/gh/echo468/picgo@main/img/202305121628668.png" alt="image-20230512162803617" style="zoom:67%;" />

<p>​		如果光线离开盒子的时间＜0，说明盒子在光线背后。如果离开盒子的时间≥0，但是进入盒子的时间＜0，说明光线起点在盒子内部。如果离开时间＜进入时间，则没有交点。当且仅当进入时间小于离开时间，且进入时间≥0，光线与盒子有交点。（不考虑平行）</p>
<table>
<thead>
<tr>
<th align="center"><img src="https://cdn.jsdelivr.net/gh/echo468/picgo@main/img/202305121642550.png" alt="image-20230512164222503" style="zoom: 67%;" /></th>
<th align="center"><img src="https://cdn.jsdelivr.net/gh/echo468/picgo@main/img/202305121643720.png" alt="image-20230512164312676" style="zoom:67%;" /></th>
</tr>
</thead>
<tbody><tr>
<td align="center"><img src="https://cdn.jsdelivr.net/gh/echo468/picgo@main/img/202305121652618.png" alt="image-20230512165258572" style="zoom:67%;" /></td>
<td align="center"></td>
</tr>
</tbody></table>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
    </footer>
  </div>

    
 
   
</article>

    
  </article>
  

  
  <nav class="page-nav">
    
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/page/6/">6</a><a class="extend next" rel="next" href="/page/2/">下一页</a>
  </nav>
  
</section>
</div>

      <footer class="footer">
  <div class="outer">
    <ul>
      <li>
        Copyrights &copy;
        2020-2023
        <i class="ri-heart-fill heart_icon"></i> John Doe
      </li>
    </ul>
    <ul>
      <li>
        
        
        
        Powered by <a href="https://hexo.io" target="_blank">Hexo</a>
        <span class="division">|</span>
        Theme - <a href="https://github.com/Shen-Yu/hexo-theme-ayer" target="_blank">Ayer</a>
        
      </li>
    </ul>
    <ul>
      <li>
        
        
        <span>
  <span><i class="ri-user-3-fill"></i>Visitors:<span id="busuanzi_value_site_uv"></span></s>
  <span class="division">|</span>
  <span><i class="ri-eye-fill"></i>Views:<span id="busuanzi_value_page_pv"></span></span>
</span>
        
      </li>
    </ul>
    <ul>
      
        <li>
          <a href="http://www.beian.miit.gov.cn/" target="_black">赣ICP备2021001676号</a>
        </li>
        
    </ul>
    <ul>
      <li>
        <!-- cnzz统计 -->
        
        <script type="text/javascript" src='https://s9.cnzz.com/z_stat.php?id=1278069914&amp;web_id=1278069914'></script>
        
      </li>
    </ul>
  </div>
</footer>
      <div class="float_btns">
        <div class="totop" id="totop">
  <i class="ri-arrow-up-line"></i>
</div>

<div class="todark" id="todark">
  <i class="ri-moon-line"></i>
</div>

      </div>
    </main>
    <aside class="sidebar on">
      <button class="navbar-toggle"></button>
<nav class="navbar">
  
  <div class="logo">
    <a href="/"><img src="/images/ayer-side.svg" alt="Hexo"></a>
  </div>
  
  <ul class="nav nav-main">
    
    <li class="nav-item">
      <a class="nav-item-link" href="/">主页</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/archives">归档</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/categories">分类</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/tags">标签</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/friend">友链</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/journal">日志</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/2019/about">关于我</a>
    </li>
    
  </ul>
</nav>
<nav class="navbar navbar-bottom">
  <ul class="nav">
    <li class="nav-item">
      
      <a class="nav-item-link nav-item-search"  title="Search">
        <i class="ri-search-line"></i>
      </a>
      
      
      <a class="nav-item-link" target="_blank" href="/atom.xml" title="RSS Feed">
        <i class="ri-rss-line"></i>
      </a>
      
    </li>
  </ul>
</nav>
<div class="search-form-wrap">
  <div class="local-search local-search-plugin">
  <input type="search" id="local-search-input" class="local-search-input" placeholder="Search...">
  <div id="local-search-result" class="local-search-result"></div>
</div>
</div>
    </aside>
    <script>
      if (window.matchMedia("(max-width: 768px)").matches) {
        document.querySelector('.content').classList.remove('on');
        document.querySelector('.sidebar').classList.remove('on');
      }
    </script>
    <div id="mask"></div>

<!-- #reward -->
<div id="reward">
  <span class="close"><i class="ri-close-line"></i></span>
  <p class="reward-p"><i class="ri-cup-line"></i>请我喝杯咖啡吧~</p>
  <div class="reward-box">
    
    <div class="reward-item">
      <img class="reward-img" src="https://cdn.jsdelivr.net/gh/Shen-Yu/cdn/img/alipay.jpg">
      <span class="reward-type">支付宝</span>
    </div>
    
    
    <div class="reward-item">
      <img class="reward-img" src="https://cdn.jsdelivr.net/gh/Shen-Yu/cdn/img/wechat.jpg">
      <span class="reward-type">微信</span>
    </div>
    
  </div>
</div>
    
<script src="/js/jquery-2.0.3.min.js"></script>


<script src="/js/lazyload.min.js"></script>

<!-- Tocbot -->

<script src="https://cdn.jsdelivr.net/npm/jquery-modal@0.9.2/jquery.modal.min.js"></script>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/jquery-modal@0.9.2/jquery.modal.min.css">
<script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/js/jquery.justifiedGallery.min.js"></script>

<script src="/dist/main.js"></script>

<!-- ImageViewer -->

<!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                <!--  Controls are self-explanatory. Order can be changed. -->

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" style="display:none" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                        <div class="pswp__preloader__cut">
                            <div class="pswp__preloader__donut"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div>

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.css">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.min.css">
<script src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js"></script>

<script>
    function viewer_init() {
        let pswpElement = document.querySelectorAll('.pswp')[0];
        let $imgArr = document.querySelectorAll(('.article-entry img:not(.reward-img)'))

        $imgArr.forEach(($em, i) => {
            $em.onclick = () => {
                // slider展开状态
                // todo: 这样不好，后面改成状态
                if (document.querySelector('.left-col.show')) return
                let items = []
                $imgArr.forEach(($em2, i2) => {
                    let img = $em2.getAttribute('data-idx', i2)
                    let src = $em2.getAttribute('data-target') || $em2.getAttribute('src')
                    let title = $em2.getAttribute('alt')
                    // 获得原图尺寸
                    const image = new Image()
                    image.src = src
                    items.push({
                        src: src,
                        w: image.width || $em2.width,
                        h: image.height || $em2.height,
                        title: title
                    })
                })
                var gallery = new PhotoSwipe(pswpElement, PhotoSwipeUI_Default, items, {
                    index: parseInt(i)
                });
                gallery.init()
            }
        })
    }
    viewer_init()
</script>

<!-- MathJax -->

<!-- Katex -->

<!-- busuanzi  -->


<script src="/js/busuanzi-2.3.pure.min.js"></script>


<!-- ClickLove -->

<!-- ClickBoom1 -->

<script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script>

<script src="/js/clickBoom1.js"></script>


<!-- ClickBoom2 -->

<!-- CodeCopy -->


<link rel="stylesheet" href="/css/clipboard.css">

<script src="https://cdn.jsdelivr.net/npm/clipboard@2/dist/clipboard.min.js"></script>
<script>
  function wait(callback, seconds) {
    var timelag = null;
    timelag = window.setTimeout(callback, seconds);
  }
  !function (e, t, a) {
    var initCopyCode = function(){
      var copyHtml = '';
      copyHtml += '<button class="btn-copy" data-clipboard-snippet="">';
      copyHtml += '<i class="ri-file-copy-2-line"></i><span>COPY</span>';
      copyHtml += '</button>';
      $(".highlight .code pre").before(copyHtml);
      $(".article pre code").before(copyHtml);
      var clipboard = new ClipboardJS('.btn-copy', {
        target: function(trigger) {
          return trigger.nextElementSibling;
        }
      });
      clipboard.on('success', function(e) {
        let $btn = $(e.trigger);
        $btn.addClass('copied');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-checkbox-circle-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPIED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-checkbox-circle-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
      clipboard.on('error', function(e) {
        e.clearSelection();
        let $btn = $(e.trigger);
        $btn.addClass('copy-failed');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-time-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPY FAILED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-time-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
    }
    initCopyCode();
  }(window, document);
</script>


<!-- CanvasBackground -->


<script src="/js/dz.js"></script>



    
    <div id="music">
    
    
    
    <iframe frameborder="no" border="1" marginwidth="0" marginheight="0" width="200" height="52"
        src="//music.163.com/outchain/player?type=2&id=1441758494&auto=1&height=32"></iframe>
</div>

<style>
    #music {
        position: fixed;
        right: 15px;
        bottom: 0;
        z-index: 998;
    }
</style>
    
  </div>
</body>

</html>